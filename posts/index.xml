<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 翔仔的个人博客</title><link>https://fatedeity.cn/posts.html</link><description>Recent content in Posts on 翔仔的个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Nov 2022 08:26:21 +0800</lastBuildDate><atom:link href="https://fatedeity.cn/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>初识设计模式 - 解释器模式</title><link>https://fatedeity.cn/posts/programming-pattern/interpreter-design-pattern.html</link><pubDate>Fri, 11 Nov 2022 08:26:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/interpreter-design-pattern.html</guid><description>&lt;p>解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器。&lt;/p></description></item><item><title>初识设计模式 - 访问者模式</title><link>https://fatedeity.cn/posts/programming-pattern/visitor-design-pattern.html</link><pubDate>Thu, 10 Nov 2022 08:32:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/visitor-design-pattern.html</guid><description>&lt;p>访问者模式被认为是最复杂的设计模式，并且使用频率不高。大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。&lt;/p></description></item><item><title>初识设计模式 - 中介模式</title><link>https://fatedeity.cn/posts/programming-pattern/mediator-design-pattern.html</link><pubDate>Wed, 09 Nov 2022 08:36:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/mediator-design-pattern.html</guid><description>&lt;p>中介模式属于行为型设计模式，可以将原本难以理解的网状结构转换成了相对加单的星型结构，主要用来降低多个对象和类之间的通信复杂性。&lt;/p></description></item><item><title>初识设计模式 - 职责链模式</title><link>https://fatedeity.cn/posts/programming-pattern/chain-of-responsibility-design-pattern.html</link><pubDate>Tue, 08 Nov 2022 08:45:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/chain-of-responsibility-design-pattern.html</guid><description>&lt;p>职责链模式是一种与策略模式类似的设计模式，都是使用多个对象去处理同一个请求。不同的是，职责链模式针对的一条链路上的所有对象，而不是“非此即彼”的关系。&lt;/p></description></item><item><title>初识设计模式 - 备忘录模式</title><link>https://fatedeity.cn/posts/programming-pattern/memento-design-pattern.html</link><pubDate>Fri, 04 Nov 2022 08:54:02 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/memento-design-pattern.html</guid><description>&lt;p>备忘录模式是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。&lt;/p></description></item><item><title>MongoDB - 简单了解</title><link>https://fatedeity.cn/posts/database/mongodb-simple-know.html</link><pubDate>Tue, 01 Nov 2022 08:47:52 +0800</pubDate><guid>https://fatedeity.cn/posts/database/mongodb-simple-know.html</guid><description>&lt;p>MongoDB 是一个基于分布式文件存储的数据库，因此其常作为使用了大数据技术的公司的优选；MongoDB 的存储是类 JSON 结构，因此在一些敏捷 Web 开发中也常使用到。&lt;/p></description></item><item><title>初识设计模式 - 模板方法模式</title><link>https://fatedeity.cn/posts/programming-pattern/template-method-design-pattern.html</link><pubDate>Wed, 26 Oct 2022 08:43:06 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/template-method-design-pattern.html</guid><description>&lt;p>模板方法模式是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。&lt;/p></description></item><item><title>初识设计模式 - 状态模式</title><link>https://fatedeity.cn/posts/programming-pattern/state-design-pattern.html</link><pubDate>Tue, 25 Oct 2022 08:32:47 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/state-design-pattern.html</guid><description>&lt;p>顾名思义，状态模式用于解决系统中与状态相关的问题，如复杂对象的状态转换以及不同状态下行为的封装问题。&lt;/p></description></item><item><title>给 hugo 博客添加搜索功能</title><link>https://fatedeity.cn/posts/z-turn/hugo-add-local-search.html</link><pubDate>Mon, 24 Oct 2022 08:22:42 +0800</pubDate><guid>https://fatedeity.cn/posts/z-turn/hugo-add-local-search.html</guid><description>&lt;p>随着博客的文章越来越多，原本没有搜索功能的博客变得难以使用起来，博客添加一个搜索功能势在必行啊。&lt;/p></description></item><item><title>初识设计模式 - 命令模式</title><link>https://fatedeity.cn/posts/programming-pattern/command-design-pattern.html</link><pubDate>Fri, 21 Oct 2022 08:43:15 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/command-design-pattern.html</guid><description>&lt;p>命令模式是一种数据驱动的设计模式，它属于行为型设计模式。通过使用命令模式，可以极大地降低系统的耦合度。&lt;/p></description></item><item><title>通过 Github Action 实现定时推送天气预报</title><link>https://fatedeity.cn/posts/z-turn/github-action-weather-push.html</link><pubDate>Thu, 20 Oct 2022 20:22:34 +0800</pubDate><guid>https://fatedeity.cn/posts/z-turn/github-action-weather-push.html</guid><description>&lt;p>最近总是想做些小东西以打发自己的折腾之心，总是在想怎么将自己的代码知识引入到生活当中。通过 Github Action 实现定时推送天气预报就是一个简单的尝试，希望是一个好的开头。&lt;/p></description></item><item><title>初识设计模式 - 策略模式</title><link>https://fatedeity.cn/posts/programming-pattern/strategy-design-pattern.html</link><pubDate>Wed, 19 Oct 2022 10:52:45 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/strategy-design-pattern.html</guid><description>&lt;p>策略模式是一种非常容易理解的设计模式，其最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。&lt;/p></description></item><item><title>初识设计模式 - 观察者模式</title><link>https://fatedeity.cn/posts/programming-pattern/observer-design-pattern.html</link><pubDate>Mon, 17 Oct 2022 08:51:09 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/observer-design-pattern.html</guid><description>&lt;p>观察者模式是使用频率最高的设计模式之一，用于建立对象与对象之间的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p></description></item><item><title>初识设计模式 - 迭代器模式</title><link>https://fatedeity.cn/posts/programming-pattern/iterator-design-pattern.html</link><pubDate>Fri, 14 Oct 2022 08:53:55 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/iterator-design-pattern.html</guid><description>&lt;p>顾名思义，迭代器就是用于迭代操作的对象，其能够像有序序列一样迭代获取集合中对象，并且能够记录下当前所在位置，因此也称游标。&lt;/p></description></item><item><title>初识设计模式 - 享元模式</title><link>https://fatedeity.cn/posts/programming-pattern/flyweight-design-pattern.html</link><pubDate>Wed, 12 Oct 2022 08:48:39 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/flyweight-design-pattern.html</guid><description>&lt;p>享元设计模式（Flyweight Design Pattern）通过共享技术实现相同或相似对象的重用，节省内存，前提是享元对象是不可变对象。&lt;/p></description></item><item><title>初识设计模式 - 组合模式</title><link>https://fatedeity.cn/posts/programming-pattern/composite-design-pattern.html</link><pubDate>Tue, 11 Oct 2022 08:51:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/composite-design-pattern.html</guid><description>&lt;p>组合设计模式（Composite Design Pattern）其应用场景非常特殊，主要用于处理树形结构数据，它可以让叶子对象和容器对象的使用具有一致性。&lt;/p></description></item><item><title>初识设计模式 - 外观模式</title><link>https://fatedeity.cn/posts/programming-pattern/facade-design-pattern.html</link><pubDate>Sun, 09 Oct 2022 08:52:19 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/facade-design-pattern.html</guid><description>&lt;p>外观模式是最常用的结构型设计模式，也是一种非常容易理解的设计模式，其核心就是为多个子系统提供一个统一的接口，将这个接口看作是这些子系统的门面。&lt;/p></description></item><item><title>初识设计模式 - 适配器模式</title><link>https://fatedeity.cn/posts/programming-pattern/adapter-design-pattern.html</link><pubDate>Fri, 30 Sep 2022 08:15:49 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/adapter-design-pattern.html</guid><description>&lt;p>适配器设计模式（Adapter Design Pattern）可以将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。&lt;/p></description></item><item><title>初识设计模式 - 装饰器模式</title><link>https://fatedeity.cn/posts/programming-pattern/decorator-design-pattern.html</link><pubDate>Thu, 29 Sep 2022 08:24:49 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/decorator-design-pattern.html</guid><description>&lt;p>装饰器模式（Decorator Design Pattern）是一种结构型设计模式，通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。简单地说，就是允许向一个现有的功能添加新的功能，同时又不改变其结构。&lt;/p></description></item><item><title>初识设计模式 - 桥接模式</title><link>https://fatedeity.cn/posts/programming-pattern/bridge-design-pattern.html</link><pubDate>Tue, 27 Sep 2022 09:03:06 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/bridge-design-pattern.html</guid><description>&lt;p>桥接模式是一种在日常开发中不是特别常用的设计模式，主要是因为上手难度较大，但是对于理解面向对象设计有非常大的帮助。&lt;/p></description></item><item><title>初识设计模式 - 代理模式</title><link>https://fatedeity.cn/posts/programming-pattern/proxy-design-pattern.html</link><pubDate>Mon, 26 Sep 2022 08:36:29 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/proxy-design-pattern.html</guid><description>&lt;p>代理设计模式（Proxy Design Pattern）指的是，在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能，即扩展目标对象的功能。&lt;/p></description></item><item><title>初识设计模式 - 原型模式</title><link>https://fatedeity.cn/posts/programming-pattern/prototype-design-pattern.html</link><pubDate>Sun, 25 Sep 2022 13:33:22 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/prototype-design-pattern.html</guid><description>&lt;p>原型模式是创建型模式的一种，其特点在于通过 &lt;strong>复制&lt;/strong> 一个已经存在的实例来返回新的实例,而不是新建实例。&lt;/p></description></item><item><title>初识设计模式 - 建造者模式</title><link>https://fatedeity.cn/posts/programming-pattern/builder-design-pattern.html</link><pubDate>Thu, 01 Sep 2022 08:41:07 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/builder-design-pattern.html</guid><description>&lt;p>顾名思义，如何建房子一样，建造者模式可以将复杂对象的建造过程抽象出来，使用相同的构建过程可以构造出不同表现的对象。&lt;/p></description></item><item><title>初识设计模式 - 工厂模式</title><link>https://fatedeity.cn/posts/programming-pattern/factory-design-pattern.html</link><pubDate>Tue, 30 Aug 2022 09:15:59 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/factory-design-pattern.html</guid><description>&lt;p>创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂设计模式通过定义一个单独的创建对象的方法来解决这些问题。&lt;/p></description></item><item><title>初识设计模式 - 单例模式</title><link>https://fatedeity.cn/posts/programming-pattern/singleton-design-pattern.html</link><pubDate>Fri, 26 Aug 2022 08:32:04 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/singleton-design-pattern.html</guid><description>&lt;p>单例模式是一种创建型设计模式，让开发者能够保证一个类只有一个实例，并提供一个访问该实例的全局节点，有助于协调系统整体的行为。&lt;/p></description></item><item><title>LeetCode - 三数之和</title><link>https://fatedeity.cn/posts/leetcode/three-sum.html</link><pubDate>Tue, 23 Aug 2022 10:03:43 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/three-sum.html</guid><description/></item><item><title>经典设计原则</title><link>https://fatedeity.cn/posts/programming-pattern/classic-design-principles.html</link><pubDate>Mon, 22 Aug 2022 08:41:52 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/classic-design-principles.html</guid><description>&lt;p>设计原则为提高可维护性和可复用性而生，每一种设计模式都符合一个或多个设计原则，因此设计原则也是评价一个设计模式使用效果的重要指标之一。&lt;/p></description></item><item><title>经典设计原则 - SOLID</title><link>https://fatedeity.cn/posts/programming-pattern/classic-design-principles-solid.html</link><pubDate>Thu, 18 Aug 2022 11:24:08 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/classic-design-principles-solid.html</guid><description>&lt;p>SOLID 原则是面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。&lt;/p></description></item><item><title>LeetCode - 最长公共前缀</title><link>https://fatedeity.cn/posts/leetcode/longest-common-prefix.html</link><pubDate>Fri, 12 Aug 2022 08:46:26 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/longest-common-prefix.html</guid><description/></item><item><title>基于接口而非实现编程</title><link>https://fatedeity.cn/posts/programming-pattern/base-interface-not-implementation.html</link><pubDate>Mon, 08 Aug 2022 11:51:09 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/base-interface-not-implementation.html</guid><description>&lt;p>“基于接口而非实现编程”是一条比较抽象、泛化的设计思想，其的另一个表述是“基于抽象而非实现编程”。从这条设计思想中衍生的理解就是，越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。&lt;/p></description></item><item><title>面向对象的基础知识</title><link>https://fatedeity.cn/posts/programming-pattern/object-oriented-basic.html</link><pubDate>Thu, 04 Aug 2022 15:50:27 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/object-oriented-basic.html</guid><description>&lt;p>面向对象是一种软件开发的编程范式。其概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD 技术、人工智能等领域。&lt;/p></description></item><item><title>设计模式的基础知识</title><link>https://fatedeity.cn/posts/programming-pattern/design-pattern-basic.html</link><pubDate>Thu, 28 Jul 2022 16:12:34 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/design-pattern-basic.html</guid><description>&lt;p>作为一个开发人员，都想写出一手好的代码，而不是别人称的“屎山”，设计模式提供了一系列常见问题的解决方案，通过利用设计模式来尽可能统一规范，可以提高代码的可维护性、可读性、可扩展性。&lt;/p></description></item><item><title>LeetCode - 寻找两个正序数组的中位数</title><link>https://fatedeity.cn/posts/leetcode/median-of-two-sorted-arrays.html</link><pubDate>Wed, 27 Jul 2022 21:58:06 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/median-of-two-sorted-arrays.html</guid><description/></item><item><title>四大经典算法思想</title><link>https://fatedeity.cn/posts/data-structure-algorithm/classical-algorithm-thought.html</link><pubDate>Mon, 25 Jul 2022 09:10:18 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/classical-algorithm-thought.html</guid><description>&lt;p>学习任何东西，都需要深究其底层，掌握其思想，融会贯通才能应万变。对于算法而言，同样如此，编程的算法题千千万，刷题是刷不完的，还是需要掌握算法的思想才能掌握如何求解算法题。&lt;/p></description></item><item><title>LeetCode - 整数反转</title><link>https://fatedeity.cn/posts/leetcode/reverse-integer.html</link><pubDate>Fri, 22 Jul 2022 10:07:28 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/reverse-integer.html</guid><description/></item><item><title>LeetCode - 回文数</title><link>https://fatedeity.cn/posts/leetcode/palindrome-number.html</link><pubDate>Wed, 20 Jul 2022 11:49:26 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/palindrome-number.html</guid><description/></item><item><title>LeetCode - 无重复字符的最长子串</title><link>https://fatedeity.cn/posts/leetcode/longest-substring-without-repeating-characters.html</link><pubDate>Mon, 18 Jul 2022 09:10:30 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/longest-substring-without-repeating-characters.html</guid><description/></item><item><title>博客从 CloudBase 迁移至云主机</title><link>https://fatedeity.cn/posts/z-turn/blog-migration-from-cloudbase-to-server.html</link><pubDate>Sat, 16 Jul 2022 17:20:26 +0800</pubDate><guid>https://fatedeity.cn/posts/z-turn/blog-migration-from-cloudbase-to-server.html</guid><description>&lt;p>本来博客部署在 CloudBase 也挺好，没有什么访问量的博客一个月也花不了几毛钱，在这个上面基本是无感了。奈何腾讯准备更改 CloudBase 的计费模式，为了省那一点钱，还是将博客迁移到自己的服务器上吧。&lt;/p></description></item><item><title>LeetCode - 两数相加</title><link>https://fatedeity.cn/posts/leetcode/add-two-numbers.html</link><pubDate>Fri, 15 Jul 2022 09:00:21 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/add-two-numbers.html</guid><description/></item><item><title>LeetCode - 两数之和</title><link>https://fatedeity.cn/posts/leetcode/two-sum.html</link><pubDate>Tue, 12 Jul 2022 20:25:11 +0800</pubDate><guid>https://fatedeity.cn/posts/leetcode/two-sum.html</guid><description/></item><item><title>插值查找的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/interpolation-search.html</link><pubDate>Tue, 05 Jul 2022 20:11:38 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/interpolation-search.html</guid><description>&lt;p>插值查找和二分查找一样，是有序表的一种查找算法，其基于二分查找，将查找点的选择改进为自适应选择，提高查找效率。&lt;/p></description></item><item><title>二分查找的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/binary-search.html</link><pubDate>Mon, 04 Jul 2022 10:03:17 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/binary-search.html</guid><description>&lt;p>二分查找是一种提升有序序列搜索效率的查找算法，大大降低了数组查找的时间，其类似的思想也应用到二叉树、数据库索引等场景。&lt;/p></description></item><item><title>基数排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/radix-sort.html</link><pubDate>Sat, 02 Jul 2022 15:01:22 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/radix-sort.html</guid><description>&lt;p>基数排序是桶排序的一种扩展使用，同样是一种非比较的整数排序算法，其原理是将整数位数切割成不同的数字，然后按每个位数分别比较。&lt;/p></description></item><item><title>桶排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/bucket-sort.html</link><pubDate>Thu, 30 Jun 2022 08:42:29 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/bucket-sort.html</guid><description>&lt;p>桶排序是计数排序的一种扩展使用，适用于元素值范围不大的序列。如果对大量学生的考试成绩做排序，就非常适合使用桶排序。&lt;/p></description></item><item><title>计数排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/count-sort.html</link><pubDate>Tue, 28 Jun 2022 21:49:04 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/count-sort.html</guid><description>&lt;p>学习计数排序可以了解到空间换时间的思想，其是一种牺牲空间换时间的排序算法，在其特定的场景上，甚至将时间复杂度降到了线性级别。&lt;/p></description></item><item><title>归并排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/merge-sort.html</link><pubDate>Fri, 24 Jun 2022 08:58:56 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/merge-sort.html</guid><description>&lt;p>归并排序与与快速排序一样，是采用分治法（Divide and Conquer）的一个非常典型的应用，在排序算法中，同时了解归并排序和快速排序，相互印证，能理解得更深。&lt;/p></description></item><item><title>快速排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/quick-sort.html</link><pubDate>Thu, 23 Jun 2022 08:49:12 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/quick-sort.html</guid><description>&lt;p>快速排序是面试当中最常见的排序算法问题了，除了需要理解快速排序的流程，还要理解一些快速排序的代码实现，了解一些优化方法。&lt;/p></description></item><item><title>希尔排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/shell-sort.html</link><pubDate>Wed, 22 Jun 2022 14:07:42 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/shell-sort.html</guid><description>&lt;p>插入排序在对基本有序的较小序列进行排序时，效率是非常高的，希尔排序针对这一点对插入排序的方式进行了再次优化。&lt;/p></description></item><item><title>插入排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/insertion-sort.html</link><pubDate>Mon, 20 Jun 2022 14:13:24 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/insertion-sort.html</guid><description>&lt;p>插入排对是一个容易被低估的排序算法，虽然其时间复杂度看起来与冒泡排序和选择排序差不多，但是用在相对有序的短序列中却格外的好。&lt;/p></description></item><item><title>选择排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/selection-sort.html</link><pubDate>Sun, 19 Jun 2022 11:47:05 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/selection-sort.html</guid><description>&lt;p>选择排序的概念非常容易理解，按照一般的思路，排序就是每次从原来的序列中拿出最小的元素即可，最终得到的序列就是有序序列。&lt;/p></description></item><item><title>冒泡排序的简单理解</title><link>https://fatedeity.cn/posts/data-structure-algorithm/bubble-sort.html</link><pubDate>Sat, 18 Jun 2022 10:46:47 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/bubble-sort.html</guid><description>&lt;p>冒泡排序是学习排序算法时最先遇到的算法，其形象名称和排序过程最容易记住，很多人会在面试时谈论起，真正理解了冒泡排序算法才能更深入地学习其他排序算法。&lt;/p></description></item><item><title>如何分析排序算法</title><link>https://fatedeity.cn/posts/data-structure-algorithm/analyze-sorting-algorithms.html</link><pubDate>Thu, 16 Jun 2022 16:32:27 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/analyze-sorting-algorithms.html</guid><description>&lt;p>学习排序算法，除了学习它的算法原理和代码实现之外，更重要的是要学会如何评价、分析排序算法。其实，排序算法主要是从执行效率、内存消耗、稳定性三个方面进行分析。&lt;/p></description></item><item><title>算法的复杂度分析</title><link>https://fatedeity.cn/posts/data-structure-algorithm/complexity-analysis.html</link><pubDate>Tue, 14 Jun 2022 15:52:09 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/complexity-analysis.html</guid><description>&lt;p>对一个算法做复杂度分析是学习算法必备的知识点，当掌握了如何对一个算法做复杂度分析，在优化算法方面将会如虎添翼。&lt;/p></description></item><item><title>一致性哈希的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/consistent-hash-basic.html</link><pubDate>Sun, 12 Jun 2022 18:47:54 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/consistent-hash-basic.html</guid><description>&lt;p>一致性哈希是一种特殊的哈希表使用方式，它解决了简单哈希算法在分布式散列表中存在的动态伸缩问题。其能在保证增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销。&lt;/p></description></item><item><title>B+ 树的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/b+-tree-basic.html</link><pubDate>Sun, 12 Jun 2022 10:03:09 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/b+-tree-basic.html</guid><description>&lt;p>B+ 树通常用于数据库和操作系统的文件系统中，对内存与磁盘之间的交互提供了非常大的遍历，是一种常见的存储在磁盘的索引结构。&lt;/p></description></item><item><title>B 树的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/b-tree-basic.html</link><pubDate>Fri, 10 Jun 2022 22:24:19 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/b-tree-basic.html</guid><description>&lt;p>在计算机科学中，B 树是一种自平衡的树，能够保持数据有序。其适用于读写相对大的数据块的存储系统，例如磁盘，因此也常作为数据库系统的索引结构。&lt;/p></description></item><item><title>AVL 树的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/avl-tree-basic.html</link><pubDate>Thu, 02 Jun 2022 19:41:08 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/avl-tree-basic.html</guid><description>&lt;p>AVL 树是最早被发明的自平衡的二叉查找树，在 AVL 树中，任意结点的两个子树的高度最大差别为 1，所以它也被称为高度平衡树，其本质仍然是一颗二叉查找树。&lt;/p></description></item><item><title>跳表的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/skip-list-basic.html</link><pubDate>Wed, 01 Jun 2022 19:15:20 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/skip-list-basic.html</guid><description>&lt;p>有序的数组可以使用二分查找的方法快速检索一个数据，但是同为线性表结构的链表没有办法使用二分查找，而跳表突破了这个限制，允许链表使用类似于二分查找的方法查找数据。&lt;/p></description></item><item><title>哈希表的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/hash-basic.html</link><pubDate>Tue, 31 May 2022 20:29:14 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/hash-basic.html</guid><description>&lt;p>哈希表也被称为散列表，其实现使用到了散列技术，散列技术在理想情况下，无须任何比较就可以找到待查关键字，查找的效率非常高。&lt;/p></description></item><item><title>堆的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/heap-basic.html</link><pubDate>Thu, 26 May 2022 08:19:58 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/heap-basic.html</guid><description>&lt;p>从逻辑结构上看，堆是一种非常特别的树形结构，从应用场景上看，与常见的树形结构又完全不同，使用堆还能解决许多独特的问题。&lt;/p></description></item><item><title>二叉树的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/binary-tree-basic.html</link><pubDate>Tue, 24 May 2022 08:54:49 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/binary-tree-basic.html</guid><description>&lt;p>二叉树是树形结构的一种重要类型，许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，因此二叉树显得格外重要。&lt;/p></description></item><item><title>队列的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/queue-basic.html</link><pubDate>Mon, 23 May 2022 16:13:38 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/queue-basic.html</guid><description>&lt;p>队列这个概念非常容易理解，将队列比喻成只能同时通过一辆汽车的隧道，当汽车进入到隧道内部，只能先进隧道的汽车先出隧道，后进隧道的汽车后出隧道。&lt;/p></description></item><item><title>栈的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/stack-basic.html</link><pubDate>Sat, 21 May 2022 08:20:15 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/stack-basic.html</guid><description>&lt;p>数据结构中的栈是一种操作受限的线性表，只允许在一端插入和删除数据，但却是计算机科学领域中非常重要的数据结构，常使用在底层结构。&lt;/p></description></item><item><title>链表的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/linked-list-basic.html</link><pubDate>Fri, 20 May 2022 11:46:56 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/linked-list-basic.html</guid><description>&lt;p>链表是两大物理存储结构之一，与数组使用一组连续的内存空间不同，链表通过链接的方式将零散的内存空间串联起来使用，是线性表的另一种存储方式。&lt;/p></description></item><item><title>数组的简单认识</title><link>https://fatedeity.cn/posts/data-structure-algorithm/array-basic.html</link><pubDate>Thu, 19 May 2022 20:49:47 +0800</pubDate><guid>https://fatedeity.cn/posts/data-structure-algorithm/array-basic.html</guid><description>&lt;p>数组是最基础的数据结构，也是两大物理存储结构之一，只有深刻理解了数组的概念和特性，才能算是迈入学习数据结构的殿堂，才能将抽象的数据结构映射到代码当中。&lt;/p></description></item></channel></rss>