<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面向对象 on 翔仔的个人博客</title><link>https://fatedeity.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</link><description>Recent content in 面向对象 on 翔仔的个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Nov 2022 08:26:21 +0800</lastBuildDate><atom:link href="https://fatedeity.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>初识设计模式 - 解释器模式</title><link>https://fatedeity.cn/posts/programming-pattern/interpreter-design-pattern.html</link><pubDate>Fri, 11 Nov 2022 08:26:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/interpreter-design-pattern.html</guid><description>&lt;p>解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器。&lt;/p></description></item><item><title>初识设计模式 - 访问者模式</title><link>https://fatedeity.cn/posts/programming-pattern/visitor-design-pattern.html</link><pubDate>Thu, 10 Nov 2022 08:32:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/visitor-design-pattern.html</guid><description>&lt;p>访问者模式被认为是最复杂的设计模式，并且使用频率不高。大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。&lt;/p></description></item><item><title>初识设计模式 - 中介模式</title><link>https://fatedeity.cn/posts/programming-pattern/mediator-design-pattern.html</link><pubDate>Wed, 09 Nov 2022 08:36:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/mediator-design-pattern.html</guid><description>&lt;p>中介模式属于行为型设计模式，可以将原本难以理解的网状结构转换成了相对加单的星型结构，主要用来降低多个对象和类之间的通信复杂性。&lt;/p></description></item><item><title>初识设计模式 - 职责链模式</title><link>https://fatedeity.cn/posts/programming-pattern/chain-of-responsibility-design-pattern.html</link><pubDate>Tue, 08 Nov 2022 08:45:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/chain-of-responsibility-design-pattern.html</guid><description>&lt;p>职责链模式是一种与策略模式类似的设计模式，都是使用多个对象去处理同一个请求。不同的是，职责链模式针对的一条链路上的所有对象，而不是“非此即彼”的关系。&lt;/p></description></item><item><title>初识设计模式 - 备忘录模式</title><link>https://fatedeity.cn/posts/programming-pattern/memento-design-pattern.html</link><pubDate>Fri, 04 Nov 2022 08:54:02 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/memento-design-pattern.html</guid><description>&lt;p>备忘录模式是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。&lt;/p></description></item><item><title>初识设计模式 - 模板方法模式</title><link>https://fatedeity.cn/posts/programming-pattern/template-method-design-pattern.html</link><pubDate>Wed, 26 Oct 2022 08:43:06 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/template-method-design-pattern.html</guid><description>&lt;p>模板方法模式是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。&lt;/p></description></item><item><title>初识设计模式 - 状态模式</title><link>https://fatedeity.cn/posts/programming-pattern/state-design-pattern.html</link><pubDate>Tue, 25 Oct 2022 08:32:47 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/state-design-pattern.html</guid><description>&lt;p>顾名思义，状态模式用于解决系统中与状态相关的问题，如复杂对象的状态转换以及不同状态下行为的封装问题。&lt;/p></description></item><item><title>初识设计模式 - 命令模式</title><link>https://fatedeity.cn/posts/programming-pattern/command-design-pattern.html</link><pubDate>Fri, 21 Oct 2022 08:43:15 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/command-design-pattern.html</guid><description>&lt;p>命令模式是一种数据驱动的设计模式，它属于行为型设计模式。通过使用命令模式，可以极大地降低系统的耦合度。&lt;/p></description></item><item><title>初识设计模式 - 策略模式</title><link>https://fatedeity.cn/posts/programming-pattern/strategy-design-pattern.html</link><pubDate>Wed, 19 Oct 2022 10:52:45 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/strategy-design-pattern.html</guid><description>&lt;p>策略模式是一种非常容易理解的设计模式，其最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。&lt;/p></description></item><item><title>初识设计模式 - 观察者模式</title><link>https://fatedeity.cn/posts/programming-pattern/observer-design-pattern.html</link><pubDate>Mon, 17 Oct 2022 08:51:09 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/observer-design-pattern.html</guid><description>&lt;p>观察者模式是使用频率最高的设计模式之一，用于建立对象与对象之间的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p></description></item><item><title>初识设计模式 - 迭代器模式</title><link>https://fatedeity.cn/posts/programming-pattern/iterator-design-pattern.html</link><pubDate>Fri, 14 Oct 2022 08:53:55 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/iterator-design-pattern.html</guid><description>&lt;p>顾名思义，迭代器就是用于迭代操作的对象，其能够像有序序列一样迭代获取集合中对象，并且能够记录下当前所在位置，因此也称游标。&lt;/p></description></item><item><title>初识设计模式 - 享元模式</title><link>https://fatedeity.cn/posts/programming-pattern/flyweight-design-pattern.html</link><pubDate>Wed, 12 Oct 2022 08:48:39 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/flyweight-design-pattern.html</guid><description>&lt;p>享元设计模式（Flyweight Design Pattern）通过共享技术实现相同或相似对象的重用，节省内存，前提是享元对象是不可变对象。&lt;/p></description></item><item><title>初识设计模式 - 组合模式</title><link>https://fatedeity.cn/posts/programming-pattern/composite-design-pattern.html</link><pubDate>Tue, 11 Oct 2022 08:51:21 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/composite-design-pattern.html</guid><description>&lt;p>组合设计模式（Composite Design Pattern）其应用场景非常特殊，主要用于处理树形结构数据，它可以让叶子对象和容器对象的使用具有一致性。&lt;/p></description></item><item><title>初识设计模式 - 外观模式</title><link>https://fatedeity.cn/posts/programming-pattern/facade-design-pattern.html</link><pubDate>Sun, 09 Oct 2022 08:52:19 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/facade-design-pattern.html</guid><description>&lt;p>外观模式是最常用的结构型设计模式，也是一种非常容易理解的设计模式，其核心就是为多个子系统提供一个统一的接口，将这个接口看作是这些子系统的门面。&lt;/p></description></item><item><title>初识设计模式 - 适配器模式</title><link>https://fatedeity.cn/posts/programming-pattern/adapter-design-pattern.html</link><pubDate>Fri, 30 Sep 2022 08:15:49 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/adapter-design-pattern.html</guid><description>&lt;p>适配器设计模式（Adapter Design Pattern）可以将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。&lt;/p></description></item><item><title>初识设计模式 - 装饰器模式</title><link>https://fatedeity.cn/posts/programming-pattern/decorator-design-pattern.html</link><pubDate>Thu, 29 Sep 2022 08:24:49 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/decorator-design-pattern.html</guid><description>&lt;p>装饰器模式（Decorator Design Pattern）是一种结构型设计模式，通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。简单地说，就是允许向一个现有的功能添加新的功能，同时又不改变其结构。&lt;/p></description></item><item><title>初识设计模式 - 桥接模式</title><link>https://fatedeity.cn/posts/programming-pattern/bridge-design-pattern.html</link><pubDate>Tue, 27 Sep 2022 09:03:06 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/bridge-design-pattern.html</guid><description>&lt;p>桥接模式是一种在日常开发中不是特别常用的设计模式，主要是因为上手难度较大，但是对于理解面向对象设计有非常大的帮助。&lt;/p></description></item><item><title>初识设计模式 - 代理模式</title><link>https://fatedeity.cn/posts/programming-pattern/proxy-design-pattern.html</link><pubDate>Mon, 26 Sep 2022 08:36:29 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/proxy-design-pattern.html</guid><description>&lt;p>代理设计模式（Proxy Design Pattern）指的是，在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能，即扩展目标对象的功能。&lt;/p></description></item><item><title>初识设计模式 - 原型模式</title><link>https://fatedeity.cn/posts/programming-pattern/prototype-design-pattern.html</link><pubDate>Sun, 25 Sep 2022 13:33:22 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/prototype-design-pattern.html</guid><description>&lt;p>原型模式是创建型模式的一种，其特点在于通过 &lt;strong>复制&lt;/strong> 一个已经存在的实例来返回新的实例,而不是新建实例。&lt;/p></description></item><item><title>初识设计模式 - 建造者模式</title><link>https://fatedeity.cn/posts/programming-pattern/builder-design-pattern.html</link><pubDate>Thu, 01 Sep 2022 08:41:07 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/builder-design-pattern.html</guid><description>&lt;p>顾名思义，如何建房子一样，建造者模式可以将复杂对象的建造过程抽象出来，使用相同的构建过程可以构造出不同表现的对象。&lt;/p></description></item><item><title>初识设计模式 - 工厂模式</title><link>https://fatedeity.cn/posts/programming-pattern/factory-design-pattern.html</link><pubDate>Tue, 30 Aug 2022 09:15:59 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/factory-design-pattern.html</guid><description>&lt;p>创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂设计模式通过定义一个单独的创建对象的方法来解决这些问题。&lt;/p></description></item><item><title>初识设计模式 - 单例模式</title><link>https://fatedeity.cn/posts/programming-pattern/singleton-design-pattern.html</link><pubDate>Fri, 26 Aug 2022 08:32:04 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/singleton-design-pattern.html</guid><description>&lt;p>单例模式是一种创建型设计模式，让开发者能够保证一个类只有一个实例，并提供一个访问该实例的全局节点，有助于协调系统整体的行为。&lt;/p></description></item><item><title>基于接口而非实现编程</title><link>https://fatedeity.cn/posts/programming-pattern/base-interface-not-implementation.html</link><pubDate>Mon, 08 Aug 2022 11:51:09 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/base-interface-not-implementation.html</guid><description>&lt;p>“基于接口而非实现编程”是一条比较抽象、泛化的设计思想，其的另一个表述是“基于抽象而非实现编程”。从这条设计思想中衍生的理解就是，越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。&lt;/p></description></item><item><title>面向对象的基础知识</title><link>https://fatedeity.cn/posts/programming-pattern/object-oriented-basic.html</link><pubDate>Thu, 04 Aug 2022 15:50:27 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/object-oriented-basic.html</guid><description>&lt;p>面向对象是一种软件开发的编程范式。其概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD 技术、人工智能等领域。&lt;/p></description></item><item><title>设计模式的基础知识</title><link>https://fatedeity.cn/posts/programming-pattern/design-pattern-basic.html</link><pubDate>Thu, 28 Jul 2022 16:12:34 +0800</pubDate><guid>https://fatedeity.cn/posts/programming-pattern/design-pattern-basic.html</guid><description>&lt;p>作为一个开发人员，都想写出一手好的代码，而不是别人称的“屎山”，设计模式提供了一系列常见问题的解决方案，通过利用设计模式来尽可能统一规范，可以提高代码的可维护性、可读性、可扩展性。&lt;/p></description></item></channel></rss>