[{"categories":["程序设计"],"content":"通常，不同的公司里有着不同的编码规范，主要是从代码得准确性、稳定性、可读性等地方着手制定，以提高团队成员之间的协作效率，这里主要是列出一些常见的编码规范。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:0:0","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"命名规范 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:1:0","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"命名长度 命名的原则以准确达意为目标，其长度以遵循此原则为主，并且是越短越好。 对于公认、熟知的词，可以在项目内部统一成缩写 对于作用域较小的变量，可以使用较短的命名 对于作用域较大的变量，推荐使用可达意的较长的命名 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:1:1","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"命名上下文 命名时可以根据上下文来简化命名，如在 User 类中，就不需要对类中的成员变量添加 user 前缀，而是直接命名如 name、password 等名称。 在使用时，开发者也可以借助上下文明确变量的含义。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:1:2","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"可读性 可读性指的是不使用特别生僻、难发音的英文单词来命名，同时也不要使用一些无意义、随意搭配的单词。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:1:3","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"可搜索性 命名可搜索性指的是，使用 IDE 开发的时候，可以很方便地使用“关键词联想”功能快速补全。 这个原则指的是，最好能在项目、团队内部统一命名方式，如都使用 selectXXX 表示查询，而不是既有 selectXXX，也有 findXXX 或 queryXXX 等多种命名方式表示查询。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:1:4","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"接口、抽象类 对于接口的命名，通常有两种比较常见的方式：一种是接口加前缀 I 表示 Interface，如 IUserService；另一种是实现类加后缀 Impl 表示 implements，如 UserServiceImpl。 对于抽象类的命名，也有两种常见的方式：一种是带上前缀 Abstract 表示抽象类，如 AbstractConfig；另一种是不带前缀。 无论是接口还是抽象类，选择哪个命名方式都可以，最重要的是能在项目内部统一。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:1:5","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"注释规范 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:0","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"注释内容 注释的目的是让代码更容易看懂。 注释的内容主要是包括三个方面：做什么、为什么做、怎么做。对于复杂的接口或类，还需要补充“如何用”。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:1","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"注释多少 注释本身有一定的维护成本，并非越多越好。 类和函数一定要写注释，而且要写得尽可能全面、详细，函数内部的注释要相对少一些，一般可以通过好的命名、提炼函数、解释性变量、总结性注释等方式来提高代码可读性。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:2","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"代码风格 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:3","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"类和函数的行数 对于函数代码行数的最大限制，网上有一种说法：最好不要超过一个显示屏的垂直高度。 对于类的代码行数的最大限制，有一个间接的判断标准： 当一个类的代码读起来比较困难 实现某个功能时不知道该用哪个函数 想用哪个函数的时候需要找很久 只用到一个小功能的时候要引入整个类 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:4","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"一行代码的长度 总体遵循一个原则：一行代码最长不能超过 IDE 显示的宽度。 需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读；但是太小的限制也会导致很多稍长点的语句被折成两行。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:5","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"分隔单元块 对于比较长的函数，如果逻辑上可以分为几个独立的代码块，但是又不方便将这些独立的代码块抽取成小函数的时候，可以使用总结性注释的方式分隔代码块。 除此之外，还可以通过使用空行分隔代码块。如类的成员变量和函数之间、静态成员变量和普通成员变量之间、各函数之间、甚至是各成员变量之间。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:6","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"类成员的排列顺序 在 Google Java 编程规范中，依赖类按照字母序从小到大排列、类中先写成员变量后写函数、成员变量之间或函数之间先写静态成员变量或函数（按照作用域大小依次排列）。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:2:7","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"常用技巧 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:0","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"善于提炼函数 对于逻辑比较复杂的代码，通常是建议提炼出类或者函数，但也避免提炼出的函数只包含两三行代码，以增加阅读成本。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:1","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"避免函数参数过多 通常函数的参数超过 5 个时候就会影响到代码的可读性，使用起来也不方便。 出现函数参数较多的情况，通常有两个解决办法：根据单一职责原则拆分成多个函数；将函数的参数封装成对象。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:2","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"勿用函数参数控制逻辑 切勿在函数内部根据函数的参数来控制内部逻辑，如根据 isVip = true 时走 VIP 的逻辑、isVip = false 走非 VIP 的逻辑。 针对于这样情况，通常是根据需求将其拆分成多个函数，拆分之后的函数职责更明确。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:3","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"函数设计要职责单一 不只是针对类、模块而言，对于函数的设计，更要满足单一职责原则。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:4","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"移除过深的嵌套 代码嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套，以避免难以理解和代码缩进过多。 解决代码嵌套过深的方法有以下几种思路： 去掉多余的 if 或者 else 语句 使用编程语言提供的 continue、break、return 关键字提前退出嵌套 调整执行顺序来减少嵌套 将部分嵌套的逻辑封装成函数调用，以此来减少嵌套 使用多态来替代 if-else、switch-case 条件判断 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:5","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"使用解释性变量 使用解释性变量可以提高代码的可读性，常见的情况有以下几种： 使用常量取代魔法数字 使用解释性变量来解释复杂表达式 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:3:6","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"函数错误返回 函数的运行结果可以分为两类：正确情况下输出的预期结果，异常（出错）情况下输出的非预期结果。 在异常情况下，函数返回的数据类型非常灵活，可以针对不同的场景和特点选择不同的返回值。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:4:0","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"返回错误码 C 语言没有异常这样的语法机制，返回错误码是最常见的出错处理方式。 而 Java、Python 等比较新的编程语言，大部分情况下，都用异常来处理函数出错的情况，极少会用到错误码。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:4:1","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"返回 NULL 值 在多数编程语言中，使用 NULL 值表示“不存在”这种语义。 对于查找函数来说，数据不存在并非一种异常情况，是一种正常行为，所以返回表示“不存在”语义的 NULL 值比返回异常更加合理。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:4:2","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"返回空对象 返回 NULL 值有各种弊端，对此有一个比较经典的应对策略，那就是应用空对象设计模式。 当函数返回的数据类型是字符串类型或者集合类型的时候，可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:4:3","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["程序设计"],"content":"抛出异常对象 最常用的函数出错处理方式是抛出异常。异常可以将正常逻辑和异常逻辑的处理分离开，这样的代码可读性会更好。 对于抛出的异常对象，通常有以下几种处理方式： 直接吞掉，如在捕捉之后只记录日志，不做任何处理 原封不动的重新抛出，如在调用的函数外部重新抛出相同的异常 包装新的异常重新抛出，如在捕捉之后抛出另一个的异常 ","date":"2023-02-02","objectID":"/posts/programming-pattern/command-coding-style-standard.html:4:4","tags":["规范"],"title":"常见编码规范","uri":"/posts/programming-pattern/command-coding-style-standard.html"},{"categories":["数据库技术"],"content":"Redis 每秒可以处理超过 10 万次读写操作，是已知性能最快的 key-value 数据库，称得上是必须要学会的知识。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:0:0","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"简介 Redis 的全称是 Remote Dictionary Server，是一个使用 C 语言编写的、开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。 Redis 的数据是存储在内存中的，所以读写速度非常快，被广泛应用于缓存方向，当然也有持久化数据库的用法。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:1:0","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"优缺点 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:2:0","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"优点 读写性能优异， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s 数据类型丰富，有 String、List、Hash、Set、SortedSet 等 单线程原子性，Redis 所有的操作都是原子性的，也支持多个操作合并后的原子执行 丰富的特性，Redis 支持发布订阅、通知、key 过期等功能 支持持久化，Redis 支持 RDB、AOF 等持久化方式 高可用性，Redis 支持主从复制、哨兵模式、Cluster 等高可用方式 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:2:1","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"缺点 数据库容量受物理内存的限制，不能用作海量数据的读写 Redis 难以支持在线扩容，修改配置文件之后重启 Redis，恢复磁盘上的数据耗费时间较久 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:2:2","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"使用场景 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:0","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"数据缓存 Redis 是高性能的内存数据库，因此，缓存是 Redis 最常用的场景。Redis 作为缓存使用的时候，一般是采用先更新数据库，再删除缓存的 Cache Aside Pattern 策略。 整体的逻辑是：业务从 Redis 中读取数据，如果 Redis 中访问不到数据，然后读取数据库中的数据，将数据库中的数据缓存到 Redis 中；业务更新数据，直接修改数据库中的数据，然后将 Redis 中的缓存删除。 这种方案需要注意的就是：避免缓存击穿，数据的实时性相对较低。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:1","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"限时业务 Redis 支持给 key 设置过期时间，客户端无法访问到过期的 key，利用这一特性可以运用在限时的优惠活动、手机验证码等业务场景。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:2","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"计数器 Redis 的 INCRBY 命令可以实现原子性的递增，可以直接作为计数器存储和递增。尤其是，该命令在键不存在时会直接初始化值再执行 INCRBY 命令，执行成功后会直接返回计算增量之后的数值。 高并发的秒杀活动、分布式序列号的生成、限制手机发送短信次数、接口限制访问次数等需要计数的功能，都涉及到计数器的概念，尤其是分布式系统会涉及到分布式计数器。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:3","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"分布式锁 先使用 SETNX 命令来争抢锁，结果返回 1 表示设置成功，抢到之后再用 EXPIRE 命令给锁加一个过期时间防止忘记释放锁。 从 Redis 的 2.6.12 版本开始，可以通过 SET 命令的复杂参数，将 SETNX 命令和 EXPIRE 命令合并成一条命令来使用： EX second: 设置键的过期时间为 second 秒，使用 EX 选项效果等同于 SETEX 命令。 PX millisecond: 设置键的过期时间为 millisecond 毫秒，使用 PX 选项效果等同于 PSETEX 命令。 NX: 只在键不存在时，才对键进行设置操作，使用 NX 选项效果等同于 SETNX 命令。 XX: 只在键已经存在时，才对键进行设置操作。 同样的，使用 SET 命令操作成功之后会返回 OK，这样才表示抢到了锁。 为了避免分布式锁被误删，加锁时可以设置线程 ID 作为 value 值，删除时需要线程的线程 ID 和 Redis 存储的值一致才能够删除分布式锁，否则只能等待锁自动过期，整个删除过程使用事务的方式保证原子性。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:4","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"排行榜功能 通过 Redis 的 SortedSet 可以实现排行榜功能。 比如说需要展示点赞排行榜，可以将用户 ID 作为 SortedSet 的 value 值，将用户的点赞数作为 SortedSet 的 score 值，SortedSet 提供的 ZRANGEBYSCORE 命令可以快速返回已排序的点赞排行榜。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:5","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"延时队列 延时队列其实就是一个带有延迟功能的消息队列，Redis 可以通过 SortedSet 实现延时队列。 具体的实现如下： 将消息内容序列化成一个字符串作为 SortedSet 的 value 值，这个消息的到期处理时间作为 score，生产者调用 ZADD 命令生产消息，消费者可以使用 ZRANGEBYSCORE 命令获取一段时间之前的数据轮询处理； 通常使用多个线程轮询 SortedSet 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其他线程可以继续处理； 因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行，Redis 的 ZREM 命令是多线程争抢任务的关键，ZREM 命令会返回被成功移除的成员数量，可以通过 ZREM 命令来决定任务的唯一属主； 同时也要注意一定要进行异常捕获，避免因为个别任务处理问题导致循环异常退出，同一个任务可能会被多个进程取到之后再使用 ZREM 命令进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费； 通常可以使用 Lua 脚本的方式，将 ZRANGEBYSCORE 命令和 ZREM 命令一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:6","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"异步队列 第一种方案 是使用 List 结构作为异步队列，RPUSH 命令生产消息，LPOP 命令消费消息。当使用 LPOP 命令没有得到消息的时候，需要适当 sleep 一会再重试，在这里 sleep 会导致消息的处理延迟增加。 如果不做 sleep 重试，改进的 第二种方案 是，使用 LPOP 命令的阻塞版本 BLPOP 命令，在 List 队列中没有消息的时候，它会阻塞直到消息到来，一旦数据到来，则立刻醒过来，消息的延迟几乎为零。但是如果线程一直阻塞，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候 BLPOP 命令会抛出异常来，代码中需要处理这样的异常。 除了 List 队列之外，第三种方案 是使用 Pub/Sub 订阅者模式实现一对多的消息队列。但是 Redis 的发布订阅功能是无状态的，对于发布者来说，无法知道发布的消息是否被订阅者接收到，在消费者下线的情况下，生产的消息会丢失。 ","date":"2023-01-31","objectID":"/posts/database/redis-introduction-usage-scenario.html:3:7","tags":["NoSQL","缓存","Redis"],"title":"Redis - 介绍与使用场景","uri":"/posts/database/redis-introduction-usage-scenario.html"},{"categories":["数据库技术"],"content":"分片是指跨机器拆分数据的过程，通过在每台机器上放置数据的子集，无须功能强大的机器，只使用大量功能稍弱的机器，就可以存储更多的数据并处理更多的负载。 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"简介 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"什么是分片 高数据量和高吞吐量的数据库应用会对单机的性能造成较大压力，大的查询会将单机的 CPU 耗尽，大的数据量对单机的存储压力较大，最终会耗尽系统的内存压力转移到磁盘 IO 上。 为了解决这些问题，有两个基本的方法： 垂直扩展：增加更多的 CPU 和存储资源来扩展容量 水平扩展：将数据集分布在多个服务器上 MongoDB 的分片就是水平扩展的体现，使用分片减少了每个分片需要处理的请求数。通过水平扩展，集群可以提高自己的存储容量和吞吐量。 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:1:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"何时分片 通常来说，不宜过早对数据进行分片，这会增加部署的复杂性；也不应该过晚进行分片，因为很难在不停止运行的情况下对超载的系统进行分片。 通常情况下，分片用于以下情况： 增加可用 RAM 增加可用磁盘空间 减少服务器的负载 处理单个 mongod 无法承受的吞吐量 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:1:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"集群结构 一个 MongoDB 的分片集群包含以下组件： Shard: 即分片，数据的真正存储位置，以 chunk 为单位存数据；分片也可以部署为一个副本集 Router: 查询的路由，提供客户端和分片之间的接口；MongoDB 提供了 mongos 进程实现 Config Servers: 存储元数据和配置数据 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"数据存储 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"分片的块 在一个分片服务内部，MongoDB 会把数据分为块，每个 chunk 代表这个分片内部的一部分数据。其作用有两个： splitting: 当一个 chunk 的大小超过配置的 chunk size 时，MongoDB 的后台进程会将这个 chunk 继续切分 balancing: 在 MongoDB 中，会有一个 balancer 线程负责 chunk 的迁移，从而均衡各个分片的负载 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"块的大小 在 MongoDB 中，chunk 的分裂和迁移是非常耗费 IO 资源的，并且 chunk 的分裂只会发生在插入和更新时。 对于大块和小块的选择，其实各有优缺点： 小块：迁移速度快，数据分布更均匀；数据分裂频繁，路由节点消耗更多资源 大块：数据分裂少，数据块移动集中消耗 IO 资源 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"分裂和迁移 随着数据的增长，其中的数据大小超过了配置的 chunk size（默认 64M），则这个 chunk 就会分裂成两个。 数据增长的速度快慢会影响 chunk 分裂的速度，数据增长越快则 chunk 分裂的速度越快。 需要注意的是，如果分片试图分裂的时候，其中一个配置服务器停止运行了，那么将无法更新元数据，则会出现分片一直尝试拆分块并一直失败，这种一直无法成功的过程最终会导致 拆分风暴。 一旦发生了分裂，比如说 Shard A 分裂成 3 个块，Shard B 分裂成 3 个块，而 Shard C 仍然只有 1 个块，则各个分片上的 chunk 数量会不平衡，。 这时候，mongos 中的 balancer 线程就会执行自动平衡，把 chunk 从 chunk 数量最多的分片挪动到 chunk 数量最少的节点。 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:3:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"如何分片 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:4:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"分片键 在对集合进行分片的时，需要选择一个或多个组合字段来对数据进行拆分，这个键（这些键）被称为分片键。 选择分片键非常重要，分片键的有以下注意事项： 分片键是不可变的 分片键必须是索引 分片键不能是数组 分片键大小限制 512bytes 分片键用于路由查询 分片键的组合最好具有很高的基数 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:4:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"哈希分片 分片过程中可以使用哈希索引作为分片键，其最大的好处是能保证数据在各个节点分布基本均匀。 对于基于哈希的分片，MongoDB 计算一个字段的哈希值，并用这个哈希值来创建数据块。 在使用基于哈希分片的系统中，拥有相近分片键的文档很可能不会存储在同一个数据块中，数据的分离性更好一些。 基于哈希分片可以很好地在集群中分配负载，但是，如果随机访问超出了 RAM 大小的数据时，效率会比较低。 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:4:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"范围分片 对于基于范围的分片，MongoDB 按照分片键的范围把数据分成不同部分。 在使用分片键做范围划分的系统中，拥有相近分片键的文档很可能存储在同一个数据块中，因此也会存储在同一个分片中。 如果这个分片键是一个自增的值时，将会使 MongoDB 难以保持块的均衡，因为 MongoDB 需要不断将最后一个分片的数据块移动到其他分片上。 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:4:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"哈希和范围的结合 哈希分片更适合随机访问，不适合范围查询；范围分片则是适合范围查询，不适合平衡负载。 一个自定义的方案是，对自增字段构建哈希索引（尽可能是仍然保持有序的哈希算法）即可解决。 ","date":"2023-01-07","objectID":"/posts/database/mongodb-sharding-introduction.html:4:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 分片简介","uri":"/posts/database/mongodb-sharding-introduction.html"},{"categories":["数据库技术"],"content":"MongoDB 的副本集类似于有自动故障修复功能的主从集群，提供了数据的冗余和高可用，是所有生产部署的基础。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"简介 在 MongoDB 中，副本集指的是一组 MongoDB 服务器实例掌管同一个数据集，实例可以在不同的机器上。 其中一个用于处理写操作的是主节点（Primary），还有多个用于保存主节点的数据副本的从节点（Secondary）。如果主节点崩溃了，则从节点会从其中选取出一个新的主节点。 副本集保证数据在生产部署时的冗余和可靠性，通过在不同的机器上保存副本来保证数据不会因为单点损坏而丢失，能够随时应对数据丢失、机器损坏带来的风险。 从另一个角度上看，还能提高读取能力，用户的读取服务器和写入服务器在不同的地方，由不同的服务器为不同的用户提供服务，提高了整个系统的负载能力。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"节点成员 副本集中的节点主要分为三种：主节点 Primary、从节点 Seconary、仲裁节点 Arbiter。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"主节点 主节点包含了所有的写操作的日志。 但是副本服务器集群包含有所有的主服务数据，因此当主服务器挂掉了，就会在副本服务器上重新选取一个成为主服务器。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"从节点 正常情况下，副本集的从节点会参与主节点选举，并从主节点同步最新写入的数据，以保证与主节点存储相同的数据。 通常，从节点提供读服务，增加从节点可以提供副本集的读服务能力，同时提升副本集的可用性。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"仲裁节点 仲裁节点只参与投票，不能被选举为主节点，并且不从主节点同步数据。 当副本集成员为偶数时，最好加入一个仲裁节点，以提升副本集的可用性。 当然，如果可以的话，最好使用没有仲裁者的部署。添加额外的仲裁者并不能加快选举速度，也不能提供更好的数据安全性，仅仅能使得副本集成员数为奇数防止选举出现平票。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"被动成员 给从节点设置 priority 可以指定其成为主节点的优先级，它的取值范围是 0 到 100，默认是 1。 优先级为 0 的从节点不参与选举，这样的从节点被称为被动成员。 拥有最高优先级的成员总是会被选举为主节点（只要它能连接到副本集中的大多数成员，并且拥有最新的数据）。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"隐藏成员 给从节点设置 hidden 为 true 可以将其作为隐藏成员，隐藏成员只对 isMaster 不可见。 客户端不会向隐藏成员发送请求，隐藏成员也不会优先作为副本集的数据源（尽管当其他复制源不可用时隐藏成员也会被使用）。 通常会将性能较弱的服务器或者备份服务器隐藏起来，因此，隐藏成员适合做数据备份、离线计算的任务。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"成员状态 成员之间通过心跳来传达自己的状态。最常见的状态就是“主节点”和“从节点”状态，其他的一些状态如下： STARTUP: 成员在第一次启动时的状态，正在尝试加载副本集配置 STARTUP2: 配置被加载后进入这个状态，初始化同步过程会持续处于这个状态 RECOVERING: 成员运行正常，但不能处理读请求 ARBITER: 仲裁节点独有的特殊状态 DOWN: 一个成员被正常启动，但后来变为不可访问 UNKNOWN: 如果一个成员未能访问到另一个成员，那么就不知道它处于什么状态 REMOVED: 此成员已被从副本集中移除 ROLLBACK: 成员正在回滚数据中会处于此状态 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:2:6","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"部署架构 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"一主两从 当主节点宕机时，两个节点都会参与选举，其中一个会变成主节点。 当原主节点恢复后，将会作为从节点加入当前的副本集群。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"一主一从一仲裁 当主节点宕机时，将会选择从节点称为主节点。 当原主节点恢复后，将会作为从节点加入当前的副本集群。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"推荐配置 第一种方案是：将“大多数”成员放在一个数据中心。只要主数据中心正常运转，就会有一个主节点。如果主数据中心不可用了，那么备份数据中心将无法选举出主节点。 第二种方案是：在两个数据中心各自放置数量相等的成员，在第三个地方放置一个用于打破僵局的副本集成员。 复杂的需求可能需要不同的配置，但都需要考虑副本集在不利条件下如何满足“大多数”的要求。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:3:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"数据同步 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:4:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"操作日志 MongoDB 的操作日志是一个特殊的有上限的集合（老的日志会被覆盖），保存了所有数据库中存储数据的修改操作的滚动记录。 当主节点执行数据库写操作时，会将这些操作记录到主节点 local 数据库中的一个固定集合中，然后从节点通过异步进程复制和应用（数据同步）这些操作。 每个从节点都维护自己的操作日志，用于记录从主节点复制的每个操作，这使得每个成员都可以被用作其他成员的同步源。 操作日志中的每个操作都是幂等的，同一个操作执行多次和只执行一次效果是一样的。 在大多数情况下，默认的操作日志大小就足够了。通常以下情况需要更大的操作日志空间： 一次更新多个文档。操作日志为了保持幂等性会将多文档更新转换成多个单独操作 删除数据量与插入数据量相同。这种情况的磁盘占用变化不大，但是操作日志的大小可能很大 大量的原地（in-place）更新。这种情况的磁盘占用变化不大，但是操作日志的大小可能很大 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:4:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"初始同步 这里的初始同步可以理解成全量同步，会使用完整的数据集填充新成员。会有以下场景触发： 新节点加入副本集时，没有任何操作日志，此时会触发初始同步 上次全量同步中途失败后重新加入副本集，此时会触发初始同步 当用户发送 resync 命令时，内存标记 initialSyncRequested 被设置为 true，此时会触发初始同步 全量同步的流程如下： 全量同步开始，设置 minvalid 集合的 _initialSyncFlag 为 true 获取同步源上最新操作日志时间戳为 t1 全量同步集合数据（耗时） 获取同步源上最新操作日志时间戳为 t2 重放 [t1, t2] 范围内的所有操作日志 获取同步源上最新操作日志时间戳为 t3 重放 [t2, t3] 范围内所有的操作日志 建立集合所有索引（耗时） 获取同步源上最新操作日志时间戳为 t4 重放 [t3, t4] 范围内所有的操作日志 全量同步结束，清除 minvalid 集合的 _initialSyncFlag ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:4:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"复制数据 这里的复制可以理解为增量同步，在初始同步结束之后，从节点就会持续同步新的操作日志并重放。 复制的流程比较复杂，会涉及到几个线程，其流程如下： 生产者线程会不断从同步源上拉取操作日志，并加入到一个阻塞队列里保存 批处理线程会逐步将阻塞队列里的操作日志取出，并放到自己维护的队列里 同步线程将批处理线程的队列分发到默认 16 个重放线程，由重放线程最终重放每条操作日志 拉取操作日志是单线程进行的，如果把重放的操作也放在这个线程，同步势必会很慢，所以设计上生产者线程只做拉取操作日志的工作。 在重放操作日志时，要保持顺序性，而且遇到 createCollection()、dropCollection() 等 DDL 命令时，这些命令与其他的增删查改是不能并行执行的，这些控制都有批处理线程处理。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:4:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"注意事项 初始同步是单线程复制数据，效率比较低，在生产上应尽量避免做全量同步 合理配置操作日志的大小，按默认 5% 的可用磁盘空间配置可满足绝大多数场景 新加入节点时，可以通过物理复制的方式来避免初始同步，将主节点的数据拷贝到新的节点，这样效率更高 当从节点需要的操作日志在同步源上已经滚掉，从节点的同步将无法进行，需要从节点主动发送 rsync 命令同步 生产环境使用 db.printSlaveReplicationInfo() 命令监控主备同步滞后的情况 当从节点因为主节点并发写入太高导致同步滞后，可通过调整从节点的重放线程数来提升 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:4:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"数据高可用 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:5:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"选举机制 在副本集中，通过选举机制来选择主节点，选举主节点的规则如下： 假设副本集内能够投票的成员是 N 个，当副本集内存活数量不足 $\\frac{N}{2} + 1$ 个时，整个副本集将无法选举出主节点，副本集将无法提供写服务，处于只读状态。 举例：3 个投票节点需要 2 个节点的赞成票，容忍选举失败次数为 1；5 个投票节点需要 3 个节点的赞成票，容忍选举失败次数为 2；通常投票节点为奇数，这样可以减少选举失败的概率。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:5:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"触发时机 当出现以下情况时，会触发选举机制： 初始化副本集时 往副本集中新加入节点 对副本集进行维护时，比如执行 rs.stepDown() 或者 rs.reconfig() 操作时 从节点失联时，比如超时（默认是 10 秒） ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:5:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"影响因素 以下因素会影响到选举结果： 副本集的选举协议 心跳 成员权重 数据中心失联 网络分区 镜像读取 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:5:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"故障转移回滚 回滚指的是，当成员在故障转移后重新加入其副本集时，将还原之前主节点上的写操作，并恢复成现在主节点的状态数据。 仅当节点接收到主节点降级前未成功复制的写操作后，重新加入副本集群之后发现与现有主节点的数据不一致时，才需要回滚。 当节点重新加入到副本集群时，它会还原或“回滚”其不一致的写操作，以保持与其他成员的一致性。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:5:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"与副本集交互 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:6:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"客户端连接 对于副本集，默认情况下，驱动程序会连接到主节点，并将所有流量都路由到此节点。 对于应用程序，可以像与单机服务器通信一样执行读写操作，同时副本集会在后台悄悄地处理热备份。 你不需要列出服务器地址列表中的所有成员（尽管这样做也可以）。当驱动程序连接到服务器时，它可以从其中发现其他成员。一个连接字符串通常看起来像下面这样： mongodb://server-1:27017,server-2:27017,server-3:27017 如果想提供更强的容错能力，那么也可以使用 DNS 种子列表连接格式来指定应用程序连接到副本集的方式。 使用 DNS 的优点是可以轮流更改 MongoDB 副本集成员所在的服务器，而无须重新配置客户端。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:6:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"重试策略 用户希望驱动程序对其隐藏整个选举过程（主节点退位，新的主节点被选举出来）。然而，由于一些原因，没有驱动程序能够以这种方式处理故障转移。 驱动程序经常因为操作失败而发现主节点已停止运行，这意味着驱动程序不知道主节点在停止运行之前是否处理了该操作。 这是一个不可避免的分布式系统问题。事实证明，正确的策略是最多重试一次。 要解释清楚这一点，需要先看一下都有哪些策略可供选择。归结起来就是：不重试、在重试一定次数后放弃或者最多只重试一次。 我们还需要考虑错误的类型，这可能是问题的根源。在尝试对副本集进行写操作的过程中，可能 会遇到 3 种类型的错误： 短暂的网络错误 持续的中断（网络或服务器） 由服务器拒绝的错误命令（比如未授权）引起的错误 对于短暂的网络错误而言，如果遵循重试一定次数的策略，则可能会发生计数过多现象（在第一次尝试成功的情况下）。对于持续中断或命令错误，多次重试只会浪费资源。 再来看一下仅重试一次的策略。对于短暂的网络错误，可能会发生计数过多现象。对于持续的中断或命令错误，这是正确的策略。 然而，如果可以确保操作是幂等的会如何？无论做一次还是多次，幂等操作都会有相同的结果。利用幂等操作，在发生网络错误时重试一次最有可能正确处理所有 3 种类型的错误。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:6:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"读写优先级 默认情况下，副本集的所有读请求都发送到主节点，Driver 可通过设置 Read Preference 来将请求路由到其他节点。规则如下： primary: 默认规则，所有读请求发送到主节点 primaryPreferred: 主节点优先，如果主节点不可达，请求从节点 secondary: 所有读请求发送到从节点 secondaryPreferred: 从节点优先，当所有从节点不可达时请求主节点 nearest: 读请求发送到最近的可达节点上（通过 ping 探测得出最近的节点） ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:6:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"读请求选择 其实，将读请求发送到从节点通常并不是一个好主意，在一些情况下，通常更建议将读请求发送到主节点而不是从节点。 对于数据一致性要求非常高的应用程序，更推荐从主节点读取数据。这是由于从节点的数据通常会落后于主节点，并且这个时间有可能因其他原因导致更长。 如果将读请求发送到从节点以分配负载，有可能会因为一个节点崩溃而导致整个副本集出现过载的情况，这个会导致恶性循环。一个更好的选择是使用分片来分配负载。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:6:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"注意事项 在生产环境中，应该始终使用副本集并为每个成员分配一个专用主机，以避免资源争用，并针对服务器故障提供隔离。 为了提供更多的弹性，还应该使用 DNS 种子列表连接格式指定应用程序如何连接到副本集。其优点在于可以轮流更改托管 MongoDB 副本集成员的服务器，而无须重新配置客户端。 副本集中的每个成员都必须能够连接到其他成员（包括自身）。但是 MongoDB 3.6 中 mongod 仅在默认情况下绑定到 localhost（127.0.0.1） 地址上，这个通常需要根据服务本身的地址做配置修改。 并且，在绑定到非 localhost 的地址之前，应该启用授权控制并指定身份验证机制。 另外，最好对磁盘上的数据和副本集成员之间以及副本集与客户端之间的通信进行加密。 需要注意的是，不能在不停止运行的情况下将单机服务器转换为副本集，以重新启动并初始化该副本集。 因此，即便一开始只有一台服务器，你也希望将其设置为一个单成员的副本集。这样，就可以在不停止运行的情况下进行添加。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:7:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"常见问题 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:8:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"MongoDB 副本集和 MySQL 主从的区别？ 从节点读写模式 MySQL 中将主从同步的从库设置为只读状态，限制了普通用户只能进行读的操作，但限制不了超级权限用户对数据进行修改操作，这种情况容易造成主键冲突。 MongoDB 中只有主节点才可进行写操作，从节点是决不允许写数据的，对数据的一致性有着更高的保证。 主节点唯一性 MongoDB 中主节点是唯一的，其余均为从节点，但主节点不是固定不变的，集群内部有容灾机制。 MySQL 提供了双主架构方案，MasterA 和 MasterB，MasterA 可以做为 MasterB 的主库，而 MasterB 也可以做为 MasterA 的主库，两者互为主从。 复制过程中是同步还是异步 MySQL 在 5.5 版本之后提供了半同步复制模式，是介于异步复制和同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个 TCP/IP 往返的时间。所以，半同步复制最好在低延时的网络中使用。 MongoDB 的同步模式是完全异步的。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:8:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"MongoDB 副本集的最大节点数为多少？ 在副本集中，每个节点会向其他节点发送心跳请求，间隔时间为 2 秒，默认 10 秒为超时。从这个角度上看，副本集也相当于无中心架构。 当副本集中节点增加时，心跳请求的数量将会以指数级的数量增加，单单是心跳请求对资源的占用也会很大。 因此，在 MongoDB 中副本集的限制为最大 50 个，同时只有 7 个成员拥有投票权。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:8:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"MongoDB 主节点宕机之后如何进行选举？ 副本集中的健康节点大于集群节点的 $\\frac{1}{2}$ 时，集群才可正常选举，否则集群将不可写，只能读。 这个限制会存在一个情况：副本集原本有 3 个节点，但是其中 2 个从节点因为异常挂掉了，那么集群检测之后主节点也将会降级为从节点，只接受读，不再接受写入。 官方推荐在副本集中有投票权的节点数量为奇数个，主要是为了避免出现脑裂（一个集群被分成了多个集群）的情况。 ","date":"2022-12-29","objectID":"/posts/database/mongodb-replica-set-introduction.html:8:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 副本集简介","uri":"/posts/database/mongodb-replica-set-introduction.html"},{"categories":["数据库技术"],"content":"虽然说 MongoDB 是无模式的，但实际上模式设计在 MongoDB 中也非常重要。在实际开发中，大多数性能问题都可以追溯到糟糕的模式设计。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"注意事项 模式设计，即在文档中表示数据的方式，对于数据表示来说时非常关键的。 为 MongoDB 做模式设计时，在性能、可伸缩性和简单性方面是重中之重，也需要考虑一些特别的注意事项。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"限制条件 与常见的 SQL 相比而言，MongoDB 有自己的限制条件： 文档最大限制为 16M 大小 从磁盘读写完整文档 更新会重写整个文档 在文档级别进行原子更新 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:1:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"访问模式 设计模式时最需要关注的就是数据库的读操作，在数据库运行过程中，应尽量减少查询的数量，这就需要在设计时确保一起查询的数据存储在同一个文档中。 其实，就是考虑是否是否可以将动态（读/写）数据和静态（主要是读）数据分离开，如未经常使用的数据应该移到不同的集合中。 在进行模式设计时，提高最常见查询的优先级会获得最佳的性能。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:1:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"关系类型 数据之间的关系影响着文档之间应该是内嵌还是引用。 比如说，需要弄清楚如何在不执行其他查询的情况下引用文档，以及当关系发生变化时需要更新多少文档。 关系基数对于文档之间的关系非常重要，如一对一、一对多、多对多、一对百万、多对百万等等关系基础，影响的程度差距非常大，应选取最佳格式去做建模。 在关系基数的基础上，还需关注访问的情况、重要数据更新与读取的比例，这些充分考虑之后，将有助于确定应采用内嵌文档还是引用文档。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:1:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"范式化和反范式化 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"基本概念 通常来说，多文档之间的关系可以使用反范式化（内嵌）或范式化（引用）。 范式化是指在文档中引用外部数据的标识，同一份数据只存在一个地方。 在查询时，查询完整的数据需要做 JOIN 的操作，需要查询多次才可能获取到所需内容；但是在更改时仅需修改一处地方，不需要担心破坏数据的完整性。 反范式化是指将外部数据复制一份存储在文档中，也就是说同一份数据存在多处地方。 在查询时，只需查询一次即可得到所需内容，查询效率比较可观；而在更改时，需要更新多处地方，可能会出现数据不一致的情况，不能保证完整性。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"范式化选择 决定何时采用范式化以及何时采用反范式化是比较困难的：通常，范式化的写入速度更快，而反范式化的读取速度更快。 通过判断以下因素可决策选择使用范式化还是反范式化： 更适合范式化 更适合反范式化 较大子文档 较小子文档 数据经常变更 数据不经常变更 数据要强一致 数据最终一致即可 文档数据大幅增加 文档数据小幅增加 数据通常不包含在结果中 数据通常需要执行二次查询才能获得 快速写入 快速读取 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"模型设计小技巧 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"指导原则 通常来说，具有类似模式的文档应该保存在同一个集合中。 对于集合来说，需要考虑的一个大问题是锁机制（每个文档都有一个读/写锁）和存储。 当使用 --directoryperdb 选项时，每个数据库都可以保留在自己的目录中，这允许你将不同的数据库挂载到不同的卷中。 同一个应用程序连接的数据库可以根据业务进行划分，也许可以将高价值的业务数据存储在 SSD 上，或者是使用 RAID10 进行存储，而低价值的数据可以存储在 RAID0 上。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"删除旧数据 有些数据只在短时间内比较重要，过了这段时间，保存这些数据只是再浪费存储空间。 删除旧数据有 3 种常见的方式：使用固定集合、使用 TTL 索引、使用多个集合。 最简单的方式是使用固定集合：将集合大小设置成一个较大的值，并让旧数据从固定集合的末尾被“删除”。 第二种方式是使用 TTL 集合：TTL 集合可以更精确地控制删除文档的时间，但其在写入量过大的集合中操作速度不够快。 最后一种方式是使用多个集合：例如每个月的文档都单独使用一个集合。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"一致性管理 MongoDB 支持多种一致性级别，从总是能够读取自己所写的数据到读取不确定的旧数据。 其内部实现是服务器端为每一个数据库连接都维护了请求队列，同一个连接发来的请求都会被添加到队列的末尾，连接中的任何后续请求都将依次得到处理。 这个管理方式涉及到多个客户端连接会出现并发问题，在一个连接中插入文档后，在另一个连接的后续查询却不一定会返回这个文档（实际上已经插入成功）。 同样的一致性问题在 MongoDB 拥有副本集时也会出现，副本节点的数据与主节点的数据总是会有时间差，高并发的请求同样存在读取到旧数据的风险。 MongoDB 提供了 readConcern 选项来控制被读取数据的一致性和隔离性。它通常与 writerConcern 组合使用，以控制为应用程序提供的一致性和可用性保证： 如果 readConcern=local，从当前实例查询并返回结果，不能保证数据已经写入大多数副本集成员。默认在主库读，如果本次读取使用了 causally consistent 则在从库读。 如果 readConcern=available，从当前实例查询并返回结果，不能保证数据已经写入大多数副本集成员。默认在从库读，并且此选项与 causally consistent 不能同时使用。 如果 readConcern=majority，查询结果返回被副本集的大多数成员确认的数据，读操作返回的文档是持久化的。前提是 MongoDB 必须是 WiredTiger 存储引擎。 如果 readConcern=linearizable，查询可能会等待并发执行的写操作传播到大多数副本集成员，然后再返回结果。 如果 readConcern=snapshot，这是适用于多文档事务中的操作，通常情况下使用较少。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"模式迁移 随着应用程序的增长和需求的变化，数据库模式也可能需要随之增长和改变。理想情况下，如果可以的话，应该考虑使用文档版本控制模式。 最简单的方式是根据应用程序的需要改进数据库模式，以确保应用程序支持所有的旧版模式。但是这种方式可能会导致混乱，特别是当不同版本的模式存在冲突时。 为了以一种更结构化的方式处理不断变化的需求，可以在每个文档中包含一个 version 字段，并使用它来确定应用程序将接受的文档结构。 最后一种方式是在模式变更时迁移所有数据。但这通常不是一个好主意：会给系统带来压力，还必须确保所有文档都被更新成功。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"模式管理 MongoDB 3.2 引入了模式验证，其可以在更新和插入操作期间对数据进行验证。 MongoDB 3.6 又通过 $jsonSchema 运算符添加了 JSON 模式验证，现在这是 MongoDB 中所有模式验证的推荐方法。 只有当文档被更改时，验证功能才会检查这些文档，并且此功能是每个集合都需要单独配置的。 要向现有集合添加验证功能，可以在 collMod 命令中使用 validator 选项。在使用 db.createCollection() 时，可以通过指定 validator 选项将验证添加到新集合中。 MongoDB 还提供了两个额外的选项： validationLevel: 决定了在更新过程中验证规则对现有文档检查的严格程度 validationAction: 决定了是应该在发生错误时拒绝请求，还是允许请求并发出警告 当然，更详细的相关内容可以查看 官方文档。 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"编写代码来处理数据完整性问题 为保证 MongoDB 数据的完整性，有可能需要在应用程序中增加必要的逻辑代码进行处理，也需要增加定时任务来保持数据的一致性。 有可能需要有以下的任务： 一致性修复程序：检查计算和重复数据以确保每个人都具有一致的值 预填充器：创建将来需要的文档 聚合：保持内联聚合为最新 架构检查器：确保当前使用的文档集都具有一组字段，可以自动更正它们 定时备份：定期锁定和转储数据库 ","date":"2022-12-26","objectID":"/posts/database/mongodb-model-design.html:3:6","tags":["NoSQL","MongoDB"],"title":"MongoDB - 模式设计","uri":"/posts/database/mongodb-model-design.html"},{"categories":["数据库技术"],"content":"在实际开发中，大多数性能问题都可以追溯到糟糕的模型设计。官方也提供分享过文档模型设计的进阶技巧，这里简单翻译记录一下。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"简介 官方文章的地址是 Building with Patterns: A Summary，其中汇总了 12 种设计模式及使用场景。 上述的图表列举了 12 种设计模式及应用场景，主要是以下这些： 近似值模式（Approximation Pattern） 属性模式（Attribute Pattern） 桶模式（Bucket Pattern） 计算模式（Computed Pattern） 文档版本控制模式（Document Versioning Pattern） 扩展引用模式（Extended Peference Pattern） 异常值模式（Outlier Pattern） 预分配模式（Preallocated Pattern） 多态模式（Polymorphic Pattern） 模式版本控制模式（Schema Versioning Pattern） 子集模式（Subset Pattern） 树型模式（Tree and Graph Pattern） ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"近似值模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 淘宝在往年“双十一”都会有一个销售额大屏展示，当销售额小于 1 亿时，可能展示的是实际的数量，当销售额超过 1 亿时，单位立即变成以“亿”为单位，对于展示的大屏而言，”亿“以下的单位这个时候并不是很重要了。 对于上述的场景，如果每次几十、几百都直接去更新数据库中的实际值，则更新数据库会变得非常频繁，对于数据库的压力是非常大的。 实际上，并不需要每次都去更新数据库，我们只需要将这个实际的精确值存储在内存中，使用 1 亿作为一个阈值，一旦超过这个阈值就精确值更新进数据库中。 对于精度不是首要考虑因素时，那么就可以使用近似值模式，尤其是消耗资源（时间、内存、CPU 周期）非常昂贵时效果会更佳。 近似值模式就是通过减少数据的写入频率，从而降低了架构的复杂度和资源开销，进而提升了整体的性能与效率。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 近似值模式的优点如下： 由于是近似的数据，不必时时刻刻写入，数据库的写操作量级更小 近似值模式的缺点如下： 存储的是近似的数据，无法应对需要展示精确数据的场景 此模式需要在应用层实现 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"属性模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 属性模式运用到了 MongoDB 多键索引的概念，支持对数组中的嵌套子文档中的某个属性进行索引。 假设现在有一个关于电影的集合，其中文档中会包含标题、导演、制片人、演员、上映时间等等信息，对于跨地区上映的电影，有可能不同地区的上映时间是不一样的。 如下展示是一条电影的文档数据： { \"title\": \"Star Wars\", \"director\": \"George Lucas\", // 不同地区有不同的上映时间 \"release_US\": ISODate(\"1977-05-20T01:00:00+01:00\"), \"release_France\": ISODate(\"1977-10-19T01:00:00+01:00\"), \"release_Italy\": ISODate(\"1977-10-20T01:00:00+01:00\"), \"release_UK\": ISODate(\"1977-12-27T01:00:00+01:00\"), } 为了支持对所有上映时间做一个快速搜索，也许我们需要将所有的上映时间设置为单一索引，这个时候，索引的数量就会变得显而易见的多。 使用属性模式，我们通过将这些上映时间信息移动到一个数组中，然后再对这个数组建立一个多键索引索引，以实现使用一个索引替代多个类似索引的功能。 如下是修改结构后的文档数据： { \"title\": \"Star Wars\", \"director\": \"George Lucas\", // 所有的地区的上映时间都放在同一个属性内部 \"releaseList\": [ { \"region\": \"US\", \"date\": ISODate(\"1977-05-20T01:00:00+01:00\") }, { \"region\": \"France\", \"date\": ISODate(\"1977-10-19T01:00:00+01:00\") }, { \"region\": \"Italy\", \"date\": ISODate(\"1977-10-20T01:00:00+01:00\") }, { \"region\": \"UK\", \"date\": ISODate(\"1977-12-27T01:00:00+01:00\") } ] } ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 属性模式的优点如下： 需要更少的索引 查询变得更容易编写，而且通常更快 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"桶模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:4:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 桶模式有点类似于水平分库，常见的水平分库是将一个集合按照某一个规则分布到不同的数据库上，桶模式是将一个集合中的文档按照某一个规则合并起来。 假设现在有一个需要记录用户日志的需求，对于用户的每一个动作，都需要将其更新到 MongoDB 当中，并且是记录其动作、时间。 对于这样的日志数据来说，如果将每一个动作都存储成一个文档，则将会占用极大的存储空间和内存。 使用桶模式的解决办法就是，将一段时间的日志数据存储成一个文档，再将每一个动作日志的数据存储到子文档数据中。 当需要管理流式数据的时候，如时间序列、实时分析或物联网应用程序，桶模式就是一个很好的解决方案。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:4:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 桶模式的优点如下： 减少了集合中的文档总数 提高了索引性能 可以通过预聚合简化数据的访问 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:4:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"计算模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:5:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 对于大型数据集，每一次计算都可能会占用极大的 CPU、磁盘、内存等相关资源，甚至是影响到服务器上的其他计算。 而对于需要重复计算、读取比写入多的场景，计算模式提供了一种优化的思路，以便降低服务器资源的占用。 拿一个电影观看总人数的例子来说明：假设现在页面上需要展示观看电影的实际总人数，而且这个页面会有成千上万的人访问。 虽然，我们可以对电影的每一次放映都记录起观看人数，但是要获取总人数，则需要拿出所有的放映场次的观看人数之后计算其总和，这个计算就非常耗费资源和时间。 对于只有放映场次变化之后，总人数才会更新的情况，实际数据库读取的次数远远大于写入的次数。 在这个场景中，计算模式的思路是：每一次更新放映场次数据的时候，将这个放映场次的人数汇总到一个文档当中，这个文档直接面向用户的查询。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:5:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 计算模式的优点如下： 对于频繁的计算可以减少 CPU 的负载 查询变得更容易编写，而且通常更快 计算模式的缺点如下： 识别出需要使用此模式的的场景可能比较困难 除非必要，请勿过度使用此模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:5:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"文档版本控制模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:6:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 文档版本控制模式在高度规范化的行业中非常有用，这些行业会要求数据的特定时间点版本。 假设现在有一个博客系统，其中有一个记录每次编辑博客文章历史的功能，这样的功能就能应用文档版本控制模式。 假设我们将所有的文章历史都存储在同一个集合当中，则需要考虑大部分与文章相关的功能都要过滤掉历史版本、版本越多则集合文档数量越多等等问题。 文档版本控制模式的想法是：文档中需要记录一个文档的版本，将最新的文档保存在一个 current 集合中，而那些旧版本的文档保存在 history 集合中。 为了最大化利用文档版本控制模式的优势，通常会假设数据访问模式尽量符合以下要求： 每个文档不会有太多的修订版本 需要做版本控制的文档不会太多 大多数的查询都是基于文档的最新版本 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:6:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 文档版本控制模式的优点如下： 容易实现，对现有系统的影响小 在最新版本上进行请求时，没有性能上的影响 文档版本控制模式的缺点如下： 写操作的数量会翻倍 请求需要被定位到正确的集合 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:6:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"扩展引用模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:7:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 MongoDB 是一个不需要提前建模的 NoSQL，当不同文档、不同集合之间存在关系的时候，通常会有嵌入和引用两种方式。 嵌入就是将文档数据嵌入到引用此数据的文档中，访问时直接访问这一次文档即可；引用就是只在文档中引用另一个文档的标识，访问时需要访问两次数据库才能拿到完整的数据。 扩展引用模式是指仅复制经常访问并且不经常更改的字段，而不是复制所有的数据，减少信息的连接以提高性能。 这张图的场景是：客户和订单是 1 对 N 的关系，通常查询订单列表的时候需要展示客户的一些信息，我们就需要考虑是否将客户的信息冗余进订单信息中。 扩展引用模式认为，客户的名称和地址是不常做更新的，可以直接将这些信息冗余进订单表中，以达到减少两个集合连接查询的要求。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:7:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 扩展引用模式的优点如下： 当有大量的 JOIN 操作时可以提升性能 读操作会更快，并且可以减少 JOIN 操作的数量 扩展引用模式的缺点如下： 修改冗余的这部分数据会比较复杂 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:7:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"异常值模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:8:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 顾名思义，异常值模式主要用以解决超出应用程序正常模式的少数异常查询情况。 假设你正在搭建一个出售图书的电子商务网站，现在需要记录一本书都有哪些用户购买过，一个常见的做法的是将购买的用户标识存储在图书文档中，如下展示： { \"_id\": ObjectId('6392cecd4dd9624424ad025d'), \"title\": \"三国演义\", \"author\": \"罗贯中\", \"purchase_customers\": [ \"user0\", \"user1\", \"user3\", // ... ] } 对于上述的文档结构，大部分情况下是适用的。但是，对于销量特别高的图书，极可能导致图书文档的大小超过 16MB 的限制。 使用异常值模式的方式是：在图书文档中添加一个字段来将其标记为异常值，超过一定大小的内容可以存储在另一个文档当中，在应用程序中对异常文档做扩展查询处理，减少异常文档对正常文档的影响。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:8:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 异常值模式的优点如下： 防止整个应用被某些异常的文档或请求所影响 请求会针对那些典型的用例进行优化，而异常值仍将得到处理 异常值模式的缺点如下： 通常会为特定的查询而进行定制，因此一些临时产生的查询可能性能不太理想 此模式的大部分工作是在应用程序代码中完成的 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:8:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"预分配模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:9:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 在使用 MMAPv1 存储引擎时，MongoDB 的一个常见优化是提前分配所需的内存，以满足不断增长的文档未来会达到的大小。 MMAPv1 中不断增长的文档需要由服务端以相当昂贵的成本进行位置的迁移，而 WiredTiger 的无锁机制（lock-free）和重写（rewrite）更新算法不需要这种处理。 一个相对应的例子就是，直接存储一个二维数据可以做到预分配内存，而存储二维数组转换后的稀疏数组则无法做到预分配内存。 因此，在 MMAPv1 中，更推荐使用预分配模式直接存储原始的二维数组。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:9:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 预分配模式的优点如下： 当预先知道文档结构时，可以简化设计 预分配模式的缺点如下： 简单和性能之间的权衡 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:9:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"多态模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:10:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 在面向对象中，多态指的是为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。 而 MongoDB 不强制要求集合的文档拥有特定的结构，这里的多态模式指的是，集合中的文档具有更多的相似性而不是差异性，文档结构都类似但又不完全相同。 其一种实现方案是将文档分组在一起做查询，而不是将其分散到多个集合中；另一种实现方案是使用嵌入式子文档的模式汇总。 多态模式的一个典型用例是单一视图应用程序：假设现在一家较大的公司收购了其他公司，这些公司的业务都是类似的，数据库都以类似的方式存储了数据。 这个时候就可以利用 MongoDB 和多态模式在短时间内构建好单一视图应用程序。 除了单一视图应用程序外，多态模式的其他典型用例还有以下几种： 内容管理 移动应用程序 产品目录 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:10:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 多态模式的优点如下： 实现简单 查询可以在单个集合中运行 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:10:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"模式版本控制模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:11:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 几乎每个数据库在其生命周期中的某个时刻都会产生变更，一旦数据库中的数据模型发生变化，通常需要停止应用程序，迁移数据库以支持新模式，然后重新启动。 这种停机更新会导致糟糕的用户体验，而模式版本控制模式允许历史版本和当前版本的文档在集合中同时存在，以此保障用户体验。 通过使用 schema_version 字段定义模式的版本，并将其保存到数据库中，每个新的模式版本都会增加 schema_version 字段的值。 在应用程序内部，为每个模式版本创建相应的处理函数，这样即可适应不同版本的数据。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:11:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 模式版本控制模式的优点如下： 不需要停机时间 模式迁移可控 减少未来的技术债务 模式版本控制模式的缺点如下： 在迁移过程中，对相同的字段可能需要两个索引 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:11:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"子集模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:12:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 MongoDB 将频繁访问的数据保存在 RAM 中，当数据和索引的工作集超过分配的物理 RAM 时，随着磁盘访问的发生以及数据从 RAM 中转出，性能会开始下降。 为解决这个问题，一个方案是向服务器添加更多的 RAM，不过扩展会有上限，而且非常昂贵；或者考虑对集合进行分片，但这会带来额外的成本和复杂性。 子集模式就解决了有大量数据的大文档没有被应用程序使用而导致的工作集超过 RAM 容量的问题，比如说一个电商产品的评论可能有成千上万条，但大部分情况下都只会访问最近 10 个评论。 其实现方法就是，将一个存储大文档的集合拆分成多个子集，每一个子集都能为单独的功能提供资源，减少了工作集的总体大小。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:12:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 子集模式的优点如下： 在总体上减小了工作集的大小 缩短了最常用数据的磁盘访问时间 子集模式的缺点如下： 必须管理子集 请求附加的数据需要额外的数据库访问 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:12:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"树形模式 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:13:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"示例描述 对于 SQL 来说，可以通过外链子结点或父结点的方式表示树形结构。 对于 MongoDB 而言，比较方便的就是通过存储子结点数组的方式实现，但是其缺点就是每次更新时都需要操作整个结构，不合适做频繁更新，比如说家谱。 因此，当数据是分层结构并且经常被查询时，树形模式是比较优的一个选择。并且可以通过给数组中的属性创建多键索引提高查询效率。 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:13:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"优缺点 树形模式的优点如下： 通过避免多次 JOIN 操作提高了性能 树形模式的缺点如下： 需要在应用程序中管理树结构的更新 ","date":"2022-12-13","objectID":"/posts/database/mongodb-model-design-pattern.html:13:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 数据模型的设计模式","uri":"/posts/database/mongodb-model-design-pattern.html"},{"categories":["数据库技术"],"content":"在 4.2 版本及更高版本中，MongoDB 提供了事务的支持，并且在其是分布式数据库的基础上，提供了支持跨多个操作、集合、数据库、文档和分片的 ACID 事务。 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"事务简介 事务是数据库中处理的逻辑单元，每个事务中包括一个或多个数据库操作，既可以是读操作，也可以是写操作。 ACID 是一个“真正”事务所需要具备的一组属性集合，指的是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。 原子性指的是，事务中的所有操作要么都被应用，要么都不被应用。 一致性指的是，如果数据库在执行事务之前是一致性状态，那么在事务执行之后，无论事务是否成功，数据库也应该是一致性状态。 隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。 持久性指的是，在事务成功提交了之后，事务所变更的数据一定会保存起来，而不会因为任何故障导致数据丢失。 当数据库满足所有这些属性，并且只有成功的事务才会被处理时，它就被称为是符合 ACID 的数据库。 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"如何使用事务 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"事务语法 MongoDB 提供了两种 API 来使用事务： 核心 API，与关系数据库类似的语法（如 start_transaction 和 commit_transaction） 回调 API，这是使用事务的推荐方法 核心 API 不为大多数错误提供重试逻辑，它要求开发人员为操作、事务提交函数以及所需的任何重试和错误逻辑手动编写代码。 与核心 API 不同，回调 API 提供了一个单独的函数，该函数封装了大量功能，包括启动与指定逻辑会话关联的事务、执行作为回调函数提供的函数以及提交事务（或在出现错误时中止）。此函数还包含了处理提交错误的重试逻辑。 在 MongoDB 4.2 中添加回调 API 是为了简化使用事务的应用程序开发，也便于添加处理事务错误的应用程序重试逻辑。 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"API 区别 核心 API 回调 API 需要显式调用才能启动和提交事务 启动事务、执行指定的操作，然后提交（或在发生错误时终止） 不包含 TransientTransactionError 和 UnknownTransactionCommitResult 的错误处理逻辑，而是提供了为这些错误进行自定义处理的灵活性 自动为 TransientTransactionError 和 UnknownTransactionCommitResult 提供错误处理逻辑 要求为特定事务将显式的逻辑会话传递给 API 要求为特定事务将显式的逻辑会话传递给 API ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"实际使用 在一个 Python 的例子当中，使用核心 API 的伪代码如下展示： from pymongo import MongoClient from pymongo.errors import ConnectionFailure, OperationFailure # 显式开启一个事务会话 with client.start_session() as session: while True: try: with session.start_transaction(): # 执行事务中的多个写操作 pass # 提交事务 session.commit_transaction() except (ConnectionFailure, OperationFailure) as e: # 错误处理 if e.has_error_label(\"UnknownTransactionCommitResult\"): # 出现暂时性错误，则重试整个事务 continue else: raise 使用核心 API 需要注意错误的捕捉和处理，而回调 API 就不需要注意这些，其伪代码如下展示： from pymongo import MongoClient def session_callback(session): # 执行事务中的多个写操作 pass # 显式开启一个事务会话 with client.start_session() as session: session.with_transaction(session_callback) ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"事务调优 在使用事务时，有几个重要的参数需要注意。可以对它们进行调整，以确保应用程序能够最佳地使用事务。 在 MongoDB 事务中有两类主要的限制： 第一类与事务的时间限制有关，控制特定事务可以运行多长时间、事务等待获取锁的时间以及所有事务将运行的最大长度 第二类与 MongoDB 的 oplog 条目和单个条目的大小限制有关 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"时间限制 事务的默认最大运行时间是 1 分钟。 可以通过在 mongod 实例级别上修改 transactionLifetimeLimitSeconds 的限制来增加。对于分片集群，必须在所有分片副本集成员上设置该参数。超过此时间后，事务将被视为已过期，并由定期运行的清理进程中止。清理进程每 60 秒或每 transactionLifetimeLimitSeconds/2 运行一次，以较小的值为准。 要显式设置事务的时间限制，建议在提交事务时指定 maxTimeMS 参数。实际上会使用 maxTimeMS 和 transactionLifetimeLimitSeconds 中的更小值。 事务等待获取其操作所需锁的默认最大时间是 5 毫秒。可以通过修改由 maxTransactionLockRequestTimeoutMillis 参数控制的限制来增加。如果事务在此期间无法获得锁，则该事务会被中止。 当 maxTransactionLockRequestTimeoutMillis 设置为 0 时，意味着如果事务无法立即获得所需的所有锁，则该事务会被中止。设置为 -1 将使用由 maxTimeMS 参数所指定的特定于操作的超时时间。 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"oplog 大小限制 MongoDB 会创建出与事务中写操作数量相同的 oplog 条目。 但是，每个 oplog 条目必须在 16MB 的 BSON 文档大小限制之内。 ","date":"2022-11-25","objectID":"/posts/database/mongodb-transaction-support.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 事务支持","uri":"/posts/database/mongodb-transaction-support.html"},{"categories":["数据库技术"],"content":"在实际使用时，必不可少地需要将多个文档甚至是多个集合汇总到一起计算、分析，MongoDB 提供了原生聚合框架支持这样的计算、分析。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"聚合管道 聚合框架是 MongoDB 中的一组分析工具，可以对一个或多个集合中的文档进行分析。 MongoDB 的聚合框架基于管道的概念：首先从集合中获取到输入，然后将输入的文档传递到一个或多个阶段，每个阶段都将之前阶段输出的内容作为输入，最终得到一个聚合结果作为输出。 上面的图是一个比较宽泛的管道流程图。这里展示一个 MongoDB 聚合语句映射到管道之后的情况： 在这里可以看得出，aggregate([{}, {}]) 是一个聚合语句，在函数的数组中，每一个对象都是一个阶段，$match 应该就是一个筛选文档的阶段，$group 应该就是一个分组汇总的阶段。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"管道阶段 使用聚合框架最重要的就是熟悉操作的语法，以及将这些语法构建成管道当中的阶段。 在 MongoDB 聚合框架中，每一个阶段都必须要规定一个特定的阶段运算符，这些阶段运算符表明了阶段的执行规则，可以到 官方文档 上查看更多、更详细的内容。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"常见操作 最常见的操作应该是能与普通查询语句对应上的操作，如查询、投影、排序、跳过、限制等等。虽然这些在一个 find() 语句中就能实现。 最常使用的操作就是查询，也可以说是筛选、过滤，在聚合框架中使用 $match 来表明这是一个筛选文档的阶段。如下是其使用语法： { $match: { \u003cquery\u003e } } 第二个则是投影，这个阶段可以修改输入文档的结构，通常是重命名、增加、删除属性，也可以通过表达式创建计算结果以及嵌套文档。如下是其使用语法： // \u003cfield\u003e: \u003c1 or true\u003e // \u003cfield\u003e: \u003c0 or false\u003e // \u003cfield\u003e: \u003cexpression\u003e { $project: { \u003cspecification(s)\u003e } } 排序、跳过、限制都比较容易理解，实际上可以与 find() 结果的游标支持的函数做联系。如下是其使用语法： // 排序 { $sort: { \u003cfield1\u003e: \u003csort order\u003e, \u003cfield2\u003e: \u003csort order\u003e ... } } // 跳过 { $skip: \u003cpositive 64-bit integer\u003e } // 限制 { $limit: \u003cpositive 64-bit integer\u003e } 上述 5 个阶段是最常用的阶段，在使用时需要注重它们的效率，一般会使用这样的顺序去构建管道： 通过筛选语句过滤指定集合，得到符合要求的文档列表； 如果排序非常重要，这一个阶段需要在过滤文档之后； 如果需要做分页功能，应该是先执行跳过的阶段，然后再到限制的阶段； 最后，执行投影阶段（进入投影阶段的文档应该尽量少）。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"更多操作 - 投影 投影阶段一个比较大的作用就是，限制下一步的文档字段数量，也就是删除属性，如下是使用方式： // 不返回 _id 字段 { $project: { _id: 0 } } // 不返回指定的 field 字段 { $project: { \u003cfield\u003e: 0 } } 删除属性是黑名单的功能，投影阶段也支持白名单的功能，即返回列表内的字段，如下是使用方式： // 返回指定的 field 字段 { $project: { \u003cfield\u003e: 1 } } 前两个功能是比较好理解的，但投影阶段所能做的远不止如此，还有很多其他的功能（投影阶段支持大部分条件组），这里做个简单举例： // 将 author 嵌套文档下 last 属性赋值给 lastName 属性 { $project: { lastName: \"$author.last\" } } // 上述的功能里，对于嵌套文档和内嵌数组返回的结果是不一样的，数组会继承下来 // 投影支持类似于三元运算的表达式 { $project: { lastName: { $cond: { if: { $eq: [ \"\", \"$author.last\" ] }, then: \"$$REMOVE\", else: \"$author.last\", } } } } ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"更多操作 - 展开 在处理数组时，一个比较常见的操作是为数组中的每一个元素形成一个输出文档。 一个实际的例子就是，一件衣服在库存中有 S、M、L 三个尺寸，而这三个尺寸会存储在同一个数组字段当中，当我们聚合时想要将这一条文档展开成三个文档，一个尺寸对应一个文档。 // 原始文档 { \"clothesId\": \"123456\", \"sizeList\": [\"S\", \"M\", \"L\"] } // 展开后的文档 { \"clothesId\": \"123456\", \"sizeList\": \"S\" } { \"clothesId\": \"123456\", \"sizeList\": \"M\" } { \"clothesId\": \"123456\", \"sizeList\": \"L\" } 聚合过程中，展开阶段的语法是： { $unwind: \u003cfield path\u003e } // 上述衣服的例子中，可以用以下语句来展开 { $unwind: \"$sizeList\" } ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"更多操作 - 分组 分组是聚合管道中举足轻重的一个阶段，这里的分组可以看作是 SQL 的 GOURP BY 语句，其能为聚合功能带来非常大的可能性。 分组阶段使用了 $group 运算符，支持使用一个键或多个键将输入的文档进行分组，其语法如下： { $group: { // 分组的标识 _id: \u003cexpression\u003e, \u003cfield1\u003e: { \u003caccumulator1\u003e : \u003cexpression1\u003e }, ... } } 其中 _id 是必须的，可以简单指定分组的键，也可以使用条件组做处理后生成自定义键。 可选的 \u003cfield\u003e 是分组后需要展示的键，并且可以指定条件组来决定它们的值是什么。 尤其是，MongoDB 提供了累加器可以实现复杂的功能，如求和、平均值、最大值、最小值等等。 这里有个对集合求和的例子，也是最简单的使用： { $group: { // 对类型进行分组 _id: \"$type\", // 这里是求和，一个文档记作 1 个，即对同类型的文档进行计数 count: { $sum: 1 }, } } ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:2:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"更多操作 - 入库 顾名思义，入库需要作为管道中最后的阶段，将管道生成的文档写入集合中。 聚合框架提供了 $out 和 $merge 两个运算符标识入库阶段，其中 $merge 是在 4.2 版本中引入的。这两个操作符的语法如下： // 指定数据库和集合，会直接覆盖 { $out: { db: \"\u003coutput-db\u003e\", coll: \"\u003coutput-collection\u003e\" } } // 配置更加丰富 { $merge: { // 指定数据库和集合 into: \u003ccollection\u003e -or- { db: \u003cdb\u003e, coll: \u003ccollection\u003e }, // 确定唯一标识与集合中做匹配 on: \u003cidentifier field\u003e -or- [ \u003cidentifier field1\u003e, ...], // Optional // 设定变量 let: \u003cvariables\u003e, // Optional // 如果标识存在时处理文档的方式 whenMatched: \u003creplace|keepExisting|merge|fail|pipeline\u003e, // Optional // 如果标识不存在时处理文档的方式 whenNotMatched: \u003cinsert|discard|fail\u003e // Optional } } 如果可以的话，建议使用 $merge 作为写入集合的首选方式，其功能更多。 当然，其真正的优势是，可以按照按需生成的物化视图（materialized view），在管道运行的阶段，输出到集合的内容会进行增量更新。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:2:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"条件组累加器 在一些阶段操作中，MongoDB 支持使用累加器来增强聚合功能，这里说的累加器泛指求和、平均值、最大值、最小值等功能的操作符。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"算术运算 这里的算术运算不是统称的四则运算，指的是与数学相关的运算，如平均值、求和等。 $avg 累加器用于计算平均值，通过是直接指定一个键名即可，使用 { $avg: \"$keyName\" } 这样的语法。 $sum 累加器用于计算指定键的和，也是直接指定一个键名即可，使用 { $sum: \"$keyName\" } 这样的语法。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"最值运算 累加器支持的最值包括这些：最小值、最大值、最大的 n 个值。 最小值和最大值的理解都比较容易，使用也比较容易。最小值使用了 { $min: \"$keyName\" } 这样的语法，最大值使用了 { $max: \"$keyName\" } 这样的语法。 最大的 n 个值是在 5.2 版本新增的累加器，其作用是通过指定输入的键，得到这些键值中排序后最大的 n 个值，其语法如下： { $maxN: { // 指定键名 input: \"$score\" input: \u003cexpression\u003e, // 指定数量 n: 3 n: \u003cexpression\u003e } } ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"数组提取 这里的数组提取指的是提取数组中的某个元素，现在能支持到的就是提取出数组中的前 n 个元素、后 n 个元素。 在这里可以使用 $first、$firstN、$last、$lastN 这样的运算符，它们的语法分别如下： { $first: \u003cexpression\u003e } { $firstN: { input: \u003cexpression\u003e, n: \u003cexpression\u003e } } { $last: \u003cexpression\u003e } { $lastN: { input: \u003cexpression\u003e, n: \u003cexpression\u003e } } ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:3:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"其他运算 除了上述的累加器，聚合框架还有非常多其他的累加器，这里简单列一下： $accumulator: 返回自定义累加器函数的结果 $addToSet: 返回一个无重复值的数组 $bottom: 返回指定排序规则后最后 1 个元素 $bottomN: 返回指定排序规则后最后 n 个元素 $count: 返回文档的计数 $mergeObjects: 返回合并多个对象之后的结果 $push: 返回一个可以有重复值的数组 $stdDevPop: 返回输入值的总体标准差 $stdDevSamp: 返回输入值的样本标准差 这些累加器都有各自的用法，使用得当可实现非常强大的数据分析功能，完整的内容可以到 官方文档 上查看。 ","date":"2022-11-24","objectID":"/posts/database/mongodb-aggregate-query.html:3:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 聚合查询","uri":"/posts/database/mongodb-aggregate-query.html"},{"categories":["数据库技术"],"content":"学会 MongoDB 的增删改查只能算得上是“初窥门径”，了解、熟练掌握索引才能算得上“融会贯通”。基本可以认为数据库的索引知识是一个初级开发向中级开发转变所必备的知识。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"索引简介 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"什么是索引 索引最常用的比喻就是书籍的目录，查询索引就像查询一本书的目录。 索引支持 MongoDB 查询的高效执行。如果没有索引，MongoDB 必须扫描集合中每一个文档，以选择与查询语句相匹配的文档。如果查询存在适当的索引，MongoDB 就可以使用索引来限制它扫描的文档数。 筛选字段时使用索引提速有以下几个因素： 索引数据通过 B 树来存储，从而使得搜索的时间复杂度为 $O(\\log n)$ 索引本身存储在高速缓存中，相比磁盘 IO 有大幅的性能提升（有的时候数据量非常大的时候，索引数据也会非常大，当大到超出内存容量的时候，会导致部分索引数据存储在磁盘上，这会导致磁盘 IO 的开销大幅增加，从而影响性能，所以务必要保证有足够的内存能容下所有的索引数据） 索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。 因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:1:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"何时不使用索引 查询结果集在原集合中占比越大，索引就会越低效。 出现这种情况的原因是：使用索引需要进行两次查找：一次是查找索引项，一次是根据索引的指针去查找其指向的文档。而全表扫描只需进行一次查找：查找文档。在最坏的情况下（返回集合内的所有文档），使用索引进行查找的次数会是全表扫描的两倍，通常会明显比全表扫描慢。 根据经验，如果查询返回集合中 30% 或更少的文档，则索引通常可以加快速度。然而，这个数字会在 2%～60% 变动。 通常，索引使用的情况有这些：比较大的集合、比较大的文档、选择性查询。 而全表扫描相对使用的情况有这些：比较小的集合、比较小的文档、非选择性查询。 总结一下就是，在以下情况不推荐使用索引： 有大量写操作而读操作较少的场景，更新损耗比查询的损耗更大，不推荐建索引 查询结果集在原集合中占比越大，索引就会越低效 索引基数（字段去重后的数量）越低，索引的作用就越小 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:1:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"MongoDB 如何选择索引 MongoDB 如何选择索引具有自己的机制，通常是根据要搜索的字段和一些附加信息（比如是否有排序）有关。基于这些信息，系统会识别出可能用于满足查询的候选索引。 当候选索引被选出之后，则会进行候选索引竞赛的阶段。 在竞赛阶段，MongoDB 会分别为这些候选索引创建 1 个查询计划，并在并行线程中运行这些查询计划，每个线程使用不同的索引。 到达目标状态的第一个查询计划成为赢家。更重要的是，具有相同 形状 的其他查询都会选择这个索引。 服务端会维护这些查询计划的缓存，以备将来用于进行相同 形状 的查询。 通常，以下这些事件导致缓存被清除掉：随着时间变化、重建特定的索引、添加或删除索引、显式清除计划缓存、mongod 进程的重启等。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:1:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"索引的类型 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"单一索引 MongoDB 提供了默认的 _id 索引，在此之外，还支持对文档的单个字段创建用户定义的升序、降序索引。但是对于单字段索引，索引键的排序顺序并不重要，因为 MongoDB 可以在任意方向上遍历索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"复合索引 MongoDB 还支持在多个字段上定义索引，即复合索引。 在考虑复合索引的设计时，需要知道对于利用索引的通用查询模式，如何处理其等值过滤、多值过滤以及排序这些部分。大部分情况可以参考以下准则： 等值过滤字段应该在最前面 排序字段应在多值过滤字段之前 多值过滤字段应该在最后面 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"多键索引 多键索引和复合索引的概念不能搞混，如果一个文档有被索引的数组字段，则该索引会立即被标记为多键索引。 对数组创建索引就是对数组中的每个元素创建索引，而不是对数组本身创建索引。 对数组创建索引有一个例外，即 MongoDB 最多支持对一个数组字段创建索引，索引项中不允许出现多个数组字段，这是为了避免多键索引中的索引项数量呈爆炸式地增长。 多键索引通常会比非多键索引慢一些，可能会有许多索引项指向同一个文档。而一旦索引被标记为多键多键，就再也无法变成非多键索引，唯一办法是将多键索引删除重建成非多键索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"地理空间索引 为了支持对地理空间坐标数据的高效查询，MongoDB 提供了两个特殊索引：返回结果时使用平面几何的 2d 索引和使用球面几何的 2dsphere 索引。 创建索引时，通过将索引键的值设置成 2d 或者是 2dsphere 即可创建地理空间索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"文本索引 MongoDB 提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存在特定于语言的停用词（如 the、a、or 等），并且集合中的词干仅存储词根。 文本索引需要一定数量的与被索引字段中单词成比例的键，创建文本索引可能会耗费大量的系统资源。同时写操作通常比对单一索引、符合索引，甚至多键索引的写操作开销更大，应在需求明确时创建文本索引。 创建索引时，通过将索引键的值设置成 text 即可创建文本索引，并且可以同时对多个键创建文本索引。在创建文本索引时，也可以用 $** 表示文档的所有字符串字段。 默认情况下，文本索引中的每个字段都会被平等对待。也可以通过 wights 属性设置本文索引中每个键的权重。但需要注意的是，文本索引一旦被创建，就不能改变索引的权重了（除非删除索引再重建）。 文本索引能解决搜索关键字的问题，但对于在中国使用汉字的应用程序来说，请谨慎使用。从 官方文档 中可以了解到支持到语言，其中并没有包含汉字。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"哈希索引 为了支持基于哈希的分片，MongoDB 提供了哈希索引类型，索引字段值的哈希值。这些索引在其范围内具有更随机的值分布，但仅支持等值匹配而不支持范围查询。 对于嵌入文档，哈希索引的哈希函数会折叠其值并计算哈希值，而对于数组，哈希索引是不支持的，对其创建哈希索引时会返回错误。 MongoDB 不支持在哈希索引上指定唯一约束，可以通过对存储原始值的键构建唯一索引以指定唯一约束。 在创建索引时，通过将键的值设置为 hashed 即可将其设置成哈希索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:2:6","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"索引的属性 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"唯一索引 索引的唯一属性会导致 MongoDB 拒绝索引字段的重复值。除了唯一约束之外，唯一索引在功能上可与其他 MongoDB 索引相同。 对于单一索引，唯一属性针对的是单个键值；对于复合索引，唯一属性针对的是所有键值的组合。 在某些情况下，索引桶（index bucket）的大小是有限制的，如果索引项超过了索引桶的大小就不会被包含在索引中。 在 MongoDB 4.2 之前，索引中包含的字段必须小于 1024 字节，也就是说大小超过 1024 字节的键不会受到唯一索引的约束；在 MongoDB 4.2 及以后版本，这个限制被去掉了。 创建索引时设置 {unique: true} 可以设置唯一索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"部分索引 部分索引在 3.2 版本新增，其表示仅索引符合特定过滤表达式的文档。 MongoDB 的部分索引只会在数据的一个子集上创建，通过索引集合中的文档子集，部分索引具有较低的存储要求，可以减少索引创建和维护的性能成本。 创建索引时设置 partialFilterExpression 选项，可以只对符合表达式要求的值做索引。 当查询条件匹配部分索引时，不在索引内的值不在搜索结果当中，如果需要返回那些缺少字段的文档，可以使用 hint 强制执行全表扫描。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"稀疏索引 稀疏索引也称为间隙索引，就是包含具有索引字段的文档的条目，跳过没有索引字段的文档。 通过上述的定义可以看出，稀疏索引是部分索引的子集，创建部分索引时设定索引键必须存在的过滤表达式即可达到稀疏索引的作用。 将稀疏索引和唯一索引组合，以拒绝具有字段重复值的文档，但忽略没有索引键的文档。 创建索引时设置 {sparse: true} 可以设置稀疏索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:3:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"TTL 索引 TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。 TTL 索引有自己适合的场景，如机器生成的事件数据，日志和会话信息等，这些信息通常只需在数据库中保存有限的时间。 MongoDB 会每分钟扫描一次 TTL 索引，因此不应依赖于秒级的粒度。 创建索引时设置 {expireAfterSeconds: \u003cseconds\u003e} 可以设置 TTL 索引，通常索引键时日期类型时，TTL 索引才会起作用。 MongoDB 还提供了一种类似于固定长度队列的集合，称作为“固定集合”。其长度是固定的，当集合已满足设定大小时，旧的文档会被删除，新的文档将取而代之。 通常来说，相对于固定集合，MongoDB 优先推荐使用 TTL 索引，因为其在 WiredTiger 存储引擎（在 3.2 版本开始作为默认存储引擎）中性能更好，可操作性也更强。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:3:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"不区分大小写的索引 在 3.4 版本，MongoDB 提供了不区分大小写索引属性，支持在不考虑大小写的情况下执行字符串比较的查询。 创建索引时通过设置 {collation: {locale : \u003clocale\u003e, strength : \u003cstrength\u003e}} 可以创建不区分大小写的索引。 其中，locale 指定语言规则，可以通过 官方文档 查看更多，使用 strength 可以指定比较级别，可以通过 官方文档 了解更详细内容。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:3:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"索引的使用 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"管理索引 索引的所有信息都存储在 system.indexes 集合中，这是一个保留集合，不支持修改或删除，只能通过相关命令对其进行操作。 MongoDB 提供了一些相关命令管理索引，以下是常用的方法： db.collection.createIndex(keys, options, commitQuorum): 创建单个索引 db.collection.createIndexes([keyPatterns], options, commitQuorum): 创建多个索引 db.collection.dropIndex(index): 删除集合中除 _id 的指定索引 db.collection.dropIndexes(): 不传参时可以删除集合中除 _id 的全部索引，也可以指定索引名实现删除指定索引 db.collection.getIndexes(): 查询集合的索引信息 db.collection.hideIndex(\u003cindex\u003e): 在 4.4 版本新增，隐藏索引对查询计划器不可见，不能用于查询，可以通过隐藏索引发现在不删除索引的情况下评估删除所有的潜在影响 db.collection.unhideIndex(\u003cindex\u003e): 取消隐藏索引 MongoDB 的索引名称可标识索引，大部分的索引管理命令都支持使用名称指定索引。 索引名称的默认形式是 keyname1dir1_keyname2_dir2..._keynameN_dirN，其中 keynameX 是索引的键，dirX 是索引的方向（1 或 -1）。 索引名称是有字符数限制的，并且比较多的键时也会难以辨识，因此创建复杂的索引时可以自定义名称。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"修改索引 当需要修改索引时，通常的做法是先使用 dropIndex(index) 删除指定索引，再使用 createIndex 重建索引。 修改索引的操作一般发生在应用程序已经上线之后，这时就需要考虑到创建索引既耗时又耗资源，考虑使用 background 选项在后台创建索引，尽可能减少对读写操作的影响。 在 MongoDB 4.2 之后，引入了混合索引创建的机制，即在索引创建的开始和结束时持有排他锁，创建过程中其余部分会交错地让步于读写操作。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"索引方向 使用单一索引时，索引键的方向并不重要，MongoDB 会根据排序的方向，选择扫描索引的方向。只有基于多个查询条件进行排序时，索引方向才是重要的。 对于复合索引，有可能对不同的键设置不同的方向，这与实际的业务有关系。 通常是创建与排序方向相同的索引方向，且相互反转（在每个方向上都乘以 -1）的索引是等价的：{age: 1, username: -1} 适用的查询与 {age: -1, username: 1} 完全一样。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"索引基数 索引的基数是指集合中某个字段有多少个不同的值，即值去重后的数量。 通常来说，一个字段的基数越高，这个字段上的索引就越有用。对于基数比较低的字段，索引通常无法排除大量可能的匹配项。 一个例子就是，如果对“性别”字段创建索引，而查找“男性”时仅能将搜索空间缩小大约 50%，其索引作用相对是较低的。 根据经验来说，应该在基数比较高的键上创建索引，或者至少应该把基数比较高的键放在复合索引的前面（在低基数的键之前）。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"左前缀原则 MongoDB 的复合索引遵循左前缀原则：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。 比如说，有一个类似 {a: 1, b: 1, c: 1, ..., z: 1} 这样的索引，那么实际上也等于有了 {a: 1}、{a: 1, b: 1}、{a: 1, b: 1, c: 1} 等一系列索引，但是不会有 {b: 1} 这样的非左前缀的索引。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"交叉索引 在 2.6 版本新增，MongoDB 可以使用交叉索引来完成查询。 对于指定复合条件的查询，如果一个索引可以满足查询条件的一部分，而另一个索引可以满足查询条件的另一部分，则 MongoDB 可以使用两个索引的交集来完成查询。 使用复合索引还是使用交叉索引更有效取决于具体的查询和系统。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:6","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"覆盖查询 当查询子句和查询投影仅包含索引字段时，MongoDB 可以直接从索引返回结果，而无需扫描任何文档或加载文档到内存。 这样的覆盖查询非常有效，效率非常高。必要时还需要对不做查询的字段进行索引，以满足覆盖索引的要求。 如果对一个被覆盖的查询运行 explain，那么结果中会有一个并不处于 FETCH 阶段下的 IXSCAN 阶段，并且在 executionStats 中，totalDocsExamined 的值是 0。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:4:7","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"查询计划 使用 explain 可以为查询提供大量的信息，它是慢查询的重要诊断工具之一。下述是执行结果示例： { \"queryPlanner\": { \"plannerVersion\": 1, \"namespace\": \"test.users\", \"indexFilterSet\": false, \"parsedQuery\": { \"age\": { \"$eq\": 42 } }, \"winningPlan\": { \"stage\": \"FETCH\", \"inputStage\": { \"stage\": \"IXSCAN\", \"keyPattern\": { \"age\": 1, \"username\": 1 }, \"indexName\": \"age_1_username_1\", \"isMultiKey\": false, \"multiKeyPaths\": { \"age\": [], \"username\": [] }, \"isUnique\": false, \"isSparse\": false, \"isPartial\": false, \"indexVersion\": 2, \"direction\": \"forward\", \"indexBounds\": { \"age\": [ \"[42.0, 42.0]\" ], \"username\": [ \"[MinKey, MaxKey]\" ] } } }, \"rejectedPlans\": [] }, \"executionStats\": { \"executionSuccess\": true, \"nReturned\": 8449, \"executionTimeMillis\": 15, \"totalKeysExamined\": 8449, \"totalDocsExamined\": 8449, \"executionStages\": { \"stage\": \"FETCH\", \"nReturned\": 8449, \"executionTimeMillisEstimate\": 10, \"works\": 8450, \"advanced\": 8449, \"needTime\": 0, \"needYield\": 0, \"saveState\": 66, \"restoreState\": 66, \"isEOF\": 1, \"invalidates\": 0, \"docsExamined\": 8449, \"alreadyHasObj\": 0, \"inputStage\": { \"stage\": \"IXSCAN\", \"nReturned\": 8449, \"executionTimeMillisEstimate\": 0, \"works\": 8450, \"advanced\": 8449, \"needTime\": 0, \"needYield\": 0, \"saveState\": 66, \"restoreState\": 66, \"isEOF\": 1, \"invalidates\": 0, \"keyPattern\": { \"age\": 1, \"username\": 1 }, \"indexName\": \"age_1_username_1\", \"isMultiKey\": false, \"multiKeyPaths\": { \"age\": [], \"username\": [] }, \"isUnique\": false, \"isSparse\": false, \"isPartial\": false, \"indexVersion\": 2, \"direction\": \"forward\", \"indexBounds\": { \"age\": [ \"[42.0, 42.0]\" ], \"username\": [ \"[MinKey, MaxKey]\" ] }, \"keysExamined\": 8449, \"seeks\": 1, \"dupsTested\": 0, \"dupsDropped\": 0, \"seenInvalidated\": 0 } } }, \"serverInfo\": { \"host\": \"eoinbrazil-laptop-osx\", \"port\": 27017, \"version\": \"4.0.12\", \"gitVersion\": \"5776e3cbf9e7afe86e6b29e22520ffb6766e95d4\" }, \"ok\": 1 } 在 explain 的结果当中，queryPlanner 描述了所有的查询计划，其中包括一个获胜的查询计划 winningPlan 字段，和一组失败的查询计划 rejectedPlans 字段。 executionStats 字段包含了描述获胜查询计划所执行的统计信息。 isMultiKey: 是否使用了多键索引 nReturned: 返回的文档数量 totalDocsExamined: 按照索引指针在磁盘上查找实际文档的次数 totalKeysExamined: 使用了索引时是查找过的索引条目数量，全表扫描时是检查过的文档数量 stage: 查询阶段，COLLSCAN 表示集合扫描，IXSCAN 表示索引扫描 needYield: 为了让写请求顺利进行，本次查询暂停的次数 executionTimeMillis: 所有查询计划花费的总毫秒数，不是所选的最优查询计划所耗费的时间 indexBounds: 描述了索引是如何被使用的，并给出了索引的遍历范围 优化的一个方向是，通过将 nReturned 和 totalKeysExamined 作比较，两个数值越是接近，表示索引的选择性越高。 ","date":"2022-11-18","objectID":"/posts/database/mongodb-index-knowledge.html:5:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 索引知识","uri":"/posts/database/mongodb-index-knowledge.html"},{"categories":["数据库技术"],"content":"对于开发人员而言，数据库的增删改查操作才是最常使用的功能，学习 MongoDB 时还需对这些功能熟记于心才行啊。我就在这里做一个简单的备忘，多看官方文档才是正道。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"连接 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"标准 URI 连接语法 通常，可以设定标准的 URI 连接语法，作为连接配置： mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] mongodb://: 固定的格式，即指定当前的 URI 是标准的 MongoDB 连接语法 username:password@: 可选项，如果设置，在连接数据库服务器之后，驱动会尝试登录这个数据库 host1: 必须的，至少指定一个 host，它指定了要连接服务器的地址。如果要连接副本及集，需要指定多个主机地址 portX: 可选的指定端口，如果不填，默认为 27017 /database: 如果指定账号和密码，连接并验证登录指定数据库。若不指定，默认打开 test 数据库 ?options: 连接选项，如果没有指定数据库，则前面需要加上 /。所有连接选项都是键值对 name=value，键值对之间通过 \u0026 或 ; 隔开 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:1:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"连接选项 标准的连接格式包含了多个选项，如下所示： replicaSet=name: 验证副本集的名称 slaveOk=true|false: 选择连接主服务器的方式 true: 表示有从服务器，当 connect=direct 时会连接第一台机器，即使这台不是主服务器；当 connect=replicaSet 时会发送所有的写请求到主并且把读请求分布在其他从服务器 false: 表示无从服务器，当 connect=direct 时会自动找寻主服务器；当 connect=replicaSet 时仅连接主服务器，并且所有的读写命令都连接到主服务器 safe=true|false: 设置为 true 时，在执行更新操作之后，驱动都会发送 getLastError 命令来确保更新成功 w=n: 驱动添加 {w: n} 到 getLastError 命令，应用于 safe=true wtimeoutMS=ms: 驱动添加 {wtimeout: ms} 到 getLastError 命令，应用于 safe=true fsync=true|false: 驱动添加 {fsync: true} 到 getLastError 命令，应用于 safe=true journal=true|false: 如果设置为 true，同步到日志（在提交到数据库前写入到实体中），应用于 safe=true connectTimeoutMS=ms: 可以打开连接的时间 socketTimeoutMS=ms: 发送和接受 socket 的时间 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:1:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"连接命令格式 使用 mongosh 连接 MongoDB 时，也支持命令选项的方式添加配置： --host arg: 指定数据库地址 --port arg: 指定数据库端口 -u [ --username ] arg: 鉴权的账号 -p [ --password ] arg: 鉴权的密码 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:1:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"插入文档 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"插入校验 MongoDB 会对要插入的数据进行最基本的检查：检查文档的基本结构，如缺少 _id 键会自动添加一个、是否包含非 UTF-8 字符、是否使用了无法识别的类型、检查文档大小等。 其中，检查文档大小主要因为 MongoDB 限制了所有文档必须小于 16MB，主要是为了防止不良的模式设计并确保性能上的一致。 要查看文档的 BSON 大小，可以在 shell 中执行 Object.bsonsize(doc) 查看字节大小。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个插入 官方文档：db.collection.insertOne() — MongoDB Manual db.collection.insertOne( \u003cdocument\u003e, { writeConcern: \u003cdocument\u003e } ) ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"批量插入 官方文档：db.collection.insertMany() — MongoDB Manual db.collection.insertMany( [ \u003cdocument 1\u003e , \u003cdocument 2\u003e, ... ], { writeConcern: \u003cdocument\u003e, ordered: \u003cboolean\u003e } ) 通过传输 ordered=true 可以确保文档按提供的顺序插入，指定为 false 则允许 MongoDB 重新排列插入的顺序以提高性能，默认为 true 值。 以有序插入的方式使用 insertMany 出现错误将会阻塞后续的插入动作，无需插入的方式则不管其他插入是否出现了错误。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"删除文档 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个删除 官方文档：db.collection.deleteOne() — MongoDB Manual db.collection.deleteOne( \u003cfilter\u003e, { writeConcern: \u003cdocument\u003e, collation: \u003cdocument\u003e, hint: \u003cdocument|string\u003e // Available starting in MongoDB 4.4 } ) 使用 hint 参数可以指定 filter 查询时命中的索引，这对于复杂的索引结构时可以提升部分效率。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:3:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"批量删除 官方文档：db.collection.deleteMany() — MongoDB Manual db.collection.deleteMany( \u003cfilter\u003e, { writeConcern: \u003cdocument\u003e, collation: \u003cdocument\u003e, hint: \u003cdocument|string\u003e // Available starting in MongoDB 4.4 } ) ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:3:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个删除并返回 官方文档：db.collection.findOneAndDelete() — MongoDB Manual db.collection.findOneAndDelete( \u003cfilter\u003e, { writeConcern: \u003cdocument\u003e, projection: \u003cdocument\u003e, sort: \u003cdocument\u003e, maxTimeMS: \u003cnumber\u003e, collation: \u003cdocument\u003e } ) ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:3:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"更新文档 更新文档是原子操作：如果两个更新同时发生，那么首先到达服务器的更新会先被执行，然后再执行下一个更新。 因此，相互冲突的更新可以安全地迅速接连完成，而不会破坏任何文档：最后一次更新将“成功”。如果不想使用默认行为，则可以考虑使用文档版本控制模式。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个更新 官方文档：db.collection.updateOne() — MongoDB Manual db.collection.updateOne( \u003cfilter\u003e, \u003cupdate\u003e, { upsert: \u003cboolean\u003e, writeConcern: \u003cdocument\u003e, collation: \u003cdocument\u003e, arrayFilters: [ \u003cfilterdocument1\u003e, ... ], hint: \u003cdocument|string\u003e // Available starting in MongoDB 4.2.1 } ) 在更新文档的时候，比较需要注意的事 upsert 的使用，其是一种特殊类型的更新：如果找不到与筛选条件相匹配的文档，则会以这个条件和更新文档为基础来创建一个新文档；如果找到了匹配的文档，则进行正常的更新。 因此，使用 upsert 的好处就是，可以使用同一套代码创建和更新文档。 使用 upsert 时就涉及到一个 $setOnInsert 运算符，它的作用是，只会在插入文档时设置字段的值，在后续的更新时不对其进行更改。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"批量更新 官方文档：db.collection.updateMany() — MongoDB Manual db.collection.updateMany( \u003cfilter\u003e, \u003cupdate\u003e, { upsert: \u003cboolean\u003e, writeConcern: \u003cdocument\u003e, collation: \u003cdocument\u003e, arrayFilters: [ \u003cfilterdocument1\u003e, ... ], hint: \u003cdocument|string\u003e // Available starting in MongoDB 4.2.1 } ) ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个替换 官方文档：db.collection.replaceOne() — MongoDB Manual db.collection.replaceOne( \u003cfilter\u003e, \u003creplacement\u003e, { upsert: \u003cboolean\u003e, writeConcern: \u003cdocument\u003e, collation: \u003cdocument\u003e, hint: \u003cdocument|string\u003e // Available starting in 4.2.1 } ) replaceOne 和 updateOne 操作的区别在于，updateOne 可以更新文档中部分键的值，而 replaceOne 的作用是直接将整个文档都替换掉，通常是建议使用 updateOne 而不是 replaceOne。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个更新并返回 官方文档：db.collection.findOneAndUpdate() — MongoDB Manual db.collection.findOneAndUpdate( \u003cfilter\u003e, \u003cupdate document or aggregation pipeline\u003e, // Changed in MongoDB 4.2 { projection: \u003cdocument\u003e, sort: \u003cdocument\u003e, maxTimeMS: \u003cnumber\u003e, upsert: \u003cboolean\u003e, returnDocument: \u003cstring\u003e, returnNewDocument: \u003cboolean\u003e, collation: \u003cdocument\u003e, arrayFilters: [ \u003cfilterdocument1\u003e, ... ] } ) 使用 findOneAndUpdate 而不是 updateOne 的最大目的莫过于使用 findOneAndUpdate 可以返回更新前后文档内容。 通过设置 returnNewDocument 的值为 true 可以返回更新后的文档，为 false 时可以返回更新前的文档。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个替换并返回 官方文档：db.collection.findOneAndReplace() — MongoDB Manual db.collection.findOneAndReplace( \u003cfilter\u003e, \u003creplacement\u003e, { projection: \u003cdocument\u003e, sort: \u003cdocument\u003e, maxTimeMS: \u003cnumber\u003e, upsert: \u003cboolean\u003e, returnDocument: \u003cstring\u003e, returnNewDocument: \u003cboolean\u003e, collation: \u003cdocument\u003e } ) ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"更新运算符 官方文档：Update Operators — MongoDB Manual 对于如 updateOne、updateMany、findOneAndUpdate 等更新操作，MongoDB 提供了原子的更新运算符支持只更新部分数据。 运算符支持以 { \u003coperator\u003e: { \u003cfield\u003e: \u003cvalue\u003e,... } } 的方式使用，并且可以同时使用多个运算符。 为避免出现歧义，不建议对同一个属性同时使用不同的运算符。 字段 $currentDate: 将指定键设置为当前时间 $inc: 对数字类型的键做递增操作 $min: 会比较原始值和更新值，并设置成较小值 $max: 会比较原始值和更新值，并设置成较大值 $mul: 对数字类型的键做乘法操作 $rename: 修改指定键的名称 $set: 将指定键设置为指定值 $setOnInsert: 与 upsert 配合使用，如果更新导致文档插入，则设置字段的值，对修改现有文档的更新操作无效 $unset: 删除指定键 数组 $: 充当占位符，更新与查询条件匹配的第一个元素 $[]: 充当占位符，为匹配查询条件的文档更新数组中的所有元素 $[\u003cidentifier\u003e]: 充当占位符，为匹配查询条件的文档更新与 arrayFilters 条件匹配的所有元素 $addToSet: 仅当集合中不存在该元素时，才将元素添加到数组中 $pop: 传 { $pop: { field: 1 } } 表示删除数组中的最后一项，传 -1 时表示删除第一项 $pull: 删除与指定查询匹配的所有数组元素 $push: 新增一项到数组中 $pullAll: 删除列出的所有数组元素 数组内层 $each: 使用 $push 或 $addToSet 运算符时，增加此运算符可以批量添加元素 $position: 与 $each 配合使用，可以指定添加元素的位置 $slice: 与 $each 配合使用，防止数组的增长超过某个大小，传正数表示从左到右截断 $sort: 与 $each 配合使用，对添加完元素的数组进行排序 位运算 $bit: 支持对整数值进行按位 AND、OR 或 XOR 更新，通过使用 { $bit: { \u003cfield\u003e: { \u003cand|or|xor\u003e: \u003cint\u003e } } } 完成更新。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:4:6","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"批量写操作 官方文档：db.collection.bulkWrite() — MongoDB Manual MongoDB 提供了 bulkwrite 命令支持批量执行命令，批处理时在一定程度上减少了网络交互的损耗。 db.collection.bulkWrite( [ \u003coperation 1\u003e, \u003coperation 2\u003e, ... ], { writeConcern: \u003cdocument\u003e, ordered: \u003cboolean\u003e } ) 支持的以下操作： insertOne updateOne updateMany replaceOne deleteOne deleteMany ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:5:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"查询文档 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:6:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"单个查询 官方文档：db.collection.findOne() — MongoDB Manual db.collection.findOne(query, projection, options) 第一个参数是查询条件，可以使用键值对的方式指定需要匹配的条件，多个键之间是 AND 的关系。 第二个参数用于仅返回指定的键，既可以节省网络传输的数据量，也可以减少客户端解码文档的时间和内存消耗。 第三个参数可以指定查询到可选项，这些选项会修改查询行为和返回结果的方式。更多查看 官方文档。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:6:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"批量查询 官方文档：db.collection.find() — MongoDB Manual db.collection.find(query, projection, options) 数据库会使用游标返回 find 的执行结果。 对于游标，客户端可以限制结果的数量，跳过一些结果，按任意方向的任意键组合对结果进行排序等操作。更多查询 官方文档。 下述是一些常用的游标方法： count(): 统计游标引用的文档数量 hasNext(): 查询是否有下一个结果 hint(index): 指定游标命中的索引 limit(number): 限制返回结果的数量 next(): 返回下一个搜索结果 size(): 返回应用 skip() 和 limit() 之后的查询数量 skip(number): 控制跳过一定的数量，跳过大量数据会比较慢 sort(sort): 使用键值对的方式对搜索结果进行排序 在服务器端，游标会占用内存的资源。通常在以下情况会终止游标及进行随后的清理： 当游标遍历完成匹配的结果时，它会清除自身 当游标超出客户端的作用域时，驱动程序会向数据库发送终止游标的信号 当游标达到 10 分钟没有使用时，数据库游标会被自动销毁 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:6:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"查询运算符 官方文档：Query and Projection Operators — MongoDB Manual 同样的，设置查询条件时，MongoDB 提供了查询运算符支持更多的查询方式。 比较运算符 $eq: 返回等于指定值的结果，等同 { \u003cfield\u003e: \u003cvalue\u003e } 的显式表示 $gt: 返回大于指定值的结果 $gte: 返回大于等于指定值的结果 $in: 返回等于指定数组中任意一个值的结果，对于一个键匹配多个值，$in 比 $or 更方便 $lt: 返回小于指定值的结果 $lte: 返回小于等于指定值的结果 $ne: 返回不等于指定值的结果 $nin: 返回不等于指定数组中任意一个值的结果 逻辑运算符 $and: 返回同时符合查询子句要求的结果 $not: 元运算符，匹配不符合查询语句要求的结果 $nor: 返回不能同时符合查询子句要求的结果 $or: 返回与任意一个查询子句的条件匹配的结果 对于普通的 $and 类型查询，我们总是希望尽可能用最少的参数来限定结果的范围。而 $or 类型查询则相反，如果第一个参数能够匹配尽可能多的文档，则其效率最高。 元素运算符 $exists: 判断指定键是否存在，返回符合要求的结果 $type: 判断指定键的数据类型，返回符合要求的结果（好的模式设计不应该出现不同类型） 表达式运算符 $expr: 允许使用聚合表达式，适合用在一些比较复杂的查询语句 $jsonSchema: 根据给定的 JSON 模式验证文档，返回符合要求的结果 $mod: 指定键的值执行模运算，返回符合要求的结果 $regex: 使用正则表达式对指定键做匹配，MongoDB 可以利用索引来查询前缀正则表达式，但不能用于不区分大小写的搜索 $text: 对使用文本索引的字段内容执行文本搜索，可以作为一个简易的搜索引擎使用 $where: 允许在查询时执行任意 JavaScript 代码（性能较差，尽可能使用 $expr 代替） 数组运算符 $all: 匹配包含查询中指定的所有元素的数组 $elemMatch: 用于强制将查询子句与单个数组元素进行匹配 $size: 匹配指定数组长度大小的结果 投影运算符 投影运算符针对的是查询语句的第二个参数，即返回的结果。 $: 仅返回数组中与查询条件匹配的第一个元素 $elemMatch: 对返回结果中的数组元素做 $elemMatch 匹配，仅返回数组中满足要求的元素 $meta: 与 $text 运算符配合使用，返回与文档关联的元数据，可以返回匹配分数，或者索引键 $slice: 对返回结果中的数组做截取返回 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:6:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"特殊的 null 值 在 MongoDB 中，null 是一个比较特殊的值，它可以与自身匹配。也就是说了，通过 { field: null } 可以查询出 field 键为 null 的文档。 不过，更特殊的是，null 同样会匹配缺少这个键值的文档。也就是说，{ field: null } 可以查询出不包含 field 键的文档。 如果仅想匹配键值为 null 的文档，则需要检查该键的值是否为 null，并且通过 $exists 条件确认该键已存在，如 { field: { $eq: null, $exists: true } } 就是这样的查询条件组。 ","date":"2022-11-16","objectID":"/posts/database/mongodb-crud.html:6:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 增删改查","uri":"/posts/database/mongodb-crud.html"},{"categories":["数据库技术"],"content":"简单了解 MongoDB 的基本概念之后，就需要了解其提供的一些工具和数据逻辑结构，以真正开始入门 MongoDB 的学习。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"组件结构 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"核心进程 在 MongoDB 中，核心进程主要包含了 mongod、mongos 和 mongosh 三个。 其中最主要的是 mongod 程序，其在不同的部署方案中（单机部署、副本集部署、分片集群部署），通过不同的配置，可以扮演多种不同的角色： 在单机部署中作为数据库服务器（提供所有读写功能） 在副本集部署中，通过配置，可以部署为 Primary 节点（负责写数据，也可以提供查询）、Secondary 节点（从主节点复制数据，也可以提供查询）、以及 Arbiter 节点（不保存数据，主要用于参与选举投票） 在分片集群中，除了在每个分片中扮演上述角色外，还扮演着配置服务器的角色（存储有分片集群的所有元数据信息，mongos 的数据路由分发等都要依赖于它） 在一台服务器上，可以启动多个 mongod 服务。但在实际生产部署中，通常是建议一台服务器部署一个 mongod 实例，这样不仅减少资源竞争，而且服务器故障也不会同时影响到多个服务。 mongos 在分片集群中扮演路由的角色，提供客户端和分片之间的接口。 mongosh 是 MongoDB 集成的交互式 shell 工具。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:1:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"数据库工具 MongoDB 数据库工具是用于处理 MongoDB 部署的命令行实用程序的集合。数据库工具包括以下二进制文件： 二进制导入导出 mongodump: 导出 mongod 数据库的二进制数据 mongorestore: 恢复 mongodump 导出文件的数据到 mongod 或 mongos 数据库 bsondump: 转换 BSON 导出文件成 JSON 格式 数据导入导出 mongoimport: 从外部 JSON、CSV 或 TSV 文件中加载数据 mongoexport: 从 mongod 实例中导出数据到 JSON 或 CSV 文件中 诊断工具 mongostat: 快速诊断当前运行的 mongod 或 mongos 实例的状态 mongotop: 统计 mongod 实例读取和写入数据的时间 GridFS 工具 mongofiles: 支持在 GridFS 对象中操作 MongoDB 实例中存储的文件 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:1:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"数据逻辑结构 MongoDB 数据逻辑结构分为数据库 database、集合 collection、文档 document 三层 : 一个 mongod 实例中允许创建多个数据库 一个数据库中允许创建多个集合，集合相当于关系型数据库的表 一个集合则是由若干个文档构成，文档相当于关系型数据库的行，是 MongoDB 中数据的基本单元 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"数据库 一个数据库中可以创建多个集合，原则上应把逻辑相近的集合都放在一个数据库中。 在 MongoDB 中，会有以下几个内建的数据库： admin: 存放有数据库帐号相关信息，在身份验证和授权时使用 local: 特定于单个服务器的数据会存储在此数据库中。在副本集中，local 数据库用于存储复制过程中所使用的数据，而其本身不会被复制。 config: 用于分片集群环境，存放了分片相关的元数据信息 test: 默认创建的测试库，连接 mongod 服务时，如果不指定连接的具体数据库，默认就会连接到 test 数据库 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"集合 和 SQL 的表不同，集合是动态模式，不需要在读写数据前创建模式就可以使用，集合中的文档也可以拥有不同的字段，随时可以任意增减某个文档的字段。 默认情况下，集合不要求其文档具有相同的模式，但这是一种很好的实践。可以通过使用 MongoDB 的文档验证功能和可用于多种编程语言的对象–文档映射（object-document mapping）库来实现文档验证。 集合由其名称进行标识，集合名称可以是任意 UTF-8 字符串，但有以下限制： 不能是空字符串（\"\"）。 不能含有 \\0（空字符），这个字符用于表示集合名称的结束 不能以 system. 开头，该前缀为内部集合保留 集合名称使用 . 字符可以创建子集合，用与区分不同组织集合。虽然子集合没有任何特殊属性，但它们很有用，许多 MongoDB 工具整合了子集合。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"文档 文档是 MongoDB 中数据的基本存储单元，以一种叫作 BSON 的文档结构表示。 文档中的键值对是有序的，不同序则是不同文档。并且键是区分大小写的，否则也为不同文档。 文档的键是字符串，而值除了字符串，还可以是 Int、Long、Double、Boolean、数组、嵌入文档等多种类型。 每个文档都有一个默认的 _id 键，它相当于关系型数据库中的主键，这个键的值在同一个集合中必须是唯一的。 _id 键的值默认是 ObjectId 类型，在插入文档的时候，如果用户不设置文档的 _id 值的话，MongoDB 会自动生成一个唯一的 ObjectId 值进行填充。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"数据库文件 MongoDB 在 3.2 版本已经将 WiredTiger 作为默认的存储引擎。其作为存储引擎的时候，数据库会有以下存储文件： collection-*.wt: 存储集合的数据 index-*.wt: 存储索引的数据 WiredTiger: 存储基本配置信息 WiredTiger.wt: 存储所有其他集合的元数据信息 WiredTiger.lock: 存储进程 ID，用于防止多个进程连接同一个 WiredTiger 数据库 WiredTiger.turtle: 存储 WiredTiger.wt 的元数据信息 journal: 存储数据库的写日志 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"命令行工具 MongoDB 提供的 mongosh 是一个 JavaScript 的 shell，其提供了许多高级功能和自定义功能。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"使用技巧 对于 MongoDB 提供的功能，shell 内置了帮助文档，可以输入 help 命令进行访问，使用 db.help() 可以查看数据库级别的帮助文档，使用 db.foo.help() 可以查看集合级别的帮助文档。 在 shell 中使用函数之前，在不使用括号的情况下输入函数名，这样会打印出函数的源代码，这是一个可以查看函数具体行为的好方法。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"执行脚本 shell 不止可以直接执行 JavaScript 的脚本代码，还可以用于执行 JavaScript 的脚本文件，简单执行 mongo script.js 即可。 如果已经进入到 shell 中，可以使用 load() 函数加载 JavaScript 脚本文件。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"创建 .mongorc.js 文件 对于需要频繁被加载的脚本，可以将它们添加到 .mongorc.js 中，此文件会在启动 shell 时自动运行。 在更实际一些的场景中，使用此脚本可以设置全局变量，或者为长名称设置一个简短的别名，也可以重写内置函数。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"定制提示信息 通过将 prompt 变量设置为一个字符串或函数，可以重写默认的 shell 提示，如下示例： prompt = function() { if (typeof db == 'undefined') { return '(nodb)\u003e '; } // 检查最后的数据库操作 try { db.runCommand({getLastError: 1}); } catch (e) { print(e); } return db+\"\u003e \"; }; 提示函数应该返回一个字符串，通常应该包含对 getLastError 的调用，这样可以捕获输入时的错误，并在 shell 断开连接时自动重新连接。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:4","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"编辑复杂变量 使用 shell 时，编辑多行的时候不能再编辑前面的行，这对于较大的代码块或对象非常不友好。 为此，可以在 shell 中设置 EDITOR 变量，则可以使用 edit varname 的方式编辑一个变量，完成更改后只需保存并退出编辑器，变量将被重新解析并加载回 shell 中。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:5","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["数据库技术"],"content":"不便使用的集合名称 大多数情况下可以使用 db.collectionName 语法来获得一个集合的内容，但如果集合名称是保留字或是无效的 JavaScript 属性名称时，那么此方法就不能正常工作了。 对于上述的情况，可以使用 db.getCollection() 的方式绕过无效属性。 ","date":"2022-11-14","objectID":"/posts/database/mongodb-started-guide.html:4:6","tags":["NoSQL","MongoDB"],"title":"MongoDB - 入门指南","uri":"/posts/database/mongodb-started-guide.html"},{"categories":["程序设计"],"content":"解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器。 ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"简介 在某些情况下，为了更好地描述某一些特定类型的问题，我们可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则。 解释器设计模式（Interpreter Design Pattern）描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。 因此，解释器模式的定义是，为某个语言定义它的语法（文法）表示，并定义一个解释器用来处理这个语法。 ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 首先，需要定义一个抽象表达式类，其声明了抽象的解释操作，其代码示例如下： public abstract class AbstractExpression { public abstract void interpret(Context context); } 终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。其代码示例如下： public class TerminalExpression extends AbstractExpression { public void interpret(Context context) { // 终结符表达式的解释操作 } } 非终结符表达式类相对比较复杂，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。其代码示例如下： public class NonTerminalExpression extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public NonTerminalExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } public void interpret(Context context) { // 递归调用每一个组成部分的 interpret() 方法 // 在递归调用时指定组成部分的连接方式，即非终结符的功能 } } 通常在解释器模式中会提供一个环境类用于存储一些全局信息，如使用 HashMap 或者 ArrayList 等类型的集合对象，存储一系列公共信息，其代码示例如下： public class Context { private HashMap\u003cString, String\u003e map = new HashMap\u003c\u003e(); public void assign(String key, String value) { // 往环境中设值 map.put(key, value); } public String lookup(String key) { // 获取存储在环境类中的值 return map.get(key); } } ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"优点 解释器模式的主要优点如下： 易于改变和扩展文法 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言 实现文法较为容易 增加新的解释器表达式较为方便 ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 解释器模式的主要缺点如下： 对于复杂文法难以维护，增加文法规则会导致类急剧增加，导致系统难以管理和维护 解释器模式使用了大量循环和递归调用，执行效率较低 ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 解释器模式的适用场景如下： 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来进行表达 一个语言的文法较为简单 ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.text.Format 就是一个抽象表达式类的实现，如下是其部分源码： public abstract class Format implements Serializable, Cloneable { AttributedCharacterIterator createAttributedCharacterIterator(String s) { AttributedString as = new AttributedString(s); return as.getIterator(); } AttributedCharacterIterator createAttributedCharacterIterator( AttributedCharacterIterator[] iterators) { AttributedString as = new AttributedString(iterators); return as.getIterator(); } } ","date":"2022-11-11","objectID":"/posts/programming-pattern/interpreter-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 解释器模式","uri":"/posts/programming-pattern/interpreter-design-pattern.html"},{"categories":["程序设计"],"content":"访问者模式被认为是最复杂的设计模式，并且使用频率不高。大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。 ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"简介 访问者设计模式（Visitor Design Pattern）的定义是，允许一个或多个操作应用到一组对象上，解耦操作和对象本身。 在使用访问者模式的时候，被访问的元素通常不是单独存在的，它们存储在一个集合中，这个集合称为“对象结构”，访问者通过遍历对象结构实现对其存储的元素进行逐个访问。 访问者模式使用了“双重分派”的调用机制，即元素对象定义一个操作方法支持注入访问者对象，在操作方法内调用访问者的访问方法，并将当前元素对象传入到访问方法中。 ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 在这里举一个工作当中的具体例子，在小公司的项目组当中，名义上区分了开发、测试等岗位，但实际上开发人员既要会开发，也有会测试，对于测试人员也是同样的要求，既要会测试，也要会开发。 在这里案例当中，开发人员、测试人员统称为元素，我们在这里先构建一个抽象的元素类。其代码示例如下： public interface Element { // 定义一个接受访问者访问的抽象方法 void accept(Visitor visitor); } 对于开发人员类，根据自己的情况实现这个 accept() 方法，其代码如下： public class Programmer implements Element { private String name = \"开发人员\"; public void setName(String name) { this.name = name; } public String getName() { return name; } @Override public void accept(Visitor visitor) { visitor.visitProgrammer(this); } } 对于测试人员，根据自己的情况实现这个 accept() 方法，其代码如下： public class Tester implements Element { private String name = \"测试人员\"; public void setName(String name) { this.name = name; } public String getName() { return name; } @Override public void accept(Visitor visitor) { visitor.visitTester(this); } } 第二步，最重要的就是要定义好一个访问者类，在这里抽象出的访问者接口可以是以项目组为范围，为项目组中的每一个元素定义对应的访问方法。其代码示例如下： public interface Visitor { void visitProgrammer(Programmer programmer); void visitTester(Tester tester); } 每当出现一个新的操作时，就可以实现访问者接口，注入不同的元素对象以实现不同的操作。 如下是开发人员和测试人员使用开发技能的代码示例： public class DevelopVisitor implements Visitor { @Override public void visitProgrammer(Programmer programmer) { System.out.println(programmer.getName() + \"在开发\"); } @Override public void visitTester(Tester tester) { System.out.println(tester.getName() + \"在开发\"); } } 如下是开发人员和测试人员使用测试技能的代码示例： public class TestVisitor implements Visitor { @Override public void visitProgrammer(Programmer programmer) { System.out.println(programmer.getName() + \"在测试\"); } @Override public void visitTester(Tester tester) { System.out.println(tester.getName() + \"在测试\"); } } ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"优点 访问者模式的主要优点如下： 能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能，符合开闭原则 将有关元素的行为都封装到一个访问者对象中，每个访问者对象的功能都比较单一，符合单一职责原则 ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 访问者模式的主要缺点如下： 增加新的元素类需要在每一个访问者类中都增加相应的具体操作，这违背了开闭原则 访问者对象可以访问并调用每一个元素对象的操作，这意味着元素对象有时候会暴露一些内部操作和内部状态，破坏了封装 访问者模式依赖了具体类，而没有依赖抽象类，违反了依赖倒置原则 ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 访问者模式的适用场景如下： 对象结构中元素对象的类很少改变，但经常需要在此对象结构上定义新的操作 ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"源码 访问者模式提供一个方便的可维护的方式来操作一组对象，JDK 内置了这样的元素接口和访问者接口。 如下是元素接口 javax.lang.model.element.Element 的部分代码： public interface Element extends javax.lang.model.AnnotatedConstruct { \u003cR, P\u003e R accept(ElementVisitor\u003cR, P\u003e v, P p); } 如下是访问者接口 javax.lang.model.element.ElementVisitor 的部分代码： public interface ElementVisitor\u003cR, P\u003e { R visit(Element e, P p); default R visit(Element e) { return visit(e, null); } } ","date":"2022-11-10","objectID":"/posts/programming-pattern/visitor-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 访问者模式","uri":"/posts/programming-pattern/visitor-design-pattern.html"},{"categories":["程序设计"],"content":"中介模式属于行为型设计模式，可以将原本难以理解的网状结构转换成了相对加单的星型结构，主要用来降低多个对象和类之间的通信复杂性。 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"简介 中介设计模式（Mediator Design Pattern）定义了一个单独的（中介）对象，来封装一组对象之间的交互。 如果对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象的其他所有对象，并进行适当处理。 而中介模式将这些对象之间的交互委派给中介对象交互，来避免对象之间直接交互，使其耦合松散。 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 首先，定义一个抽象中介者接口，该接口用于与各对象之间进行通信。其代码示例如下： public abstract class Mediator { // 维持所有同事对象的引用 protected ArrayList\u003cColleague\u003e colleagues; // 注册方法，用于增加同事对象 public void register(Colleague colleague) { colleagues.add(colleague); } // 声明抽象的业务方法 public abstract void operation(); } 对于具体的中介者对象，主要是实现自己的业务方法，封装同事之间的调用。其代码示例如下： public class ConcreteMediator extends Mediator { @Override public void operation() { // 通过中介者调用同事类的方法 this.colleagues.get(0).method1(); } } 然后，需要定义一个抽象的同事类，其维持了一个抽象中介者的引用，用于调用中介者的方法。其代码示例如下： public abstract class Colleague { // 维持一个抽象中介者的引用 protected Mediator mediator; public Colleague(Mediator mediator) { this.mediator = mediator; } // 声明自身方法，处理自己的行为 public abstract void method1(); // 定义依赖方法，与中介者通信 public void method2() { mediator.operation(); } } 具体的同事类也比较简单，只需要继承自抽象同事类，然后定义好自己的行为即可。 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"优点 中介模式的主要优点如下： 中介模式将一对多的关系简化成了一对一的关系，降低了类的复杂度，简化了对象之间的交互 将各同事对象解耦，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则” 中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使得各个同事类可被重用，无须对同事类进行扩展 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 中介模式的主要缺点如下： 具体的中介者类中包含了大量同事之间的交互逻辑，可能会导致具体中介者类非常复杂 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 中介模式的适用场景如下： 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解 一个对象由于引用了许多其他对象并且直接和这些对象通信，导致难以复用该对象 想通过一个中间类来封装多个类中的行为，而又不想生成太多子类 ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中 java.util.Timer 就使用到了中介模式。如下是其源码部分： public class Timer { private final TaskQueue queue = new TaskQueue(); private void sched(TimerTask task, long time, long period) { if (time \u003c 0) throw new IllegalArgumentException(\"Illegal execution time.\"); if (Math.abs(period) \u003e (Long.MAX_VALUE \u003e\u003e 1)) period \u003e\u003e= 1; synchronized(queue) { if (!thread.newTasksMayBeScheduled) throw new IllegalStateException(\"Timer already cancelled.\"); synchronized(task.lock) { if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( \"Task already scheduled or cancelled\"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; } queue.add(task); if (queue.getMin() == task) queue.notify(); } } } ","date":"2022-11-09","objectID":"/posts/programming-pattern/mediator-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 中介模式","uri":"/posts/programming-pattern/mediator-design-pattern.html"},{"categories":["程序设计"],"content":"职责链模式是一种与策略模式类似的设计模式，都是使用多个对象去处理同一个请求。不同的是，职责链模式针对的一条链路上的所有对象，而不是“非此即彼”的关系。 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"简介 职责链设计模式（Chain Of Responsibility Design Pattern）的定义是，将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。 同时，将这些接收对象串成一条链，并沿着这条链传递这个对象，直至链上的某个接收对象能够处理这个请求为止。 职责链可以是一条直线、一个环或一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 首先，定义一个抽象处理者 Handler 类，其代码示例如下： public abstract class Handler { // 维持对下一个处理者的引用 protected Handler successor; public void setHandler(Handler successor) { this.successor = successor; } public abstract void handleRequest(String Request); } 然后，定义一个具体处理者 ConcreteHandler 子类，其代码示例如下： public class ConcreteHandler extends Handler { public void handleRequest(String request) { // 处理请求或者转发请求 this.successor.handleRequest(request); // 执行完当前处理方法后，可以执行下一个处理者的处理，完成链路循环 } } 对于客户端而言，只需要知道第一个具体处理者是谁即可，无需关心后续的其他处理者。这就像是操作链表一样，知道链表的头结点即可访问链表的所有结点。 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"分类 根据处理者对象的行为，职责链模式可以分为纯的职责链模式和不纯的职责链模式。 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"纯的职责链模式 一个纯的职责链模式要求一个具体处理者对象只能在两种行为中选择一个：要么承担全部责任，要么将责任推给下家。 同时，纯的职责链模式要求一个请求必须被某一个具体处理者对象所接受，不能出现某个请求未被处理者对象接收的情形。 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"不纯的职责链模式 不纯的职责链模式是与纯的职责链模式相对的一种模式。 在一个不纯的职责链模式中，允许某个请求被具体处理者部分处理后还能向下传递，或者一个具体处理者处理完某个请求后其后继处理者可以继续处理该对象，而且同一个请求可以最终不被任何处理者对象所接收。 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"优点 职责链模式的主要优点如下： 将发送者和接收者解耦，客户端无需知道请求被哪一个对象处理 当工作流程发生变化，可以动态地改变链内的成员或调动它们的次序，也可动态的新增或删除职责 通过链式结构串联处理者，可以根据需要增加新的处理类，符合开闭原则 纯的职责链模式明确了各类的职责范围，符合类的单一职责原则 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 职责链模式的主要缺点如下： 由于请求没有一个明确的处理者，不能保证请求一定会被处理 对于较长的职责链，请求的处理涉及到多个处理对象，系统性能将受到一定影响 职责链的建立要靠客户端来保证，增加了客户端的复杂性，建链不当可能造成循环引用 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 职责链模式的适用场景如下： 多个对象可以处理一个请求，但具体由哪一个对象处理在运行时自动确定 需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求 动态地指定一组处理者，或者改变链中处理者之间的次序 ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中 java.util.logging.Logger 记录日志有可能有多个不同的 Handler 处理器，如果使用这些 Handler 处理器就是一种职责链模式的运用。 如下是源码部分： public void log(LogRecord record) { if (!isLoggable(record.getLevel())) { return; } Filter theFilter = config.filter; if (theFilter != null \u0026\u0026 !theFilter.isLoggable(record)) { return; } Logger logger = this; while (logger != null) { final Handler[] loggerHandlers = isSystemLogger ? logger.accessCheckedHandlers() : logger.getHandlers(); for (Handler handler : loggerHandlers) { handler.publish(record); } final boolean useParentHdls = isSystemLogger ? logger.config.useParentHandlers : logger.getUseParentHandlers(); if (!useParentHdls) { break; } logger = isSystemLogger ? logger.parent : logger.getParent(); } } ","date":"2022-11-08","objectID":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 职责链模式","uri":"/posts/programming-pattern/chain-of-responsibility-design-pattern.html"},{"categories":["程序设计"],"content":"备忘录模式是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"简介 备忘录设计模式（Memento Design Pattern）也叫作快照（Snapshot）模式，主要用于实现防丢失、撤销、恢复等功能。 其定义是，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象先前的状态。 ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 首先，定义一个备忘录 Memento 类存储状态，其代码示例如下： public class Memento { private String state; public Memento(Originator o) { this.state = o.getState(); } public void setState(String State) { this.state = state; } public String getState() { return this.state; } } 然后，把需要被存储状态的对象称作为发起者，定义为 Originator 类，包含用于存储成员数据的属性，其代码示例如下： public class Originator { private String state; public Originator() {} // 创建一个备忘录对象 public Memento createMemento() { return new Memento(this); } // 根据备忘录状态恢复原发器状态 public void restoreMemento(Memento m) { state = m.getState(); } public void setState(String State) { this.state = state; } public String getState() { return this.state; } } 定义一个负责人 Caretaker 用于管理备忘录对象，其代码示例如下： public class Caretaker { private Memento memento; public Memento getMemento() { return this.memento; } public void setMemento(Memento memento) { this.memento = memento; } } ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"优点 备忘录模式的主要优点如下： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了内部状态的封装，使得用户不需要关心状态的保存细节 ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 备忘录模式的主要缺点如下： 如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源 ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 备忘录模式的适用场景如下： 保存一个对象在某一时刻的全部状态或部分状态，方便后续实现恢复和撤销 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象 ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中 java.util.Date 通过自身内部的一个 Long 值来实现备忘录模式。 如下是源码部分： public class Date implements java.io.Serializable, Cloneable, Comparable\u003cDate\u003e { private transient long fastTime; public Date(long date) { fastTime = date; } public long getTime() { return getTimeImpl(); } private final long getTimeImpl() { if (cdate != null \u0026\u0026 !cdate.isNormalized()) { normalize(); } return fastTime; } } ","date":"2022-11-04","objectID":"/posts/programming-pattern/memento-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 备忘录模式","uri":"/posts/programming-pattern/memento-design-pattern.html"},{"categories":["数据库技术"],"content":"MongoDB 是一个基于分布式文件存储的数据库，因此其常作为使用了大数据技术的公司的优选；MongoDB 的存储是类 JSON 结构，因此在一些敏捷 Web 开发中也常使用到。 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:0:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["数据库技术"],"content":"什么是 NoSQL NoSQL 是一种非关系型数据库管理系统，不需要固定的架构，可以避免 JOIN 连接，并且易于扩展。 NoSQL 常用于具有庞大数据存储需求的分布式数据存储，通常是大数据和实时 Web 应用程序等场景。 对于海量数据，使用 RDBMS 处理是会导致系统响应时间变慢，一般的替代方案都是在负载增加时横向扩展到其他的服务器上，而 NoSQL 比关系型数据库更容易扩展。 NoSQL 的功能和优点主要是以下几点： NoSQL 数据库不遵循关系模型 NoSQL 数据库是无模式或具有宽松模式的数据库 NoSQL 提供简单的 API 作为存储和查询 NoSQL 可以以分布式方式执行，易于扩展 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:1:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["数据库技术"],"content":"关于 MongoDB MongoDB 是一个以 BSON 为数据模型的文档数据库，其中 BSON 是一种类 JSON 的二进制存储格式。 文档类似于 JSON 对象，其中存储的也是键值对的数据结构，字段的值也可以包括其他文档、数组和文档数组。 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:2:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["数据库技术"],"content":"主要特点 易于使用：建模不是必需的，类 JSON 数据模型仅用一条数据表示复杂的层次关系 易于扩展：自带分片功能，完美支持横向扩展（更多机器），无需更改应用程序的逻辑 功能丰富：支持通用的二级索引，支持聚合分析数据，支持生命周期有限集合，针对大文件存储等等功能 性能卓越：使用多粒度锁尽可能提高并发和吞吐量，使用尽可能多的内存作为缓存，尽可能为查询自动选择正确的索引 高可用：自带副本集的概念，支持自动故障转移和数据冗余，对读负载均衡非常友好 支持多种存储引擎：自带 WiredTiger 存储引擎、内存存储引擎，并且提供可插拔的 API 允许第三方开发存储引擎 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:2:1","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["数据库技术"],"content":"适用场景 MongoDB 主要有以下适用场景： 作为应用数据库使用，类似于 Oracle、MySQL，由于其建模是非必需的，更适合创业公司快速迭代使用 由于其性能较高，且易于扩展，也常用在大数据领域中，通常是用作海量数据处理及搭建数据平台 MongoDB 也有以下不适用场景： 高度事务化的系统：需要大量原子性复杂事务的应用程序使用传统的关系型数据库会更好 传统的商业智能应用：针对特定问题的 BI 数据库会产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:2:2","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["数据库技术"],"content":"技术优势总结 类 JSON 结构和对象模型接近，开发代码量低 类 JSON 的动态模型意味着更容易响应新的业务需求 MongoDB 原生支持的副本集提供 99.999% 高可用 MongoDB 使用分片架构支持海量数据和无缝扩容 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:2:3","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["数据库技术"],"content":"MongoDB vs 关系型数据库 不同点 MongoDB RDBMS 数据模型 文档模型 关系模型 数据库类型 OLTP(联机事务处理) OLTP CRUD MQL/SQL SQL 高可用 复制集 集群模式 横向扩展能力 原生分片完美支持 数据分区或者应用侵入式 索引支持 B 树全文索引地理位置索引多键索引TTL 索引 B+ 树 开发难度 容易 困难 数据容量 没有理论上限 千万、亿 扩展方式 垂直扩展 + 水平扩展 垂直扩展 ","date":"2022-11-01","objectID":"/posts/database/mongodb-simple-know.html:3:0","tags":["NoSQL","MongoDB"],"title":"MongoDB - 简单了解","uri":"/posts/database/mongodb-simple-know.html"},{"categories":["程序设计"],"content":"模板方法模式是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。 ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"简介 在模板方法设计模式（Template Method Design Pattern）中比较重要的两个概念是 基本方法 和 模板方法。 实现具体逻辑步骤的方法可以称之为基本方法，而把基本方法汇总起来形成一个总算法或总行为的方法称之为模板方法。 基本方法包括以下几种类型： 具体方法：在抽象类中声明，由具体子类实现 抽象方法：在抽象类中已经实现，在具体子类中可以继承或重写 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种 ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 在模板方法模式中，最重要的就是定义好一个抽象类，并在其中归纳总结出一个模板方法。一般而言，其代码结构示例如下： public abstract class AbstractClass { // 模板方法 public void templateMethod() { // 一般来说，主要是如何执行基本方法 concreteMethod(); abstractMethod(); hookMethod(); } // 基本方法 - 具体方法 public void concreteMethod() { // 实现代码 } // 基本方法 - 抽象方法 public abstract void abstractMethod(); // 基本方法 - 钩子方法 public void hookMethod() { // 实现代码 } } 然后，需要定义一个继承自抽象类的具体子类，并根据业务重写相应基本方法，其代码示例如下： public class ConcreteClass extends AbstractClass { // 基本方法 - 抽象方法 @Override public void abstractMethod() { // 实现代码 } // 基本方法 - 钩子方法 @Override public void hookMethod() { // 实现代码 } } ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"优点 模板方法模式的主要优点如下： 封装了不变部分，扩展了可变部分 在父类中提取了公共的部分代码，便于代码复用 通过子类覆盖父类的钩子方法可以实现一种反向控制结构 部分方法是由子类实现，不同的子类可以提供基本方法的不同实现，更改和增加新的子类很方便，符合开闭原则 ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 模板方法模式的主要缺点如下： 每个不同的实现都要增加一个子类，这会导致类的个数增加，设计更加抽象，系统更加复杂 由于继承关系自身的缺点，如果父类添加新的抽象方法时，所有子类都要改一遍 ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 模板方法模式的适用场景如下： 将不变的行为提取到父类中实现，将可变的行为留给子类实现 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制 ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.util.List 接口的 sort() 方法就是一个模板方法，其使用到部分基本方法，定义了一个排序的默认行为。 如下是源码部分： public interface List\u003cE\u003e extends Collection\u003cE\u003e { Object[] toArray(); ListIterator\u003cE\u003e listIterator(); // 一个默认方法，其中用到了 toArray() 和 listIterator() 这样的抽象方法 default void sort(Comparator\u003c? super E\u003e c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator\u003cE\u003e i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } } ","date":"2022-10-26","objectID":"/posts/programming-pattern/template-method-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 模板方法模式","uri":"/posts/programming-pattern/template-method-design-pattern.html"},{"categories":["程序设计"],"content":"顾名思义，状态模式用于解决系统中与状态相关的问题，如复杂对象的状态转换以及不同状态下行为的封装问题。 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"简介 状态模式（State Design Pattern）的定义是，允许一个对象在内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 在状态模式中，通常有两种方式实现状态转换：统一由环境类来负责状态之间的转换；由具体状态类来负责状态之间的转换。 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"状态机 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"概念 状态模式一般用于实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。 状态机会有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。 拿“超级马里奥”游戏来举例，其中马里奥形态的转变就是一个状态机：初始状态是小马里奥，吃蘑菇这个事件会触发状态的转移，从小马里奥转变成超级马里奥，以及触发动作的执行（增加积分）。 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:2:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"分支逻辑法 最简单的状态机实现方式就是分支逻辑法，其理解非常简单，就是将每一个状态转移都直译成代码。 其缺点是，代码中会充斥着 if-else 或 switch 分支判断逻辑，甚至是嵌套的分支判断逻辑，当状态较多时，代码的可读性会比较低。 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:2:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"查表法 查表法的实现逻辑是，将状态、事件和动作三者存储到一个二维表中，这样可以清晰地表示，一个动作发生某个事件时，会转移到怎样的状态以及触发怎样的动作。 在实现过程中，将二维表的数据存储到配置文件中，可以通过动态地修改配置文件以达到修改状态机的目的。 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:2:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 仍然还是拿“超级马里奥”游戏来举例说明，初始状态是小马里奥，吃蘑菇这个事件会触发状态的转移，从小马里奥转变成超级马里奥，以及触发动作的执行（增加积分）。 首先，定义一个抽象状态 State 接口，其代码示例如下： public interface State { // 声明抽象业务方法，不同的具体状态可以有不同的方法实现 void handle(); } 对于小马里奥状态，定义一个实现 State 接口的 SmallState 类，其代码示例如下： public class SmallState implements State { @Override public void handle() { // 业务方法的具体实现 System.out.println(\"变成小马里奥状态\"); } } 对于超级马里奥状态，定义一个实现 State 接口的 SuperState 类，其代码示例如下： public class LargeState implements State { @Override public void handle() { // 业务方法的具体实现 System.out.println(\"变成超级马里奥状态\"); } } 在状态模式中，需要创建一个 Context 类用于保存对于一个具体状态对象的引用，并且负责状态的保持和转变。其代码示例如下： public class Context { private State state; public void setState(State state) { // 注入状态对象 this.state = state; } public void request() { // 调用状态对象的业务方法 this.state.handle(); } } 对于客户端，直接操作 Context 对象并根据状态的转变传入不同的状态对象，这样即可实现状态机的功能，其代码示例如下： class StateDemo { public static void main(String[] args) { Context context = new Context(); State smallState = new SmallState(); context.setState(smallState); // 变成小马里奥状态 context.request(); State largeState = new LargeState(); context.setState(largeState); // 变成超级马里奥状态 context.request(); } } ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"优点 状态模式的主要优点如下： 状态模式统一封装了状态的转换规则，对状态转换代码进行集中管理 将不同的状态引入独立的对象中使得状态转换变得更加明确，且减少对象间的相互依赖 状态的职责分明，通过定义新的子类可以很容易地增加新的状态和转换 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 状态模式的主要缺点如下： 每个状态都会新增一个具体的状态子类，导致系统的运行开销增大 状态模式的结构和实现都较为复杂，使用不当会导致程序结构和代码的混乱 对于可以切换的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增的状态，而且修改某个状态类的行为也要修改对应类的源码 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 状态模式的适用场景如下： 对象的行为依赖于它的状态，状态的改变将导致行为的变化 在代码中包括大量与对象状态有关的条件语句 ","date":"2022-10-25","objectID":"/posts/programming-pattern/state-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 状态模式","uri":"/posts/programming-pattern/state-design-pattern.html"},{"categories":["折腾日志"],"content":"随着博客的文章越来越多，原本没有搜索功能的博客变得难以使用起来，博客添加一个搜索功能势在必行啊。 ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:0:0","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"起因 我的博客使用了 hugo 作为静态生成工具，自带的主题里也没有附带搜索功能。看来，还是得自己给博客添加一个搜索功能。 经过多方查找，从 Hugo Fast Search · GitHub 找到一片详细、可用的教程（虽然后面魔改了一些）。 ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:1:0","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"实际案例 ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:0","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"步骤 在 config.toml 文件做好相关配置； 添加导出 JSON 格式文件的脚本，即在 layouts/_default 目录下添加 index.json 文件； 增加依赖的 JS 脚本，包含自己的 search.js 和 fuse.js 文件； 添加相关 HTML 代码； 添加相关 CSS 样式。 ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:1","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"配置 [params] # 是否开启本地搜索 fastSearch = true [outputs] # 增加 JSON 配置 home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:2","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"添加 index.json 文件 {{- $.Scratch.Add \"index\" slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \"index\" (dict \"title\" .Title \"permalink\" .Permalink \"content\" .Plain) -}} {{- end -}} {{- $.Scratch.Get \"index\" | jsonify -}} ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:3","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"添加依赖 首先，可以先添加 fuse.js 依赖，它是一个功能强大的轻量级模糊搜索库，可以到 官网 访问更多信息： {{- if .Site.Params.fastSearch -}} \u003cscript src=\"https://cdn.jsdelivr.net/npm/fuse.js@6.4.6\"\u003e\u003c/script\u003e {{- end -}} 然后，就是添加自定义的 search.js 文件以实现搜索功能，文件放置在 assets/js 目录下。 这里的代码和 Gist 上的有些许不同，经过了自己的魔改。 var fuse; // holds our search engine var searchVisible = false; var firstRun = true; // allow us to delay loading json data unless search activated var list = document.getElementById('searchResults'); // targets the \u003cul\u003e var first = list.firstChild; // first child of search list var last = list.lastChild; // last child of search list var maininput = document.getElementById('searchInput'); // input box for search var resultsAvailable = false; // Did we get any search results? // ========================================== // The main keyboard event listener running the show // document.addEventListener(\"click\", event =\u003e { var cDom = document.getElementById(\"fastSearch\"); var sDom = document.getElementById('search-click'); var tDom = event.target; if (sDom == tDom || sDom.contains(tDom)) { showSearchInput(); } else if (cDom == tDom || cDom.contains(tDom)) { // ... } else if (searchVisible) { cDom.style.display = \"none\" searchVisible = false; } }); document.addEventListener('keydown', function(event) { // CMD-/ to show / hide Search if (event.metaKey \u0026\u0026 event.which === 191) { showSearchInput() } // Allow ESC (27) to close search box if (event.keyCode == 27) { if (searchVisible) { document.getElementById(\"fastSearch\").style.display = \"none\"; document.activeElement.blur(); searchVisible = false; } } // DOWN (40) arrow if (event.keyCode == 40) { if (searchVisible \u0026\u0026 resultsAvailable) { event.preventDefault(); // stop window from scrolling if ( document.activeElement == maininput) { first.focus(); } // if the currently focused element is the main input --\u003e focus the first \u003cli\u003e else if ( document.activeElement == last ) { last.focus(); } // if we're at the bottom, stay there else { document.activeElement.parentElement.nextSibling.firstElementChild.focus(); } // otherwise select the next search result } } // UP (38) arrow if (event.keyCode == 38) { if (searchVisible \u0026\u0026 resultsAvailable) { event.preventDefault(); // stop window from scrolling if ( document.activeElement == maininput) { maininput.focus(); } // If we're in the input box, do nothing else if ( document.activeElement == first) { maininput.focus(); } // If we're at the first item, go to input box else { document.activeElement.parentElement.previousSibling.firstElementChild.focus(); } // Otherwise, select the search result above the current active one } } }); // ========================================== // execute search as each character is typed // document.getElementById(\"searchInput\").onkeyup = function(e) { executeSearch(this.value); } function showSearchInput() { // Load json search index if first time invoking search // Means we don't load json unless searches are going to happen; keep user payload small unless needed if(firstRun) { loadSearch(); // loads our json data and builds fuse.js search index firstRun = false; // let's never do this again } // Toggle visibility of search box if (!searchVisible) { document.getElementById(\"fastSearch\").style.display = \"block\"; // show search box document.getElementById(\"searchInput\").focus(); // put focus in input box so you can just start typing searchVisible = true; // search visible } else { document.getElementById(\"fastSearch\").style.display = \"none\"; // hide search box document.activeElement.blur(); // remove focus from search box searchVisible = false; // search not visible } } // ========================================== // fetch some json without jquery // function fetchJSONFile(path, callback) { var httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = function() { if (httpRequest.readyState === 4) { if (httpRequest.status === 200) { var data = JSON.parse(httpRequest.responseText); if (callback) callback(data); } } }; httpRequest.open('GET', path); httpReq","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:4","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"添加 HTML 代码 HTML 页面的代码分为两个部分：搜索的按钮、搜索框和结果展示。 我这里将搜索的按钮放到的菜单栏，主要是一个可点击的按钮： {{ if .Site.Params.fastSearch -}} \u003cli id=\"search-click\" class=\"menu-item\"\u003e \u003ca class=\"menu-item-link\" href=\"javascript:void(0)\"\u003e搜索\u003c/a\u003e \u003c/li\u003e {{- end }} 对于搜索框，我选择的是弹出式的窗口，这里比较重要的是标签的 ID 需要和 search.js 脚本一致： {{ if .Site.Params.fastSearch -}} \u003cdiv id=\"fastSearch\"\u003e \u003cinput id=\"searchInput\"\u003e \u003cul id=\"searchResults\"\u003e\u003c/ul\u003e \u003c/div\u003e {{- end }} ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:5","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"添加 CSS 样式 页面样式这部分，主要是看个人的喜好，这里只放出自己的样式： #fastSearch { display: none; position: fixed; left: 50%; top: calc(5vw + 40px); transform: translateX(-50%); z-index: 4; width: 650px; background-color: #fff; box-shadow: 0 1px 2px #3c40434d, 0 2px 6px 2px #3c404326; border-radius: 4px; overflow: hidden; input { padding: 10px; width: 100%; height: 30px; font-size: 18px; line-height: 30px; border: none; outline: none; font-family: inherit; } #searchResults { display: none; overflow-y: auto; max-height: 60vh; padding-left: 0; margin: 0; border-top: 1px dashed #ddd; .search-highlight { color: red; } li { list-style: none; margin: 0; a { text-decoration: none; color: inherit; padding: 6px 10px; display: block; font-size: 14px; letter-spacing: .04em; } a:hover, a:focus { filter: brightness(93%); outline: 0; background-color: rgb(240, 240, 240); } .title { font-weight: 600; } } li.noSearchResult { text-align: center; margin: 8px 0; color: #888; } } } ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:6","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"样例展示 ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:2:7","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["折腾日志"],"content":"总结 经过两天时间的奋斗，终于是将搜索功能给上线了。 不得不说，理想总是一开始美好，最初以为是一个完整、可用的教程，却没想到复制到代码之后就不可用了，最终是经过自己的魔改才得以使用。 总结一下就是，没有实践就没有话语权，千万不要做管中窥豹的那个人。 ","date":"2022-10-24","objectID":"/posts/z-turn/hugo-add-local-search.html:3:0","tags":["博客"],"title":"给 hugo 博客添加搜索功能","uri":"/posts/z-turn/hugo-add-local-search.html"},{"categories":["程序设计"],"content":"命令模式是一种数据驱动的设计模式，它属于行为型设计模式。通过使用命令模式，可以极大地降低系统的耦合度。 ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"简介 命令设计模式（Command Design Pattern）可以将请求发送者和接收者完全解耦。发送者和接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 其定义是，将请求（命令）封装成一个对象，从而可用不同的请求对客户进行参数化（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。 ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 首先，定义一个抽象命令 Command 接口，通常仅声明一个执行命令的方法，其代码示例如下： public interface Command { // 业务处理方法 void execute(); } 具体命令会实现各种类型的请求，其自身并不完成工作，而是将调用委派给一个业务逻辑对象，其代码示例如下： public class ConcreteCommand implements Command { // 维持一个对请求者对象的引用 private final Receiver receiver; public ConcreteCommand(Receiver receiver) { this.receiver = receiver; } // 调用请求接收者的业务处理方法 public void execute() { this.receiver.action(); } } 接收者是真正命令执行的对象，是客户端直接操作的对象，其代码示例如下： public class Receiver { public void action() { // 具体操作 } } 最后，需要定义的是调用者 Invoker 类，其作用是负责对请求进行初始化，其代码示例如下： public class Invoker { private final List\u003cCommand\u003e commandList; public Invoker() { this.commandList = new ArrayList\u003c\u003e(); } public Invoker(Command command) { this(); this.commandList.add(command); } // 添加命令 public void pushCommand(Command command) { this.commandList.add(command); } // 执行命令 public void executeAll() { for (Command command : commandList) { command.execute(); } commandList.clear(); } } 对于客户端而言，需要知道自己需要操作的接收者对象是什么、可以执行的命令有哪些、通过调用者如何去执行这些命令。 如下是客户端使用命令模式的代码示例： public class CommandDemo { public static void main(String[] args) { // 操作的接收者对象是什么 Receiver receiver = new Receiver(); // 可以执行的命令有哪些 Command command = new ConcreteCommand(receiver); // 通过调用者如何去执行这些命令 Invoker invoker = new Invoker(command); invoker.executeAll(); } } ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"优点 命令模式的主要优点如下： 降低请求者和接收者的耦合度 新的命令可以很方便地加入到系统中 可以比较容易地设计一个命令队列或者宏命令（组合命令） 为请求的撤销和恢复操作提供了一种设计和实现方案 ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 命令模式的主要缺点如下： 可能会导致系统中有过多的具体命令类 ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 命令模式的适用场景如下： 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互 系统需要在不同的时间指定请求、将请求排队和执行请求 系统需要支持命令的撤销操作和恢复操作 系统需要将一组操作组合在一起形成宏命令 ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，Runnable 接口就类似于命令模式的命令接口。 只要实现了 Runnable 接口的类都被认为是一个线程类，相当于命令模式中具体命令类的角色。而实现了 Runnable 接口的 Thread 类既可以作为具体命令类，也可以作为调用者。 如下是客户端使用 Runnable 和 Thread 的代码示例： public class ThreadDemo { public static void main(String[] args) { Runnable command = new Runnable() { @Override public void run() { System.out.println(\"command 线程执行\"); } }; Thread thread = new Thread(command); // command 线程执行 thread.start(); } } ","date":"2022-10-21","objectID":"/posts/programming-pattern/command-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 命令模式","uri":"/posts/programming-pattern/command-design-pattern.html"},{"categories":["折腾日志"],"content":"最近总是想做些小东西以打发自己的折腾之心，总是在想怎么将自己的代码知识引入到生活当中。通过 Github Action 实现定时推送天气预报就是一个简单的尝试，希望是一个好的开头。 偶然间，看到 GitHub Actions 教程：定时发送天气邮件 - 阮一峰的网络日志 这篇文章，没错，这个正好能打发自己的折腾之心，也能通过代码给生活引入一些变化。 还是在这里简单记录一下实现过程吧。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:0:0","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"第一步 获取天气预报出现问题 按照阮一峰的教程走，一开始使用了 wttr 的结果作为数据来源，也在 文档 上研究了很久，最终的结果总是不尽如人意。 最终展现到邮件上的结果如下： 从上面就可以看出一些问题： 展示到邮件中的是一个 HTML 页面，白色的背景使得结果展示不理想 默认返回的结果比较多，根据配置做调整之后返回的结果又比较少，结果不尽如人意 从页面上看返回的都是不太好理解的单位，不能让人一眼就能理解 …… 其实还有很多问题，最主要的原因还是其 API 的结果更符合国外的理解，而不适合我用。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:1:0","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"第二步 寻找新的数据来源 通过在网上寻找，最终找到了一个 墨迹天气 的 API 作为数据来源，虽然没有找到出处，但是暂时还可用。 其返回的结果是一个 JSON 对象，可根据自己的需求去组装。下面是返回的示例： { \"code\": 0, \"msg\": \"操作成功\", \"data\": { \"total\": 7, \"sourceName\": \"墨迹天气\", \"list\": [ { \"city\": \"广州\", \"lastUpdateTime\": \"2022-10-13 08:55:08\", \"date\": \"2022-10-13\", \"weather\": \"晴\", \"temp\": 20.0, \"humidity\": \"35%\", \"wind\": \"东北风3级\", \"pm25\": 29.0, \"pm10\": 43.0, \"low\": 20.0, \"high\": 30.0, \"airData\": \"43\", \"airQuality\": \"优\", \"dateLong\": 1665590400000, \"weatherType\": 0, \"windLevel\": 3, \"province\": \"广东\" }, { \"city\": \"广州\", \"lastUpdateTime\": \"2022-10-13 08:00:00\", \"date\": \"2022-10-14\", \"weather\": \"晴\", \"humidity\": \"未知\", \"wind\": \"微风\", \"pm25\": 0.0, \"low\": 21.0, \"high\": 30.0, \"airData\": \"80\", \"airQuality\": \"良\", \"dateLong\": 1665676800000, \"weatherType\": 0, \"windLevel\": 1, \"province\": \"广东\" }, { \"city\": \"广州\", \"lastUpdateTime\": \"2022-10-13 08:00:00\", \"date\": \"2022-10-15\", \"weather\": \"晴\", \"humidity\": \"未知\", \"wind\": \"北风\", \"pm25\": 0.0, \"low\": 21.0, \"high\": 31.0, \"airData\": \"80\", \"airQuality\": \"良\", \"dateLong\": 1665763200000, \"weatherType\": 0, \"windLevel\": 3, \"province\": \"广东\" }, { \"city\": \"广州\", \"lastUpdateTime\": \"2022-10-13 08:00:00\", \"date\": \"2022-10-16\", \"weather\": \"多云\", \"humidity\": \"未知\", \"wind\": \"北风\", \"pm25\": 0.0, \"low\": 22.0, \"high\": 32.0, \"airData\": \"70\", \"airQuality\": \"良\", \"dateLong\": 1665849600000, \"weatherType\": 1, \"windLevel\": 4, \"province\": \"广东\" } ], \"logoUrl\": \"http://iflycar.hfdn.openstorage.cn/xfypicture/dev/logo/moji.png\" } } 根据上述的返回结果，简单组装了一个自己想要的结果： 位置：广东-广州 今天：2022-10-11 当前：15.0°C 最低：15.0°C 最高：26.0°C 空气质量：优 湿度：29% 风向：东北风4级 PM2.5：17.0 位置：广西-桂林 今天：2022-10-11 当前：11.0°C 最低：11.0°C 最高：25.0°C 空气质量：优 湿度：30% 风向：北风5级 PM2.5：23.0 实际上是非常简陋的，但却也暂时够用了，后续有相关的需求再加内容上去。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:2:0","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"第三步 通过脚本简化 解决了数据来源和展示文本之后，其实已经是解决了需求端的问题，然后来到程序员的实现端。 现在，我们先将需求做拆解，落实到程序上应该有以下工作要做： 通过 API 获取到数据来源，组装成推送的文本格式 定时触发，可以通过 Github Action 白嫖 发送邮件，可以通过 QQ 邮箱白嫖 上述工作中的第一步，我最终是选择使用 Python 对其脚本化，代码如下： import sys import requests def generate_weather_text(weather: dict) -\u003e str: ret = [ f'位置：{weather.get(\"province\")}-{weather.get(\"city\")} 今天：{weather.get(\"date\")}', f'当前：{weather.get(\"temp\")}°C 最低：{weather.get(\"low\")}°C 最高：{weather.get(\"high\")}°C', f'空气质量：{weather.get(\"airQuality\")} 湿度：{weather.get(\"humidity\")}', f'风向：{weather.get(\"wind\")} PM2.5：{weather.get(\"pm25\")}', ] return '\\n'.join(ret) def get_weather(city: str) -\u003e dict: url = 'http://autodev.openspeech.cn/csp/api/v2.1/weather' params = { 'openId': 'aiuicus', 'clientType': 'android', 'sign': 'android', 'city': city, } res = requests.get(url, params=params).json() return res['data']['list'][0] def get_weather_text(city: str) -\u003e str: weather = get_weather(city) return generate_weather_text(weather) if __name__ == '__main__': if len(sys.argv) \u003e= 2: ret = [get_weather_text(_) for _ in sys.argv[1:]] print('\\n\\n'.join(ret)) else: print('请求参数错误') ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:3:0","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"第四步 配置 Github Action Github Action 的配置文件趋同于阮一峰的教程，下面是这个配置文件的一些解释。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:4:0","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"定时触发 name: \"天气预报\" on: push: schedule: # 需要减 8 个小时 - cron: \"0 23 * * *\" 这里比较好理解，name 是名称，on 是触发的时机，push 是我们提交代码到 Github 时触发，schedule 是定时触发，需要注意的时候，定时触发的时间需要减掉 8 个小时，其遵循国际标准时间而不是北京时间。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:4:1","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"运行流程 runs-on: ubuntu-latest steps: - name: \"切换代码\" uses: actions/checkout@v3 进入到 jobs 运行流程中，runs-on 指定运行环境是最新的 Ubuntu 即可，actions/checkout@v3 用作从代码仓库获取代码。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:4:2","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"获取时间 - name: \"获取时间\" run: echo \"WEATHER_REPORT_DATE=$(TZ=':Asia/Shanghai' date '+%Y-%m-%d %T')\" \u003e\u003e $GITHUB_ENV 直接通过 Linux 命令获取当前时间，然后转换成北京时间，这个时间主要是用于后续写入到邮件的标题当中。 在这里，通过 echo \"{environment_variable_name}={value}\" \u003e\u003e $GITHUB_ENV 的方式写入环境变量，在后续的步骤中都可以访问到这个环境变量。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:4:3","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"执行脚本 - uses: actions/setup-python@v4 with: python-version: \"3.10\" - run: pip install -r requirements.txt - name: \"获取天气结果\" run: 'echo \"$(python open_api/weather.py 广州 桂林)\" \u003e output.txt' 这里有两个步骤，一个是指定 Python 的运行环境并且安装好相关的依赖，第二个是执行 Python 的脚本获取结果。 在这里，为了方便将脚本的执行结果给到后续的步骤，选择将执行结果写入到一个文件当中。当然，选择怎样的方式主要看自己。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:4:4","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"发送邮件 - name: \"发送邮件\" uses: dawidd6/action-send-mail@v3 with: server_address: smtp.qq.com server_port: 465 username: ${{ secrets.SENDER_USER }} password: ${{ secrets.SENDER_PASSWORD }} subject: 天气预报 - ${{env.WEATHER_REPORT_DATE}} from: GitHub Actions to: fatedeity@qq.com body: file://output.txt 按照阮一峰的脚本，使用 Send email · Actions 发送邮件，和其不同的就是相关的配置。 当然，也可以通过将发送邮件直接写入到 Python 脚本当中，它们各有自己的优势。 使用 GIthub Action 发送邮件更易懂，只需要填写配置即可，也可以将脚本和发送邮件解耦。 使用 Python 发送邮件可以省下 Github Action 的步骤，直接通过脚本一步到位，耦合就比较高。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:4:5","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["折腾日志"],"content":"总结 通过这一次的尝试，使用 Github Action 实现了自动化及定时，也是为以后实现自己的自动化做铺垫。本篇文章的源码可以通过 GitHub - fatedeity/weather-action 访问。 生命在于折腾，看似无用的一次尝试，希望能给自己带来美好的未来。 ","date":"2022-10-20","objectID":"/posts/z-turn/github-action-weather-push.html:5:0","tags":["Github","Python"],"title":"通过 Github Action 实现定时推送天气预报","uri":"/posts/z-turn/github-action-weather-push.html"},{"categories":["程序设计"],"content":"策略模式是一种非常容易理解的设计模式，其最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。 ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"简介 策略设计模式（Strategy Design Pattern）实际上起到一个解耦的作用，解耦了策略的定义、创建、使用三部分。 其概念是，定义一系列算法类，将每一个算法封装起来，并让它们可以互相替换。 从代码的层面上理解就是，将面向过程编程中的分支（如 if-else 或 switch 分支）代码，转换成面向对象的算法类，通过构建这些类的关系以实现不同分支的选择，实现运行时选择策略。 ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 在这里，使用一个加、减、乘的案例来展示策略模式的应用。 首先，对加、减、乘运算抽象出一个公共的方法，定义一个 Strategy 策略接口，其代码示例如下： public interface Strategy { // 加、减、乘、除都是对两个数进行处理 int doOperation(int num1, int num2); } 对于加法，实现 Strategy 策略接口，定义一个 OperationAdd 策略类，其代码示例如下： public class OperationAdd implements Strategy { @Override public int doOperation(int num1, int num2) { return num1 + num2; } } 对于减法，实现 Strategy 策略接口，定义一个 OperationSubtract 策略类，其代码示例如下： public class OperationSubtract implements Strategy { @Override public int doOperation(int num1, int num2) { return num1 - num2; } } 对于乘法，实现 Strategy 策略接口，定义一个 OperationMultiply 策略类，其代码示例如下： public class OperationMultiply implements Strategy { @Override public int doOperation(int num1, int num2) { return num1 * num2; } } 通常，会定义一个 Context 类用于汇总策略类，以方便客户端使用，其代码示例如下： public class Context { private final Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public int executeStrategy(int num1, int num2) { return strategy.doOperation(num1, num2); } } 对于客户端而言，需要理解 Context 类如何使用，以及知道所有的策略类，通过注入不同的 Strategy 对象以达到选择不同策略的效果。 如下是客户端使用策略模式的代码示例： public class StrategyDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); // 10 + 5 = 15 System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationSubtract()); // 10 - 5 = 5 System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); // 10 * 5 = 50 System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5)); } } ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"优点 策略模式的主要优点如下： 使用策略模式可以避免使用多重条件语句，如 if-else 或 switch 语句 策略模式提供了管理相关算法族的办法，如恰当地使用继承把算法族的公共代码转移到父类中 策略模式提供了相同行为的不同实现，客户端可以根据不同的需求使用不同的策略 可以在不更改原代码的模式下，灵活增加新的算法，符合开闭原则 策略模式把算法的使用放到环境类中，把实现放到具体策略类中，把定义放到客户端中，实现了三者的解耦 ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 策略模式的主要缺点如下： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类 策略模式造成很多策略类，增加了维护难度 ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 策略模式的适用场景如下： 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中 对于多重条件语句，使用策略模式将这些行为转移到相应的具体策略类中，以替代这些条件语句 系统要求使用算法的客户端不应该知道其操作的数据时，可以使用策略模式来封装算法及其数据结构 ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，Comparator 接口就是一个策略模式的应用。 实际使用时，Comparator 就是策略接口，使用匿名内部类来实现具体策略类。如下是使用的示例代码： import java.util.Arrays; import java.util.Comparator; public class ComparatorDemo { public static void main(String[] args) { String[] names = {\"张三\", \"李四\", \"小明\"}; Comparator\u003cString\u003e comparator = new Comparator\u003c\u003e() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }; Arrays.sort(names, comparator); // [小明, 张三, 李四] System.out.println(Arrays.toString(names)); } } ","date":"2022-10-19","objectID":"/posts/programming-pattern/strategy-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 策略模式","uri":"/posts/programming-pattern/strategy-design-pattern.html"},{"categories":["程序设计"],"content":"观察者模式是使用频率最高的设计模式之一，用于建立对象与对象之间的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"简介 观察者设计模式（Observer Design Pattern）的别名有很多，如发布 - 订阅（Publish/Subscribe）模式、模型 - 视图（Model/View）模式、源 - 监听（Source/Listener）模式或从属者（Dependents）模式。 无论是何种名称，其意图都是在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。 其主要解决了一个对象状态改变之后给其他对象通知的问题，而且考虑到易用性和低耦合，保证高度的协作性。 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 在发布 - 订阅模式当中，观察者就是订阅者，一般是需要定义一个抽象的观察者接口，其代码示例如下： public interface Observer { void update(); } 具体的观察者类也很简单，只需要简单实现接口即可，其代码示例如下： public class ConcreteObserver implements Observer { // 实现响应方法 public void update() { // 具体响应代码 } } 定义完订阅者，其次就是发布者，通常是将之定义为一个抽象的目标类，其代码示例如下： public abstract class Subject { // 定义一个观察者集合存储所有观察者对象 protected List\u003cObserver\u003e observers = new ArrayList\u003c\u003e(); // 注册方法，用于向观察者集合增加一个观察者 public void attach(Observer observer) { observers.add(observer); } // 注销方法，用于向观察者集合删除一个观察者 public void detach(Observer observer) { observers.remove(observer); } // 声明抽象的通知方法，需要由子类具体实现 abstract void notifyObservers(); } 根据不同的场景定义不一样的具体目标类，如下是一种代码示例： public class ConcreteSubject extends Subject { // 实现具体的通知方法 @Override public void notifyObservers() { // 遍历观察者集合，调用每一个观察者的响应方法 for (Observer ob : observers) { ob.update(); } } } ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"优点 观察者模式的主要优点如下： 观察者模式可以实现表示层和数据逻辑层的分离 观察者模式在观察目标和观察者之间建立了一个抽象的耦合 观察者模式支持广播通信，简化了一对多系统设计的难度 增加新的具体观察者无需修改原有代码，符合开闭原则 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 观察者模式的主要缺点如下： 如果目标对象的观察者有很多，将所有的观察者都通知到会非常耗时 如果目标对象和观察者存在循环依赖，观察目标会触发它们之间进行循环调用，最终导致系统崩溃 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 观察者模式的适用场景如下： 将具有依赖关系的两种抽象模型独立出来，使它们可以独立地改变和复用 一个对象的改变将导致一个或多个其他对象也发生改变，但并不知道具体有多少对象将发生改变，也不知道这些对象是谁 可以使用观察者模式创建一种链式触发机制 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 的 java.util 包中，提供了 Observer 接口和 Observable 类，它们构成了 JDK 对观察者模式的支持。 如下是 Observer 接口的源码： @Deprecated(since = \"9\") public interface Observer { void update(Observable o, Object arg); } 如下是 Observable 类的部分源码： @Deprecated(since = \"9\") public class Observable { private boolean changed = false; private Vector\u003cObserver\u003e obs; public Observable() { obs = new Vector\u003c\u003e(); } // 注册观察者，线程安全 public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); // 注册时去重 if (!obs.contains(o)) { obs.addElement(o); } } // 注销观察者，线程安全 public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } // 通知观察者，无参数模式 public void notifyObservers() { notifyObservers(null); } // 通知观察者，带参数模式 public void notifyObservers(Object arg) { // 保存观察者的状态，备忘录模式的简单应用 Object[] arrLocal; // 获取观察者时候锁住 synchronized (this) { if (!changed) return; arrLocal = obs.toArray(); clearChanged(); } // 逐一调用观察者的处理方法 for (int i = arrLocal.length - 1; i \u003e= 0; i--) ((Observer) arrLocal[i]).update(this, arg); } public synchronized void deleteObservers() { obs.removeAllElements(); } protected synchronized void setChanged() { changed = true; } protected synchronized void clearChanged() { changed = false; } public synchronized boolean hasChanged() { return changed; } public synchronized int countObservers() { return obs.size(); } } 需要注意的是，在 JDK 9 之后已经不推荐使用 Observer 接口和 Observable 类。 ","date":"2022-10-17","objectID":"/posts/programming-pattern/observer-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 观察者模式","uri":"/posts/programming-pattern/observer-design-pattern.html"},{"categories":["程序设计"],"content":"顾名思义，迭代器就是用于迭代操作的对象，其能够像有序序列一样迭代获取集合中对象，并且能够记录下当前所在位置，因此也称游标。 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"简介 迭代器设计模式（Iterator Design Pattern），也叫作游标设计模式（Cursor Design Pattern）。 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。 其定义是，提供一种方法来访问聚合对象，而不暴露这个对象的内部实现。 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"典型实现 首先，定义一个用于遍历聚合对象中所存储元素的抽象迭代器接口，其代码示例如下： public interface Iterator { // 将游标指向第一个元素 public void first(); // 将游标指向下一个元素 public void next(); // 判断是否存在下一个元素 public boolean hasNext(); // 获取游标指向的当前元素 public Object currentItem(); } 然后，我们通常将存储数据的类称作为聚合类，一般会在聚合类中创建迭代器对象，如下是抽象聚合接口的代码示例： public interface Aggregate { public Iterator creteIterator(); } 在具体迭代器类中，我们需要注入聚合对象，以便后续使用迭代器时能访问到其数据，其代码示例如下： public class ConcreteIterator implements Iterator { private Aggregate objects; private Object cursor; public ConcreteIterator(Aggregate objects) { this.objects = objects; } // 将游标指向第一个元素 public void first() {} // 将游标指向下一个元素 public void next() {} // 判断是否存在下一个元素 public boolean hasNext() {} // 获取游标指向的当前元素 public Object currentItem() {} } 在具体聚合类中，通常是实现存储数据的逻辑，以及指定具体迭代器的对象，其代码示例如下： public class ConcreteAggregate implements Aggregate { public Iterator creteIterator() { return new ConcreteIterator(this); } } ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"优点 迭代器模式的主要优点如下： 封装性良好，访问一个聚合对象的内容而无需暴露它的内部实现 将遍历操作交给迭代器，简化了复杂聚合类的设计 支持以不同的方式遍历聚合对象，在同一个聚合对象上可以定义多种遍历方式 增加新的聚合类和迭代器类都很方便，满足开闭原则 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 迭代器模式的主要缺点如下： 迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加 抽象迭代器的设计难度较大，需要充分考虑系统将来的扩展 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 迭代器模式的适用场景如下： 访问一个聚合对象的内容而无需暴露它的内部实现 需要为一个聚合对象提供多种遍历方式 为遍历不同的聚合对象提供一个统一的接口 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 Java 中，迭代器的应用非常广。 最顶层的 Collection 集合接口继承了 Iterable 接口，其实表明了所有的集合对象都是可迭代对象，并且都需要实现获取 Iterator 对象的方法。 将这个源码映射到典型实现中，Iterable 接口和 Collection 接口就是抽象聚合接口，Iterator 接口则是抽象迭代器接口。 ","date":"2022-10-14","objectID":"/posts/programming-pattern/iterator-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 迭代器模式","uri":"/posts/programming-pattern/iterator-design-pattern.html"},{"categories":["程序设计"],"content":"享元设计模式（Flyweight Design Pattern）通过共享技术实现相同或相似对象的重用，节省内存，前提是享元对象是不可变对象。 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"简介 古代的活字印刷术就有点像享元模式，活字印刷就是将每个字模做出来，再印刷时再选取需要的字模到印刷板上，这样就构成了一页书的印刷板。这样的活字印刷大大提升了效率，减少了印刷板的空间。 在享元模式中，存储共享实例对象的地方称为享元池（Flyweight Pool）。类比到上述的活字印刷术中，放置字模的地方就是享元池。 享元模式能做到共享的关键是区分了内部状态和外部状态，它们的简单释义是： 内部状态：存储在享元对象内部且不跟随环境变化而改变的状态，内部状态可以在对象之间共享 外部状态：通常由客户端保存，当需要时再传入享元对象中的状态，会跟随环境变化而改变，不可以在对象之间共享。 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"典型示例 一个典型的享元工厂类的代码示例如下： public class FlyweightFactory { // 使用 HashMap 定义享元池 private final HashMap\u003cString, Flyweight\u003e flyweights = new HashMap\u003c\u003e(); public Flyweight getFlyweight(String key) { // 如果对象存在，直接从享元池中获取 if (flyweights.containsKey(key)) { return (Flyweight) flyweights.get(key); } else { // 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回 Flyweight fw = new ConcreteFlyweight(); flyweights.put(key, fw); return fw; } } } 一个典型的享元抽象类的代码示例如下： public abstract class Flyweight { // 内部状态作为成员对象，同一个享元对象其内部状态是一致的 protected Object intrinsicState; public Flyweight(Object intrinsicState) { this.intrinsicState = intrinsicState; } public void operation(Object extrinsicState) { // 外部状态在使用时由外部提供，每一次都可以不同 } } 通常，实际会根据业务情况定义具体享元类，代码示例如下： public class ConcreteFlyweight extends Flyweight { public ConcreteFlyweight(Object intrinsicState) { super(intrinsicState); } @Override public void operation(Object extrinsicState) { // 结合内部状态 intrinsicState 以及方法参数传入的 extrinsicState 完成具体逻辑 } } ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"优点 享元模式的主要优点如下： 极大地减少内存中对象的数量，节约了系统资源，提高了系统性能 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 享元模式的主要缺点如下： 享元模式需要分离出内部状态和外部状态，从而使得系统变得复杂，这使得程序的逻辑复杂化 为了使对象可以共享，享元对象需要将部分状态外部化，而读取外部状态将使得运行时间变长 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 享元模式的适用场景如下： 一个系统有大量相同或相似的对象，造成内存大量耗费 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 Java 类库中的 String 类就使用了享元模式，使用字面量创建的对象是共享的，而不会重新为此分配内存空间。 ","date":"2022-10-12","objectID":"/posts/programming-pattern/flyweight-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 享元模式","uri":"/posts/programming-pattern/flyweight-design-pattern.html"},{"categories":["程序设计"],"content":"组合设计模式（Composite Design Pattern）其应用场景非常特殊，主要用于处理树形结构数据，它可以让叶子对象和容器对象的使用具有一致性。 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"简介 组合模式就是组合多个对象形成树形结构以表示具有“部分 - 整体”关系的层次结构。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。 组合模式的关键是定义一个抽象构件类，它既可以代表叶子，也可以代表容器。客户端针对该抽象构件进行编程，无需知道它到底表示的是叶子还是容器，可以对其进行统一处理。 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 对于组合模式的抽象构件角色，其代码示例如下： public abstract class Component { // 增加成员 public abstract void add(Component c); // 删除成员 public abstract void remove(Component c); // 获取成员 public abstract Component getChild(int i); // 业务方法 public abstract void operation(); } 如果继承抽象构件类的是叶子构件，其代码示例如下： public class Leaf extends Component { @Override public void add(Component c) { // 增加成员 // 异常处理或业务提示 } @Override public void remove(Component c) { // 删除成员 // 异常处理或业务提示 } @Override public Component getChild(int i) { // 获取成员 // 异常处理或业务提示 } @Override public void operation() { // 业务方法 // 叶子构件具体业务方法的实现 } } 如果继承抽象构件类的是容器构件，其代码示例如下： import java.util.ArrayList; public class Composite extends Component { private final ArrayList\u003cComponent\u003e list = new ArrayList\u003c\u003e(); @Override public void add(Component c) { // 增加成员 list.add(c); } @Override public void remove(Component c) { // 删除成员 list.remove(c); } @Override public Component getChild(int i) { // 获取成员 return (Component) list.get(i); } @Override public void operation() { // 业务方法 // 叶子构件具体业务方法的实现 // 递归调用成员构件的业务方法 for (Component obj : list) { obj.operation(); } } } ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"分类 在使用组合模式时，根据抽象构件类的定义形式，可以将组合模式分为透明组合模式和安全组合模式两种。 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"透明组合模式 在透明组合模式中，抽象构件类声明了所有用于管理成员的方法，如 add()、remove()、getChild() 等所有方法。 透明组合模式也是组合模式的标准形式，这样做的好处是确保所有的构件类都使用相同的接口。 其缺点就是不够安全，因为叶子对象和容器对象有本质上的区别，对叶子对象提供 add()、remove()、getChild() 等方法是没有意义的，如果没有提供相应的错误处理代码，在运行阶段有可能会出错。 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"安全组合模式 在安全组合模式中，抽象构件类没有声明任何管理成员的方法，只声明抽象的业务方法。 这样的做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。 相对的，其缺点就是不够透明，因为叶子构件和容器构件具有不同的方法，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"优点 组合模式的主要优点如下： 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案 在组合模式中增加新的叶子构件和容器构件都很方便，符合开闭原则 客户端可以一致地使用一个组合结构或其中单个对象，简化了客户端代码 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 组合模式的主要缺点如下： 设计较复杂，客户端需要花费更多时间理清类之间的层次关系 在增加新构件时很难对容器中的构件类型进行限制，通常通过运行时进行类型检查来实现 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 组合模式的适用场景如下： 在具有整体和部分的层次结构中，希望通过一种方式忽略整体和部分的差异 在一个使用面向对象语言开发的系统中需要处理一个树形结构 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，HashMap 也是用到了组合模式，如下是部分代码： public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable { public void putAll(Map\u003c? extends K, ? extends V\u003e m) { putMapEntries(m, true); } final void putMapEntries(Map\u003c? extends K, ? extends V\u003e m, boolean evict) { int s = m.size(); if (s \u003e 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft \u003c (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t \u003e threshold) threshold = tableSizeFor(t); } else { // Because of linked-list bucket constraints, we cannot // expand all at once, but can reduce total resize // effort by repeated doubling now vs later while (s \u003e threshold \u0026\u0026 table.length \u003c MAXIMUM_CAPACITY) resize(); } for (Map.Entry\u003c? extends K, ? extends V\u003e e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } } putAll() 和 putMapEntries() 都接受一个 Map 结构参数，这个 Map 就是一个抽象构件，HashMap 同样是实现了 Map 结构，轻易实现一个树形的调用结构。 ","date":"2022-10-11","objectID":"/posts/programming-pattern/composite-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 组合模式","uri":"/posts/programming-pattern/composite-design-pattern.html"},{"categories":["程序设计"],"content":"外观模式是最常用的结构型设计模式，也是一种非常容易理解的设计模式，其核心就是为多个子系统提供一个统一的接口，将这个接口看作是这些子系统的门面。 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"简介 外观设计模式（Facade Design Pattern）又被叫作门面模式，其描述是，通过为多个复杂的子系统提供统一的接口，使得子系统更容易被使用。 在现实生活中，常常存在办事复杂的情况，如办理房产证或者注册公司，有时需要跑几个部门才能办成，如果这些部门都在一个地方，或者是成立一个综合部门就方便很多。 对于上述例子，成立综合部分就相当于使用外观模式，为客户端提供统一的接口，从而降低的系统的耦合度、降低客户端的使用难度。 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 创建一个抽象的图形接口，定义一个画图的行为： public interface Shape { void draw(); } 实现一个画圆形的具体类： public class Circle implements Shape { @Override public void draw() { System.out.println(\"在这里画圆形！\"); } } 定义一个画正方形的具体类： public class Square implements Shape { @Override public void draw() { System.out.println(\"在这里画正方形！\"); } } 随着具体类越来越多，客户端调用这些类也变得更多，则耦合度变得越来越高。这时就可以通过外观模式将这些具体类汇总到同一个接口中，客户端只需掌握这个外观类即可。 定义一个图形类的外观类，将具体类都注入到其中： public class ShapeFacade { private final Shape circle = new Circle(); private final Shape square = new Square(); public void drawCircle() { circle.draw(); } public void drawSquare() { square.draw(); } } ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"优点 外观模式的主要优点如下： 降低了子系统与客户端的耦合度，使得子系统的变化不会影响调用它的客户端 对客户端屏蔽了子系统组件，减少了客户处理的对象数目，使得子系统使用起来更加简便 只是提供了一个访问子系统的统一入口，并不影响客户端直接使用子系统类 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 外观模式的主要缺点如下： 不能很好地限制客户端使用子系统类，很容易带来未知风险 增加新的子系统类可能需要修改外观类或者客户端的代码，违背了开闭原则 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 外观模式的适用场景如下： 解决易用性问题，当需要访问一系列复杂的子系统时，外观模式可以为客户端提供简单的入口 解决性能问题，调用多个接口改成调用一个统一接口，可以减少网络通信成本 解决分布式事务问题，对于不同模块还需要保持事务性，则可以设计一个包括两个操作的新接口在同一个事务里执行 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"源码 外观模式是一种使用频率非常高的设计模式，如 JDK 中的 java.util.logging.LogManager 简单地使用了外观模式，其中统一了 SystemLoggerContext 和 LoggerContext 这两个内部类。 ","date":"2022-10-09","objectID":"/posts/programming-pattern/facade-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 外观模式","uri":"/posts/programming-pattern/facade-design-pattern.html"},{"categories":["程序设计"],"content":"适配器设计模式（Adapter Design Pattern）可以将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"简介 适配器在生活中经常见到，如手机、笔记本电脑的电源适配器，USB 转接头都是常见的适配器。 在设计模式当中，适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 在类适配器模式中，适配器与适配者之间是继承（实现）关系；在对象适配器模式中，适配器与适配者之间是关联关系。 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"类适配器模式 典型的类适配器模式代码示例如下： class Adapter extends Adaptee implements Target { public void request() { // 转发调用 super.specificRequest(); } } 从上述的代码可以看出，典型的类适配器模式就是通过继承的方式，使用子类方法调用父类的方法，使用者在使用时面对的是适配器类而不是原始类。 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:2:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"对象适配器模式 典型的对象适配器模式代码示例如下： class Adapter extends Target { // 维持一个对适配者的引用 private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { // 转发调用 adaptee.specificRequest(); } } ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:2:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"代理、桥接、装饰器、适配器的区别 笼统地说，这 4 种设计模式可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。 尽管它们的代码结构类似，但这 4 种设计模式的用意完全不同，以下是它们简要描述： 代理模式：代理类在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它与装饰器模式最大的不同 桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变 装饰器模式：装饰器模式在不改变原始类接口的情况下，对原始类功能进行加强，并且支持多个装饰器的嵌套使用 适配器模式：适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口，适配器模式是一种事后的补救策略 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"优点 适配器模式的主要优点如下： 将目标类和适配者类解耦 增加了类的透明性和复用性 灵活性和扩展性都非常好 除上述以外，对象适配器模式还有以下优点： 一个对象适配器可以把多个不同的适配器适配到同一个目标 可以适配一个适配者的子类 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 类适配器模式的主要缺点如下： 对于不支持多重继承的编程语言，一次最多只能适配一个适配者类，不能同时适配多个适配者 适配者类必须是可被继承的 对于不支持多重继承的编程语言，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性 对象适配器模式的主要缺点如下： 与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 适配器模式的适用场景如下： 封装有缺陷的接口设计 统一多个类的接口设计 替换依赖的接口设计 兼容老版本接口 适配不同格式的数据 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 Java 中，SLF4J 日志框架不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 SLF4J 接口定义。 ","date":"2022-09-30","objectID":"/posts/programming-pattern/adapter-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 适配器模式","uri":"/posts/programming-pattern/adapter-design-pattern.html"},{"categories":["程序设计"],"content":"装饰器模式（Decorator Design Pattern）是一种结构型设计模式，通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。简单地说，就是允许向一个现有的功能添加新的功能，同时又不改变其结构。 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"简介 装饰器模式主要解决的问题是，如果使用子类继承的方式扩展一个类，随着扩展功能的增多，子类会非常膨胀，包括子类的数量或子类的方法数。 装饰器模式其核心还是“用组合替代继承”，但是相对于普通的组合关系，装饰器模式还有两个比较特殊的地方： 装饰器类和原始类继承同样的父类，这样就可以对原始类“嵌套”多个装饰器类 装饰器类是对功能的加强，这也是装饰器模式应用场景的一个重要特点 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 以图书馆的图书和借阅者为例，在已定义了实体类的基础上，增加借书计数的功能。 定义图书馆的抽象类： public abstract class Library { // 借书 public abstract void borrowBook(); // 还书 public abstract void returnBook(); } 定义具体图书馆类继承抽象图书馆类： public class ConcreteLibrary extends Library { @Override public void borrowBook() { // 实现类借书 System.out.println(\"ConcreteLibrary borrowBook\"); } @Override public void returnBook() { // 实现类还书 System.out.println(\"ConcreteLibrary returnBook\"); } } 定义抽象装饰器类继承抽象图书馆类： public abstract class LibraryDecorator extends Library { protected Library library; public LibraryDecorator(Library library) { this.library = library; } @Override public void borrowBook() { this.library.borrowBook(); } @Override public void returnBook() { this.library.returnBook(); } } 再定义具体的装饰器类继承抽象装饰器类： public class CountingLibrary extends LibraryDecorator { private int counter = 0; public CountingLibrary(Library library) { super(library); } @Override public void borrowBook() { this.library.borrowBook(); this.counter++; this.printCounter(); } @Override public void returnBook() { this.library.returnBook(); this.counter--; this.printCounter(); } private void printCounter() { System.out.println(\"当前的计数是：\" + this.counter); } } ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"具体分类 在实际使用过程中，为了可以单独调用装饰器类新增的方法，定义这种形式的装饰器模式称为半透明装饰器模式；而标准的装饰器模式是透明装饰器模式。 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"透明装饰器模式 在透明装饰器模式中，要求客户端完全针对抽象编程，并且可以在具体的装饰器类中将新增行为都定义为私有方法。 如下是推荐的代码示例： // 使用抽象类型定义对象 Component component = new ConcreteComponent(); 如下是不推荐的代码示例： // 使用具体类型定义对象 ConcreteComponent component = new ConcreteComponent(); 透明装饰器模式可以让客户端透明地使用装饰器之前的对象和装饰之后的对象，无需关心它们的区别，使用上没有任何差别。因为，对于我们而言，面向的总是最顶层的抽象类。 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"半透明装饰器模式 为了能够调用到新增方法，不得不用具体装饰器类型来定义装饰之后的对象，而被装饰的对象还是可以使用抽象类来定义。 其实，也就是因为使用到具体装饰器新增的方法，无法确定这个方法是否在其他同类装饰器上也存在，因此，也就无法嵌套使用装饰器了。 如下是半透明装饰器模式的代码示例： // 无论是使用具体类型定义对象 ConcreteComponent component = new ConcreteComponent(); // 或者是使用抽象类型定义对象 Component component = new ConcreteComponent(); // 使用具体装饰器类型定义 ConcreteDecorator decorator = new ConcreteDecorator(component); // 再调用具体装饰器自定义的方法 decorator.otherMethod(); 半透明装饰器模式更加灵活，设计相对简单，使用起来也很方便。 但是其最大的缺点是不能实现对同一个对象的多次装饰，而且客户端需要有区别地地对待装饰之前的对象和装饰之后的对象。 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"优点 装饰器模式的主要优点如下： 对于扩展一个对象的功能，装饰器模式比继承更加灵活，不会导致类的个数急剧增加 可以通过一种动态的方式来扩展一个对象的功能 可以对一个对象进行多次装饰 具体类和具体装饰器类可以独立变化，用户可以根据需要增加新的具体类和具体装饰器类，符合开闭原则 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 装饰器模式的主要缺点如下： 使用装饰器模式进行系统设计时将产生很多小对象，如 Java 的 IO 类库 装饰器模式比继承更加灵活，但是也比继承更加容易出错，排错也很困难 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 装饰器模式的适用场景如下： 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责 类已经被定义为不可被继承，但是又需要对类进行扩展的情况 系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，提供的 IO 类库使用了装饰器模式。 ","date":"2022-09-29","objectID":"/posts/programming-pattern/decorator-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 装饰器模式","uri":"/posts/programming-pattern/decorator-design-pattern.html"},{"categories":["程序设计"],"content":"桥接模式是一种在日常开发中不是特别常用的设计模式，主要是因为上手难度较大，但是对于理解面向对象设计有非常大的帮助。 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"简介 桥接设计模式（Bridge Design Pattern）也叫作桥梁模式，其描述是将实现和抽象放在两个不同的类层次中，使两个层次可以独立地变化。 桥接模式采用抽象关联取代了传统的多层继承，将类之间的静态继承关系转化为动态的对象组合关系，使系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。 在桥接模式中，有以下概念需要理解： 抽象化：将对象共同的性质抽取出去而形成类的过程 实现化：和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化 脱耦：将抽象化和实现化之间强关联改换成弱关联，将两个角色之间的继承关系改为关联关系 桥接模式主要解决的是多维度的指数级变化。 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 以手机为例，手机既可以按照品牌分类，也可以按照手机软件来分类，两种维度交叉的变化远必一种维度多得多。 手机软件代码示例如下： // 抽象类 public abstract class HandsetSoft { public abstract void run(); } // 实现类 public class HandsetGame extends HandsetSoft { @Override public void run() { System.out.println(\"运行手机游戏\"); } } public class HandsetAddressList extends HandsetSoft { @Override public void run() { System.out.println(\"运行手机通讯录\"); } } 手机品牌代码示例如下： // 抽象类 public abstract class HandsetBrand { protected HandsetSoft soft; // 设置手机软件 public void setHandsetSoft(HandsetSoft soft) { this.soft = soft; } // 运行 public abstract void run(); } // 实现类 public class HandsetBrandA extends HandsetBrand { @Override public void run() { soft.run(); } } public class HandsetBrandB extends HandsetBrand { @Override public void run() { soft.run(); } } 客户端代码示例如下： public class Client { public static void main(String[] args) { HandsetBrand ab; // A 品牌 ab = new HandsetBrandA(); ab.setHandsetSoft(new HandsetGame()); ab.run(); ab.setHandsetSoft(new HandsetAddressList()); ab.run(); // B 品牌 ab = new HandsetBrandB(); ab.setHandsetSoft(new HandsetGame()); ab.run(); ab.setHandsetSoft(new HandsetAddressList()); ab.run(); } } ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"优点 桥接模式的主要优点如下： 实现了抽象和实现部分的分离，从而极大地提高了系统的灵活性 使用桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本 桥接模式提高了系统的可扩展性，在两个维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 桥接模式的主要缺点如下： 增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 桥接模式的适用场景如下： 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用 一个类存在两个或多个独立变化的维度，且这两个或多个维度都需要独立进行扩展 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"源码 桥接模式是设计 Java 虚拟机和实现 JDBC 等驱动程序的核心模式之一，应用较为广泛。 ","date":"2022-09-27","objectID":"/posts/programming-pattern/bridge-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 桥接模式","uri":"/posts/programming-pattern/bridge-design-pattern.html"},{"categories":["程序设计"],"content":"代理设计模式（Proxy Design Pattern）指的是，在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能，即扩展目标对象的功能。 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"简介 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"概念 举个简单的例说明代理模式就是：假如现在需要买一辆二手车，可以自己去找车源、做质量检测等一系列车辆过户的流程，但是这实在太浪费时间和精力了，其实可以通过找中介的方式，同样会找车源、做质量检测等一系列车辆过户的流程，但是这样自己就只需要选车、付钱即可。 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:1:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"分类 在实际开发中，代理模式根据其目的和实现方式的不同可分为很多种类，如下是常用的几种代理模式： 远程代理：为一个位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中 虚拟代理：如果需要创建一个资源消耗较大的对象，可以先创建一个消耗相对较小的对象来表示，真实对象只有需要时才会被真正创建 保护代理：控制对一个对象的访问，可以给不同用户提供不同级别的使用权限 缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 智能引用代理：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:1:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"功能分类 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"远程代理 远程代理是一种常见的代理模式，远程代理对象承担了大部分的网络通信工作，使得客户端程序可以访问在远程主机上的对象。 对于客户端而言，无需关心实现具体业务的是谁，只需要按照服务接口所定义的方法直接与本地主机中的代理对象交互即可。 在 Java 语言中，可以通过 RMI(Remote Method Invocation, 远程方法调用) 机制来实现远程代理。代码示例如下： 服务端部分代理 import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; // 远程接口 public interface IMyRemote extends Remote { String SayHello() throws RemoteException; } // 远程接口实现 - 远程对象 public class MyRemoteImpl extends UnicastRemoteObject implements IMyRemote { public MyRemoteImpl() throws RemoteException { super(); } @Override public String SayHello() throws RemoteException { return \"Server says, 'Hey'\"; } public static void main(String[] args) throws RemoteException, MalformedURLException { IMyRemote service = new MyRemoteImpl(); // 启动本地 RMI 服务，默认端口是 1099 LocateRegistry.createRegistry(1099); // 注册远程对象 Naming.rebind(\"rmi://localhost:1099/RemoteHello\", service); } } 客户端部分代理 import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; public class MyRemoteClient { private void go() throws RemoteException, NotBoundException, MalformedURLException { IMyRemote service = (IMyRemote) Naming.lookup(\"rmi://localhost:1099/RemoteHello\"); System.out.println(service.sayHello()); } public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException { new MyRemoteClients().go(); } } ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:2:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"虚拟代理 虚拟代理会在真实对象创建成功之前扮演其替身，而当真实对象创建成功之后，虚拟代理再将用户的请求转发给真实对象。 使用虚拟代理的场景非常容易理解，主要有以下两种： 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象，通常在实现时结合多线程使用 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:2:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 代理模式的具体实现从运行时的角度可以分成两种：一种是静态代理，即在代码运行之前就已经确定好代理关系；另一种是动态代理，可以在代码运行时才决定如何实现代理关系。 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"静态代理 静态代理是比较好理解的实现方式，在这种实现方式中，代理类所实现的接口和所代理的方法都被固定，需要在编译期就预先对原始类编写代理类。 基于接口 一般情况下，参考基于接口而非实现编程的设计思想，为了让代码的改动尽量少，代理类和原始类应该实现同样的接口。 如下是使用图片展示作为例子的代码示例： 图片 Image 接口：描述图片具有的行为 public interface Image { void display(); } 展示图片 ShowImage 类：实际的图片原始类 public class ShowImage implements Image { public ShowImage() {} @Override public void display() { System.out.println(\"ShowImage display!\"); } } 代理图片 ProxyImage 类：在真实图片前包装一层的代理类 public class ProxyImage implements Image { // 通过依赖注入的方式 private ShowImage showImage; public ProxyImage(ShowImage showImage) { this.showImage = showImage; } @Override public void display() { System.out.println(\"ProxyImage display start!\"); this.showImage.display(); System.out.println(\"ProxyImage display end!\"); } } 基于继承 如果原始类并没有实现接口，并且原始类代码由其他人开发维护，可以通过代理类继承原始类的方法来实现代理模式。 假设上述展示图片 ShowImage 类没有实现接口，可以重新定义代理图片 ProxyImage 类如下： public class ProxyImage extends ShowImage { public ProxyImage() {} @Override public void display() { System.out.println(\"ProxyImage display start!\"); super.display(); System.out.println(\"ProxyImage display end!\"); } } ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"动态代理 静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了开发成本和维护成本。 对于静态代理存在的问题，可以通过动态代理来解决。 动态代理的原理是：不事先为每个原始类编写代理类，而是在代码运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。 在 Java 中，主要就是利用反射机制在运行时创建代理类。代码示例如下： // 定义接口，描述行为 public interface Subject { void hello(String param); } // 实现接口 public class SubjectImpl implements Subject { public SubjectImpl() {} @Override public void hello(String param) { System.out.println(\"hello \" + param); } } // 创建代理类 public class SubjectProxy implements InvocationHandler { private Subject subject; public SubjectProxy(Subject subject) { this.subject = subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"----- Start -----\"); Object invoke = method.invoke(subject, args); System.out.println(\"----- End -----\"); return invoke; } } // 实际调用 public class Main { public static void main(String[] args) { Subject subject = new SubjectImpl(); InvocationHandler subjectProxy = new SubjectProxy(subject); // 代理类的类加载器 // 被代理类的接口，如果有多个就是以数组形式传入 // 代理类实例 Subject proxyInstance = (Subject) Proxy.newProxyInstance( subjectProxy.getClass().getClassLoader(), subject.getClass().getInterfaces(), subjectProxy ); // 执行代理方法 proxyInstance.hello(\"world\"); } } 常见的 Java 动态代理实现方式有 JDK 代理、CGLib 代理。基于 JDK 的动态代理必须实现一个接口，而 CGLib 动态代理没有这个限制，是另一种不错的选择。 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"优点 代理模式的主要优点如下： 协调调用者和被调用者，在一定程度上降低了系统的耦合，满足迪米特原则 客户端可以针对抽象主题角色进行编程，增加和更换代理类无需修改源代码，符合开闭原则 公共的事务由代理来完成，使得真实处理的业务更加纯粹，不再去关注公共业务，而公共业务发生扩展时也变得更加集中和方便 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 代理模式的主要缺点如下： 在客户端和真实主题之间增加代理对象，有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的成本，有些代理模式的实现非常复杂 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 代理模式的适用场景如下： 当客户端对象需要访问远程主机中的对象时，可以使用远程代理 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象时，可以使用虚拟代理 当需要控制一个对象的访问，为不同用户提供不同级别的的访问权限时，可以使用保护代理 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时，可以使用缓冲代理 当需要为一个对象的访问（引用）提供一些额外的操作时，可以使用智能引用代理 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，提供了 java.lang.reflect.Proxy 支持创建动态代理类。 ","date":"2022-09-26","objectID":"/posts/programming-pattern/proxy-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 代理模式","uri":"/posts/programming-pattern/proxy-design-pattern.html"},{"categories":["程序设计"],"content":"原型模式是创建型模式的一种，其特点在于通过 复制 一个已经存在的实例来返回新的实例,而不是新建实例。 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"简介 对于大部分系统来说，创建对象包括申请内存、给成员变量赋值等过程，这些操作耗费的时间基本可以忽略不计。 如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这其中耗费的时间有时是无法容忍的。 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（如大部分字段都相同），在这种情况下，可以利用对已有对象（原型）进行复制的方式来创建新对象，以达到节省创建时间的目的。 这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern）。 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 原型模式其核心就是拷贝，而在编程语言中，拷贝有两种实现方式：深拷贝和浅拷贝。 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"浅拷贝 浅拷贝只会复制对象中基本数据类型和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象…… 对于浅拷贝来说，如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但是对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险。 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:2:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"深拷贝 和浅拷贝不同，深拷贝得到的是一份完完全全独立的对象，相比浅拷贝，深拷贝更加耗时、更加耗内存空间。 常见的深拷贝有两种实现方式：递归浅拷贝对象直到只包含基本数据类型数据；序列化对象再反序列化成新的对象。实际开发中更推荐使用后者。 递归浅拷贝的 Java 代码示例如下： public class DeepProtoType implements Cloneable { // String 类型 public String name; // 引用数据类型 public DeepCloneableTarget deepCloneableTarget; public DeepProtoType() { super(); } @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; // 这里完成对基本数据类型（属性）和 String 类型的拷贝 deep = super.clone(); // 对引用数据类型的属性进行单独处理，如果有多属性，需要一一处理 DeepProtoType deepProtoType = (DeepProtoType)deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone(); return deepProtoType; } } 序列化对象的代码示例如下： public class DeepProtoType implements Serializable { // String 类型 public String name; // 引用数据类型 public DeepCloneableTarget deepCloneableTarget; public DeepProtoType() { super(); } public Object deepClone() { // 创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { // 序列化 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 当前这个对象以对象流的方式输出 oos.writeObject(this); // 反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepProtoType deepProtoType = (DeepProtoType) ois.writeObject(); return deepProtoType; } catch (Exception e) { e.printStackTrace(); return null; } finally { try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (Exception e2) { System.out.println(e2.getMessage()); } } } } ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:2:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"优点 原型模式的主要优点如下： 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 可以使用深拷贝方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来 原型模式提供了简化的创建结构 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 原型模式的主要缺点如下： 需要为每一个类都配置一个拷贝方法 拷贝方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则 当实现深拷贝的时候，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深拷贝，每一层对象对应的类都必须支持深拷贝 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 原型模式的适用场景如下： 创建对象的成本较大，比如初始化时间长，占用 CPU 太多，或者占用网络资源太多等 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较小时，可以使用原型模式配合备忘录模式来实现 如果产生一个对象需要非常繁琐的数据准备和访问权限，需要提高权限或提高安全性 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，对自定义的类重写 clone() 方法就是典型的原型模式。 ","date":"2022-09-25","objectID":"/posts/programming-pattern/prototype-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 原型模式","uri":"/posts/programming-pattern/prototype-design-pattern.html"},{"categories":["程序设计"],"content":"顾名思义，如何建房子一样，建造者模式可以将复杂对象的建造过程抽象出来，使用相同的构建过程可以构造出不同表现的对象。 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"简介 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"概念 建造者设计模式（Builder Design Pattern）又叫作生成器模式，是一种对象构建模式，其核心在于将产品和产品建造过程解耦。 建设者模式允许用户只通过指定复杂对象的类型和内容就可以一步一步地构建出一个复杂的对象，在这个过程当中，用户不需要知道内部的具体构建细节。 因此，建造者模式特别适合用于构建具有复杂内部结构的对象，或者是需要生成内部本身相互依赖的对象。 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:1:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"与工厂模式的区别 工厂模式注重的是整体对象的创建方法，而建造者模式注重的是对象的创建过程，创建对象的过程方法可以在创建时自由调用。 它们的区别还可以使用以下的经典例子解释： 顾客走进一家餐厅点餐，根据用户不同的选择，可以利用工厂模式来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，可以通过建造者模式根据用户选择的不同配料来制作披萨。 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:1:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"实现方式 传统的建造者模式会包括以下 4 部分： 建造者 Builder 抽象类：构建对象的抽象类，包括 buildPartX（） 相关的构建对象方法，以及 getResult() 这样获取实际对象的方法 建造者 ConcreteBuilder 具体类：继承自 Builder 抽象类，完善及构建自己特殊的 buildPartX() 方法 指挥者 Director 具体类：与客户端对接，然后根据需要创建出所需的对象，可以看做是一个代理 产品 Product 具体类：实际被构建出来的实际产品类 简单的 Builder 抽象类代码示例如下： public abstract class Builder { abstract void buildPartA(); abstract void buildPartB(); abstract Product createProduct(); } 具体的 ConcreteBuilder 类代码示例如下： public class ConcreteBuilder extends Builder { private Product product = new Product(); public void buildPartA() { product.setPartA(\"A\"); } public void buildPartB() { product.setPartB(\"B\"); } public Product createProduct() { return product; } } 产品 Product 类代码示例如下： public class Product { private String partA; private String partB; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } } 指挥者 Director 类代码示例如下： public class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public Product getProductA() { builder.buildPartA(); return builder.createProduct(); } public Product getProductB() { builder.buildPartB(); return builder.createProduct(); } } ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 传统的建造者模式所需的部分较多，在实际开发过程中，是需要简化系统结构，减少程序当中类的个数，并且降低用户的使用成本。 另一个常见的使用方式是，通过直接将 Builder 类作为产品类的静态内部类，这种方式更多的是降低较多成员变量时构建对象的复杂度。 以下是创建 ResourcePoolConfig 类的建造者模式代码示例： public class ResourcePoolConfig { private String name; private int maxTotal; private int maxIdle; private int minIdle; private ResourcePoolConfig(Builder builder) { this.name = builder.name; this.maxTotal = builder.maxTotal; this.maxIdle = builder.maxIdle; this.minIdle = builder.minIdle; } // 将 Builder 类设计成了 ResourcePoolConfig 的内部类 // 也可以将 Builder 类设计成独立的 ResourcePoolConfigBuilder 非内部类 public static class Builder { private static final int DEFAULT_MAX_TOTAL = 8; private static final int DEFAULT_MAX_IDLE = 8; private static final int DEFAULT_MIN_IDLE = 0; private String name; private int maxTotal = DEFAULT_MAX_TOTAL; private int maxIdle = DEFAULT_MAX_IDLE; private int minIdle = DEFAULT_MIN_IDLE; public ResourcePoolConfig build() { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等 if (name == null || name.isEmpty()) { throw new IllegalArgumentException(\"...\"); } if (maxIdle \u003e maxTotal) { throw new IllegalArgumentException(\"...\"); } if (minIdle \u003e maxTotal || minIdle \u003e maxIdle) { throw new IllegalArgumentException(\"...\"); } return new ResourcePoolConfig(this); } public Builder setName(String name) { if (name == null || name.isEmpty()) { throw new IllegalArgumentException(\"...\"); } this.name = name; return this; } public Builder setMaxTotal(int maxTotal) { if (maxTotal \u003c= 0) { throw new IllegalArgumentException(\"...\"); } this.maxTotal = maxTotal; return this; } public Builder setMaxIdle(int maxIdle) { if (maxIdle \u003c 0) { throw new IllegalArgumentException(\"...\"); } this.maxIdle = maxIdle; return this; } public Builder setMinIdle(int minIdle) { if (minIdle \u003c 0) { throw new IllegalArgumentException(\"...\"); } this.minIdle = minIdle; return this; } } } 以下是 ResourcePoolConfig 类建造者模式的使用方式： ResourcePoolConfig config = new ResourcePoolConfig.Builder() .setName(\"dbconnectionpool\") .setMaxTotal(16) .setMaxIdle(10) .setMinIdle(6) .build(); 上述的示例代码只是传入 4 个参数，就可以看得出构建一个对象的复杂性了，如果所需构建参数的数量更多，使用建造者模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性。 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"优点 建造者模式的主要优点如下： 使用建造者模式可以使客户端不必知道产品内部组成的细节 具体的建造者类之间是相互独立的，这有利于系统的扩展 具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 建造者模式的主要缺点如下： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 建造者模式的适用场景如下： 类的内部非常复杂，包含多个成员变量 类的属性之间有一定的依赖关系或者约束条件，需要指定其生成顺序 希望创建的对象是不可变的，在对象创建之后不能修改对象内部的属性值，暴露 setter() 方法的创建对象方式就不适用了 ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.lang.StringBuilder 是经典的建造者模式。 其中具体的如 append()、delete()、reverse() 等方法都是直接返回当前 StringBuilder 对象，其可以再继续调动类似的方法以构建出一个想要的 StringBuilder 对象。 如下是使用 StringBuilder 的一个代码示例： StringBuilder stringBuilder = new StringBuilder() .append(\"olleH\") .delete(0, 1) .insert(0, \"o\") .reverse(); // Hello System.out.println(stringBuilder); ","date":"2022-09-01","objectID":"/posts/programming-pattern/builder-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 建造者模式","uri":"/posts/programming-pattern/builder-design-pattern.html"},{"categories":["程序设计"],"content":"创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂设计模式通过定义一个单独的创建对象的方法来解决这些问题。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"简介 工厂设计模式（Factory Design Pattern）是一种创建型的设计模式，它提供了一种创建对象的最佳方式，是一种代替 new 操作符的一种模式。 在工厂模式中，创建对象不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象。 工厂模式还可以细分为三种的类型：简单工厂模式、工厂方法模式和抽象工厂模式。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"简单工厂模式 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"概念 简单工厂模式（Simple Factory Pattern）的定义是，由一个工厂对象决定创建出哪一种产品类的实例，被创建的产品类实例具有共同的父类或实现同样的接口。 因为在简单工厂模式中用于创建实例的方法通常是静态方法，因此简单工厂模式又被称为静态工厂模式（Static Factory Pattern）。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"实现方式 下面是使用果汁生产来展示简单工厂模式： 果汁 FruitJuice 接口：描述生产果汁的必要方法 public interface FruitJuice { void make(); } 苹果汁 AppleJuice 类：生产苹果汁的类 public class AppleJuice implements FruitJuice { public AppleJuice() { this.make(); } @Override public void make() { System.out.println(\"This is AppleJuice make!\"); } } 橙汁 OrangeJuice 类：生产橙汁的类 public class OrangeJuice implements FruitJuice { public OrangeJuice() { this.make(); } @Override public void make() { System.out.println(\"This is OrangeJuice make!\"); } } 果汁工厂 FruitJuiceFactory 类：负责生产各种果汁的类 public class FruitJuiceFactory { public FruitJuiceFactory() {} public static FruitJuice createFruitJuice(String juiceType) { FruitJuice fruitJuice = null; if (juiceType.equals(\"AppleJuice\")) { fruitJuice = new AppleJuice(); } else if (juiceType.equals(\"OrangeJuice\")) { fruitJuice = new OrangeJuice(); } return fruitJuice; } } 通过 if-else 逻辑是简单工厂的第一种实现方法，还可以通过静态代码块和 Map 结构实现简单工厂模式，具体的代码示例如下： import java.util.Map; import java.util.HashMap; public class FruitJuiceFactory { // 存储产品类的映射关系 private static final Map\u003cString, FruitJuice\u003e cachedFruitJuice = new HashMap\u003c\u003e(); static { cachedFruitJuice.put(\"AppleJuice\", new AppleJuice()); cachedFruitJuice.put(\"OrangeJuice\", new OrangeJuice()); } public FruitJuiceFactory() {} public static FruitJuice createFruitJuice(String juiceType) { if (juiceType == null || juiceType.isEmpty()) { return null; } // 直接从 Map 结构中取到对应的产品类实例 return cachedFruitJuice.get(juiceType.toLowerCase()); } } ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"优点 简单工厂模式的主要优点如下： 简单工厂模式实现了对象创建和使用的分离 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可 可以在不改变客户端代码的情况下更换或增加新的具体产品类 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 简单工厂模式的主要缺点如下： 工厂类集中了相似产品类的创建逻辑，职责过重 简单工厂模式违反开闭原则，新增产品类时需要改动到工厂类 通常使用静态方法作为创建实例的方法，无法实现继承关系 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 简单工厂模式的适用场景如下： 对于一批产品类，并且不会新增产品类，可以选择简单工厂模式 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:5","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.util.Calendar 使用了简单工厂模式。如下是其的一些实现逻辑： public abstract class Calendar implements Serializable, Cloneable, Comparable\u003cCalendar\u003e { private static Calendar createCalendar(TimeZone zone, Locale aLocale) { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.hasExtensions()) { String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) { cal = switch (caltype) { case \"buddhist\" -\u003e new BuddhistCalendar(zone, aLocale); case \"japanese\" -\u003e new JapaneseImperialCalendar(zone, aLocale); case \"gregory\" -\u003e new GregorianCalendar(zone, aLocale); default -\u003e null; }; } } if (cal == null) { if (aLocale.getLanguage() == \"th\" \u0026\u0026 aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale); } else if (aLocale.getVariant() == \"JP\" \u0026\u0026 aLocale.getLanguage() == \"ja\" \u0026\u0026 aLocale.getCountry() == \"JP\") { cal = new JapaneseImperialCalendar(zone, aLocale); } else { cal = new GregorianCalendar(zone, aLocale); } } return cal; } } ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:2:6","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"工厂方法模式 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"概念 简单工厂模式违背了开闭原则，没有能够做到“对扩展开放、对修改关闭”，新增产品类时需要改动到工厂类。 而工厂方法模式（Factory Method Pattern）是对简单工厂模式的进一步抽象，其好处是可以使系统在不修改原来代码的情况下引入新的产品类，即满足开闭原则。 和简单工厂模式中工厂负责生产所有的产品相比，工厂方法模式抽象出简单工厂的接口，然后将生产具体产品的任务分发给具体的产品工厂，即简单工厂的工厂。 由于工厂方法模式利用了面向对象的多态特性，因此又被称为多态工厂模式（Polymorphic Factory Pattern）。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"实现方式 在上述简单工厂模式的基础上，将果汁生产改造成工厂方法模式： 抽象工厂 AbstractFactory 接口：描述生产果汁工厂的必要方法 public interface FruitJuiceFactory { FruitJuice createFruitJuice(); } 苹果汁工厂 AppleJuiceFactory 类：详细的生产苹果汁的类 public class AppleJuiceFactory implements FruitJuiceFactory { public AppleJuiceFactory() {} @Override public FruitJuice createFruitJuice() { return new AppleJuice(); } } 橙汁工厂 OrangeJuiceFactory 类：详细的生产橙汁的类 public class OrangeJuiceFactory implements FruitJuiceFactory { public OrangeJuiceFactory() {} @Override public FruitJuice createFruitJuice() { return new OrangeJuice(); } } ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"优点 工厂方法模式除了具有简单工厂模式的优点之外，还有以下优点： 在系统中增加新的产品类时，无需修改原有的工厂代码，只需添加一个具体产品类和具体工厂类 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 工厂方法模式的主要缺点如下： 添加新的产品类时，需要同时提供具体产品类和对应的工厂类，系统中类的个数将成对增加 工厂方法模式引入了抽象层，增加了系统的抽象性和理解难度 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 工厂方法模式的适用场景如下： 客户端知道其需要的接口实现类，不知道所需要的具体对象类，可以通过对应的工厂创建实例 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:5","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.util.Collection 接口中定义的 iterator() 方法就是一个工厂方法。 所有实现了 Collection 接口的类，都需要显式地实现此方法并返回一个 Iterator 实例，不同的实现类可以拥有自己的实现逻辑。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:3:6","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"抽象工厂模式 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"概念 在工厂方法模式中，具体工厂负责生产具体的产品，每个具体工厂对应一种具体产品，工厂方法具有唯一性。 抽象工厂模式（Abstract Factory Pattern）定义了一个接口用于创建相关或有依赖关系的对象族，而无需指明具体的类，其可以整合简单工厂模式和抽象工厂模式。 学习抽象工厂模式需要理解两个概念：产品等级结构指的是产品的继承结构，如抽象果汁和具体果汁之间构成一个产品等级结构；产品族指的是由同一个工厂生产的，位于不同等级结构中的一组产品，如同一个饮料工厂生产的酒和果汁构成一个产品族。 从上述概念上理解，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式在工厂方法模式的基础上，覆盖了多个工厂的产品族。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"实现方式 在上述简单工厂模式的基础上，下面使用果汁生产和酒生产来展示抽象工厂模式： 酒 Alcohol 接口：描述生产酒的必要方法 public interface Alcohol { void make(); } 葡萄酒 Wine 类：详细的生产葡萄酒的类 public class Wine implements Alcohol { public Wine() { this.make(); } @Override public void make() { System.out.println(\"This is Wine make!\"); } } 啤酒 Beer 类：详细的生产啤酒的类 public class Beer implements Alcohol { public Beer() { this.make(); } @Override public void make() { System.out.println(\"This is Beer make!\"); } } 抽象工厂 AbstractFactory 接口：描述生产果汁和酒的必要方法 public interface AbstractFactory { FruitJuice creatFruitJuice(); Alcohol createAlcohol(); } 具体工厂 ConcreteFactory 类：可生产果汁和酒的工厂的类 public class ConcreteFactory implements AbstractFactory { public ConcreteFactory() {} @Override public FruitJuice creatFruitJuice(String juiceType) { FruitJuice fruitJuice = null; if (juiceType.equals(\"AppleJuice\")) { fruitJuice = new AppleJuice(); } else if (juiceType.equals(\"OrangeJuice\")) { fruitJuice = new OrangeJuice(); } return fruitJuice; } @Override public Alcohol createAlcohol(String alcoholType) { Alcohol alcohol = null; if (alcoholType.equals(\"Wine\")) { alcohol = new Wine(); } else if (alcoholType.equals(\"Beer\")) { alcohol = new Beer(); } return alcohol; } } ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"优点 抽象工厂模式的主要优点如下： 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无需修改已有代码，符合开闭原则 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 抽象工厂模式的主要缺点如下： 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 抽象工厂模式的适用场景如下： 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:5","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.util.Collection 接口可以看作一个抽象工厂。 Collection 接口定义了转换成 Iterator 实例的工厂方法，也定义了转换成 T[] 实例的工厂方法，可以认定其做了两个产品族的定义。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:4:6","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:5:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"使用标准 对于要不要使用工厂模式，其最本质的参考标准有以下四个： 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明 代码复用：创建代码抽离到独立的工厂类之后可以复用 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:5:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"应用场景 对于产品种类相对较少、且可预见性地不会修改的情况，可以使用简单工厂模式。使用简单工厂模式的客户端只需传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。 由于简单工厂模式会将所有创建逻辑都放在一个工厂类中，会导致这个工厂类会变得很复杂，当产品的种类是可预见地会增加时，还需要对工厂类做更改，这种时候可以采用工厂方法模式以达到不需要修改原来代码的情况下引进新的产品。 抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。当需要创建的对象是一系列相互关联或相互依赖的产品族时，或者是只会新增新的产品族而不是新种类的产品时，可以使用抽象工厂模式。 ","date":"2022-08-30","objectID":"/posts/programming-pattern/factory-design-pattern.html:5:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 工厂模式","uri":"/posts/programming-pattern/factory-design-pattern.html"},{"categories":["程序设计"],"content":"单例模式是一种创建型设计模式，让开发者能够保证一个类只有一个实例，并提供一个访问该实例的全局节点，有助于协调系统整体的行为。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:0:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"简介 一个类只允许创建一个对象（或实例），那么这个类就是一个单例类，这种设计模式称作单例设计模式（Singleton Design Pattern），简称单例模式。 单例模式保证系统内存中只存在一个对象，非常节省系统资源，对于一些需要频繁销毁的对象，使用单例模式可以提高系统性能。 一个普通单例模式的实现方式主要是以下三个步骤： 将单例类的构造方法定义为私有方法，禁止外部直接调用构造方法来实例化单例类的对象； 在类的内部创建并保存类的唯一实例，并设置成私有变量，禁止外部直接调用这个实例变量； 创建一个公开的静态方法，对外暴露类的唯一实例。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:1:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"具体实现 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:2:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"饿汉式 饿汉式的实现方式就是，在类装载的期间，将类的实例初始化好，然后通过静态方法拿到实例化的对象。 对应的 Java 代码片段如下： public class Singleton { // 静态实例化 private static final Singleton instance = new Singleton(); // 构造器私有化 private Singleton() {} // 公有静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } 除了通过使用静态常量初始化实例的方式以外，还可以通过静态代码块的方式实现饿汉式单例模式。 对应的 Java 代码片段如下： public class Singleton { // 静态变量 private static final Singleton instance; // 构造器私有化 private Singleton() {} // 静态代码块 static { instance = new Singleton(); } // 公有静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } 饿汉式的优点是，在类装载的时候就完成了实例化，避免了线程同步问题。 但是，这样的实现方式不支持延迟加载实例，如果从始至终未使用过这个实例，就会造成内存浪费。 并且，饿汉式在一些场景中无法使用：比如单例类实例的创建是依赖参数或者配置文件的，在通过 getInstance() 方法获取实例对象之前需要调用某个方法设置参数给对象实例，则这种方式将无法使用。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:2:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"懒汉式 懒汉式相对于饿汉式的优势是支持延迟加载，可以在需要使用实例的时候才进行初始化。 对应的 Java 代码片段如下： public class Singleton { // 静态变量 private static Singleton instance; // 构造器私有化 private Singleton() {} public static Singleton getInstance() { if (instance == null) { // 实例不存在时初始化 instance = new Singleton(); } return instance; } } 上述的实现方式是线程不安全的，如果有两个线程同时进入到 getInstance() 方法，并且正好都通过了判断语句，这时便会产生多个实例。通常不建议在生产环境中使用线程不安全的懒汉式创建单例类。 为了做到线程安全，可以给 getInstance() 方法加一把锁。 对应的 Java 代码片段如下： public class Singleton { // 静态变量 private static Singleton instance; // 构造器私有化 private Singleton() {} // 使用 synchronized 对方法进行加锁 public static synchronized Singleton getInstance() { if (instance == null) { // 实例不存在时初始化 instance = new Singleton(); } return instance; } } 上述在 getInstance() 方法加锁的方式解决了线程不安全的问题，但是，由于加锁的粒度较大，实际的效率非常低。 如果这个单例类偶尔会被使用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁则会出现并发度低的问题，造成性能瓶颈。 因此，也不建议在生产环境中使用线程安全的懒汉式创建单例类。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:2:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"双重检测 饿汉式和懒汉式的实现方式都有一定的限制，而双重检测的实现方式是一种既支持延迟加载、又支持高并发的单例实现方式。 对应的 Java 代码片段如下： public class Singleton { // 静态变量 private static Singleton instance; // 构造器私有化 private Singleton() {} public static Singleton getInstance() { // 一次检测 if (instance == null) { synchronized (Singleton.class) { // 二次检测 if (instance == null) { instance = new Singleton(); } } } return instance; } } 当有两个线程同时进入到 getInstance() 方法时，虽然会出现都通过第一次检查的判断语句，但是只会有一个线程获得锁并实例化对象，即使后续再有线程进入到同步代码块中，也会被第二次检查的判断语句挡在外面。 双重检测方式在多线程开发中常使用到，其优点是线程安全、支持延迟加载、效率较高。在实际开发中比较推荐使用这种方式实现单例模式。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:2:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"静态内部类 静态内部类是一种比双重检测更加简单的实现方式。它有点类似饿汉式，但又能做到延迟加载。 对应的 Java 代码片段如下： public class Singleton { // 静态内部类 private static class SingletonHolder { // 初始化实例 private static final Singleton instance = new Singleton(); } // 构造器私有化 private Singleton() {} public static Singleton getInstance() { // 返回内部类的静态实例 return SingletonHolder.instance; } } 这种方式采用类装载机制来保证初始化实例时只有一个线程。 静态内部类方式在单例类被加载的时候并不会立即实例化，而是在调用 getInstance() 方法的时候，才会装载 SingletonHolder 类，从而实现单例类的实例化。 类的静态属性只会在第一次加载类的时候初始化，实例的唯一性、创建过程的线程安全性，都由 JVM 来保证。 所以，这种实现方法既保证了线程安全，又能做到延迟加载，效率也比较高，也是一种推荐使用的实现方式。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:2:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"枚举 基于枚举类型的单例实现，是最简单的实现方式。 对应的 Java 代码片段如下： public enum Singleton { // 实例属性 INSTANCE; public void doSomething() { // 通过以下方式调用此方法 // Singleton.INSTANCE.doSomething(); } } 这种方式是通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性，还能防止反序列化重新创建新的对象。 这种方式是 Effective Java中文版（第3版） 作者提倡的方式，推荐在生产环境中使用。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:2:5","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"深度理解 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:3:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"单例模式唯一性的范围 单例类只允许创建唯一对象（或实例），这里对象的唯一性范围指的是进程内只允许创建一个对象。 进程之间是不共享地址空间的，如果在一个进程中创建另一个进程，操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据。 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象不是同一个对象。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:3:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"实现线程唯一的单例 “进程唯一”指的是进程内唯一，进程间不唯一。类比得知，“线程唯一”指的是线程内唯一，线程间不唯一。 其实，“进程唯一”的单例在同一个进程中的线程间唯一，若要做到“线程唯一”，主要是做到线程间保持不唯一。 实现线程唯一单例的代码很简单，可以通过一个键值对做关联存储，其中 key 是线程 ID，value 是对象。 对应的 Java 代码片段如下： import java.util.concurrent.ConcurrentHashMap; public class Singleton { // 保证线程唯一的键值对 private static final ConcurrentHashMap\u003cLong, Singleton\u003e instanceMap = new ConcurrentHashMap\u003c\u003e(); // 构造器私有化 private Singleton() {} public static Singleton getInstance() { Long currentThreadId = Thread.currentThread().getId(); instanceMap.putIfAbsent(currentThreadId, new Singleton()); return instanceMap.get(currentThreadId); } } ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:3:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"实现集群唯一的单例 这里的集群表示进程集群，类比可知，“集群唯一”相当于进程间也唯一，即在不同的进程间共享同一个对象，不创建同一个类的多个对象。 实现集群唯一单例需要依赖到外部共享存储区：将单例对象序列化并存储到外部共享存储区，在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。 为了保证任何时刻在集群中都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。 在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对象的锁。 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:3:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"实现一个多例模式 “多例”指的是，一个类可以创建多个对象，但是个数是有限制的，同无限个有一些区别。 多例模式的实现也比较简单，通过一个键值对存储索引和对象之间的对应关系，并且需要控制对象的个数。 对应的 Java 代码片段如下： import java.util.Map; import java.util.HashMap; import java.util.Random; public class Multipleton { // 限制实例数量 private static final int COUNT = 3; // 存储对应关系的键值对 private static final Map\u003cInteger, Multipleton\u003e instanceMap = new HashMap\u003c\u003e(); // 饿汉式实现 static { instanceMap.put(0, new Multipleton()); instanceMap.put(1, new Multipleton()); instanceMap.put(2, new Multipleton()); } // 构造器私有化 private Multipleton() {} // 公有静态方法，返回对应索引的实例对象 public static Multipleton getInstance(Integer index) { return instanceMap.get(index); } // 公有静态方法，返回随机索引的实例对象 public static Multipleton getRandomInstance() { Random random = new Random(); Integer index = random.nextInt(COUNT); return instanceMap.get(index); } } ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:3:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"总结 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:4:0","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"优点 单例模式的主要优点如下： 提供了对唯一实例的受控访问，封装性非常好 系统内存中只存在一个对象，可以节省系统资源 基于单例模式，可扩展实现多例类，既节省系统资源，又解决了由于单例模式共享过多有损性能的问题 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:4:1","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"缺点 单例模式的主要缺点如下： 单例模式对面向对象特性的支持不友好，违背了基于接口而非实现的设计原则 单例模式对代码的扩展性不友好，如要扩展则会导致改动较大 常规的单例模式不支持有参数的构造函数，只能通过其他方式改动单例类中的成员变量 对于有 GC 的编程语言，如果长时间不使用实例化的对象，则单例对象有可能会被销毁 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:4:2","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"适用场景 单例模式的适用场景如下： 单例模式主要针对需要频繁地创建和销毁的对象，可以理解成创建对象时耗时过多或耗费资源较大但又经常用到的对象。如工具类对象、频繁访问的数据库或文件对象 从业务概念上看，有些数据在系统中只应该保存一份，就比较适合设计成单例类。比如，系统的配置信息类 可以使用单例解决资源访问冲突的问题，单例模式可以只提供一个公共访问点 ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:4:3","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["程序设计"],"content":"源码 在 JDK 中，java.lang.Runtime 是经典的单例模式，其用于与 Java 运行时环境进行交互。 Runtime 类是一个典型的饿汉式单例模式实现，如下是其的一些实现逻辑： public class Runtime { // 静态实例化 private static final Runtime currentRuntime = new Runtime(); private static Version version; // 静态方法获取静态实例 public static Runtime getRuntime() { return currentRuntime; } // 构造器私有化 private Runtime() {} ","date":"2022-08-26","objectID":"/posts/programming-pattern/singleton-design-pattern.html:4:4","tags":["设计模式","面向对象"],"title":"初识设计模式 - 单例模式","uri":"/posts/programming-pattern/singleton-design-pattern.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c，使得 a + b + c = 0，请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:1:0","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:2:0","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"示例 1 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:2:1","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"示例 2 输入：nums = [] 输出：[] ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:2:2","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"示例 3 输入：nums = [0] 输出：[] ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:2:3","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"限制 0 \u003c= nums.length \u003c= 3000 -105 \u003c= nums[i] \u003c= 105 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:2:4","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:3:0","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"暴力枚举 最先想到的应该是暴力枚举的方法，当然这也是最简单的的方法。 既然这里要找出符合要求的三个数，当然是使用三层循环依次去匹配，缺点就是时间复杂度达到了 $O(n^3)$，当数组长度特别长的时候，程序运行时间也会特别长。 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:3:1","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"哈希匹配 从“两数之和”题目中可以知道，使用哈希表结构采用空间换时间的方式，时间复杂度能从 $O(n^2)$ 降到了 $O(n)$。 如果将这种空间换时间的方式代入这个题目，可以将暴力破解 $O(n^3)$ 的时间复杂度降到 $O(n^2)$，这也是一个非常大的提升。 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:3:2","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["LeetCode"],"content":"排序 + 双指针 现在思考一下如何将时间复杂度从 $O(n^2)$ 降下去。 首先一层循环是必不可少的，因为至少要对给定的数组做一次枚举； 假如拿到数组的第一个元素，需要思考一下怎么从数组剩下的元素中找到匹配的两个元素，换一个思路其实就是从剩下的数组元素中找到和等于第一个元素相反数的两个元素，所以这里退变成了“两数之和”的逻辑； 如果对剩下的元素采用哈希匹配的方法，其实就和上面的方法一致了，由于答案中不可以包含重复的三元组，这里先对数组进行排序，方便后续跳过相同的答案，再采用数组首尾双指针的方法查找匹配的两个数。 package cn.fatedeity.algorithm.leetcode; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class ThreeSum { public List\u003cList\u003cInteger\u003e\u003e answer(int[] nums) { List\u003cList\u003cInteger\u003e\u003e result = new ArrayList\u003c\u003e(); Arrays.sort(nums); for (int i = 0; i \u003c nums.length; i++) { if (i != 0 \u0026\u0026 nums[i] == nums[i - 1]) { // 答案不可以包含重复的三元组，这里相同的数直接过掉 continue; } int target = -nums[i]; int left = i + 1; int right = nums.length - 1; while (left \u003c right) { int diff = target - (nums[left] + nums[right]); if (diff \u003e 0) { left++; } else if (diff \u003c 0) { right--; } else { boolean leftFlag = left == 0 || nums[left] != nums[left - 1]; boolean rightFlag = right == nums.length - 1 || nums[right] != nums[right + 1]; if (leftFlag || rightFlag) { // 这里的 if 判断仍然是避免答案出现重复的三元组 List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); result.add(list); } left++; right--; } } } return result; } } 使用这个方式解决这个题目，耗时的地方有两个：对原数组进行排序；对排序后的数组查找出和为目标数的两个数。 排序的时间复杂度可以看做是 $O(n\\log_2n)$，查找出剩余两个数采用了遍历数组并嵌套使用双指针遍历，时间复杂度为 $O(n \\times n)$，最终总体的时间复杂度在 $O(n^2)$。 在整个过程当中，除了存储答案需要额外的空间，实际的空间复杂度是 $O(1)$。 ","date":"2022-08-23","objectID":"/posts/leetcode/three-sum.html:3:3","tags":["数组","双指针","排序"],"title":"LeetCode - 三数之和","uri":"/posts/leetcode/three-sum.html"},{"categories":["程序设计"],"content":"设计原则为提高可维护性和可复用性而生，每一种设计模式都符合一个或多个设计原则，因此设计原则也是评价一个设计模式使用效果的重要指标之一。 经典设计原则除了 SOLID 之外，常见的还包括 KISS、YAGNI、DRY、LOD、CRP 等几种： KISS(Keep It Simple \u0026 Stupid, 尽量保持简单) YAGNI(You Ain’t Gonna Need It, 你不会需要它) DRY(Don’t Repeat Yourself, 不要重复自己) LOD(Law Of Demeter, 迪米特法则) CRP(Composite Reuse Principle, 合成复用原则) ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:0:0","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"KISS 原则 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:1:0","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"理解 KISS 原则的英文描述有很多版本，如下： Keep It Simple \u0026 Stupid Keep It Sweet \u0026 Simple Keep It Short \u0026 Simple Keep It Simple \u0026 Straightforward 它们的含义都差不多，其实就是“尽量保持简单”。 但是，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。并且，有些本身就复杂的问题，用复杂的方法解决，并不能算是违背 KISS 原则。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:1:1","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"优点 遵循 KISS 原则，将会有以下的优点： 简单地编写代码，理解该代码不会有任何困难，将更容易修改，而且花费的时间也会大大减少 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:1:2","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"最佳实践 在实际开发中，可以通过以下情况判断代码是否满足 KISS 原则： 不要使用协作者可能不懂的技术来实现代码 不要重复造轮子，要善于使用已经有的工具类 不要过度优化，牺牲代码的可读性 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:1:3","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"YAGNI 原则 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:2:0","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"理解 YAGNI 原则的核心思想就是不要过度设计，即不要去设计当前用不到的功能，不要去编写当前用不到的代码。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:2:1","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"优点 遵循 YAGNI 原则，将会有以下的优点： 过度设计往往会延缓开发的迭代速度，减少过度设计将能支持创业公司的快速迭代 编写只符合当前场景的代码质量可能会更高，这也是 KISS 原则的另一种实践 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:2:2","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"最佳实践 虽然说，在不需要某功能前，不要提前去实现此功能。但是，在可预见的情况下，需要预留好扩展点，等到实现此功能时能无缝接入。 比如，系统在当前只需要使用 Redis 存储配置信息，以后有可能会用到 ZooKeeper 存储配置信息。根据 YAGNI 原则，当前没有必要编写 ZooKeeper 的代码，但是可以通过抽象出统一的配置存储接口作为扩展点，方便后续可以快速接入。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:2:3","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"DRY 原则 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:3:0","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"理解 DRY 原则可以理解成不要写重复的代码，解决的是代码的复用性问题。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:3:1","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"优点 遵循 DRY 原则，将会有以下的优点： 对于频繁更改需求的情况，重复代码将会增加修改代码的痛苦 遵循 DRY 原则要求开发者具备高度抽象思维，高度抽象的代码具备高可维护性、高扩展性 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:3:2","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"最佳实践 常见代码重复情况 实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。 比如说，一个检验用户名和检验密码的代码在编写上完全一致，因此写了 isValidUserName() 和 isValidPassword() 两个函数，但其实这两个函数并不能算作违反 DRY 原则。 功能语义重复，但实现逻辑不重复的代码，视为违反 DRY 原则。 其原则在于，对于完全相同的功能，不允许出现两个及其以上的对外接口，更不允许出现不同的代码表示同一个功能。 隐藏的执行重复被认定违反 DRY 原则。 即当运行完一个代码流程之后，出现相同的函数被无意义地执行过两次及其以上，则被称为执行重复，这是一种隐藏的违反 DRY 原则的行为。 代码复用性 总结有以下方法可以提高代码的可复用性： 减少代码耦合 满足单一职责原则 善于模块化 业务与非业务逻辑分离 通用代码下沉 善用面向对象的特性 应用设计模式 事不过三 “3”是一个非常神奇的数字，“事不过三”是它的一种特殊用法，这个原则可以应用在编写可复用代码的时候。 可以这么理解：第一次写代码时，如果当下没有复用的需求，而未来的复用需求也不是很明确，并且开发可复用代码的成本比较高，那就不需要考虑代码的复用性；第二次遇到复用场景的时候，再进行重构使其变得可复用。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:3:3","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"LOD 原则 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:4:0","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"理解 LOD(迪米特) 原则也被叫作最小知识法则（Least Knowledge Principle, LKP），其含义是不该有依赖的模块之间不要有依赖，有依赖关系的模块之间尽量只依赖必要的接口。 迪米特原则有点类似于接口隔离原则，希望能减少类之间的耦合，让类越独立越好。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:4:1","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"优点 遵循迪米特原则，将会有以下的优点： 降低类之间的耦合度，提高了模块的相对独立性 提高类的可复用率和系统的扩展性 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:4:2","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"最佳实践 迪米特原则还有几种定义形式：不要和陌生人“说话”，只与你的直接朋友通信等。 在迪米特原则中，对于一个对象，其“朋友”包括以下几类： 当前对象本身 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的对象也都是朋友 当前对象所创建的对象 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:4:3","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"CRP 原则 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:5:0","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"理解 CRP 原则又称为组合/聚合复用原则，其含义是，尽量使用对象组合，而不是继承来达到复用的目的。 通过继承来进行复用的主要问题在于，继承复用会破坏系统的封装性。当基类发生了改变，继承基类的子类也会不可避免地发生改变，从基类继承而来的实现是静态的，不可能在运行时发生变化，没有足够的灵活性。 通过组合或聚合关系可以将已有的对象纳入新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样关系不会将已有对象的实现细节暴露给新对象。 相对继承而言，组合和聚合复用的耦合度更低，相互之间的影响不大，实际开发中可以有选择性地调用需要的功能。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:5:1","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"优点 遵循 CRP 原则，将会有以下的优点： 系统更加灵活，降低了类与类之间的耦合度，一个类的变化对其他类造成的影响相对较小 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:5:2","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"最佳实践 一般而言，如果两个类之间是“Has-A”的关系，应使用组合或聚合；如果是“Is-A”的关系，可以使用继承。 ","date":"2022-08-22","objectID":"/posts/programming-pattern/classic-design-principles.html:5:3","tags":["设计原则","设计模式"],"title":"经典设计原则","uri":"/posts/programming-pattern/classic-design-principles.html"},{"categories":["程序设计"],"content":"SOLID 原则是面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。 SOLID 设计原则包含以下 5 种原则： 单一职责原则（Single Responsibility Principle, SRP） 开闭原则（Open Closed Principle, OCP） 里式替换原则（Liskov Substitution Principle, LSP） 接口隔离原则（Interface Segregation Principle, ISP） 依赖反转原则（Dependency Inversion Principle, DIP） ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:0:0","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"单一职责原则 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:1:0","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"理解 单一职责原则的描述是，一个类或者模块只负责完成一个职责（或功能）。当然，单一职责原则不止是可以针对于模块或类，对于很多粒度都有效果，如函数、类、接口、模块等等，模块通常由多个类组成。 职责可以指模块变化的原因，从这个角度理解，单一职责原则表示不要存在超过一个导致模块变更的原因。 需要注意的是，不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:1:1","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"优点 遵循单一职责原则，将会有以下的优点： 提高代码的可维护性：职责越少，复杂度越低，可读性更好，可维护性就更高 降低代码变更的风险：职责越多，代码变更的可能性就越高，变更带来的风险也就越大 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:1:2","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"最佳实践 在实际开发中，出现以下现象有可能违反了单一职责原则： 模块的变量、属性或代码行数过多 模块的内部对外部依赖过多 模块的私有方法过多 难以给模块取一个合理的名称 模块的大部分操作只针对几个属性 如出现上述情况，则需要判断是否对代码做职责分离，以遵循单一职责原则，最终应以提高内聚、降低耦合、保证代码的可维护性为主。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:1:3","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"开闭原则 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:2:0","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"理解 开闭原则的描述是，软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。 详细的解释就是，添加一个新的功能时，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。更宽松的理解是以最小的修改代码的代价来完成新功能的开发。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:2:1","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"优点 遵循开闭原则，将会有以下的优点： 减少测试范围：修改的代码范围越小，涉及的测试范围越小，未改动的测试代码仍能正常运行 降低维护成本：软件规模越大、寿命越长，则软件的维护成本越高 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:2:2","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"最佳实践 若要做到“对扩展开发、对修改关闭”，有以下几点需要注意： 时刻具备扩展意识、抽象意识、封装意识，多花时间设计代码结构，事先留好扩展点 大部分经典设计模式都是为了解决代码的扩展性问题而总结出来的，开闭原则是它们一个重要的评价依据 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:2:3","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"里式替换原则 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:3:0","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"理解 里式替换原则的描述是，子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。 从代码实现上看，面向对象的多态和里式替换原则有点类似，但是它们的关注点不一样：里式替换原则是用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:3:1","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"优点 遵循里式替换原则，将会有以下的优点： 实现有意义的继承：保证了父类的复用性，也降低了系统出错误的故障，防止误操作，同时也不会破坏继承的机制 增强程序的健壮性：不同的子类可以完成不同的业务逻辑，即使增加子类也能保持非常好的兼容性 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:3:2","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"最佳实践 通常，需要注意以下违反里式替换原则的代码： 子类违背父类声明要实现的功能，如将加法改成减法 子类违背父类对输入、输出、异常的约定，如同一情况抛出的异常不同等 子类违背父类注释中所罗列的任何特殊声明 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:3:3","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"接口隔离原则 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:4:0","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"理解 接口隔离原则的描述是，接口的调用者或使用者不应该被强迫依赖它不需要的接口。 通过对接口的理解不同，接口隔离原则有以下三种理解： 1、如果把“接口”理解成一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果存在部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖其他不会用到的接口。 2、如果把“接口”理解成单个 API 接口或函数，部分调用者只需要其中的部分功能，则需要将这个函数拆分成更细粒度的多个函数，让调用者只依赖它需要的那个细粒度函数。 3、如果把“接口”理解成 OOP 中的接口，也可以理解成为面向对象编程语言中的接口语法，那接口的设计要尽量单一，不要让接口的实现类和调用者依赖不需要的接口函数。 接口隔离原则和单一职责原则有点类似，但接口隔离原则更侧重于接口的设计，通常是通过调用者如何使用接口来定义这个接口的设计是否足够职责单一。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:4:1","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"优点 遵循接口隔离原则，将会有以下的优点： 高内聚，低耦合：拆分成更小粒度的接口，减少对外的交互，预防外来的变更，提高系统的灵活性和可维护性 可读性高，易于维护：合理的接口拆分粒度能保证系统的稳定性，减少项目工程的代码冗余 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:4:2","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"最佳实践 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。定义过小，则会造成接口数量过多，使设计复杂化；定义多大，灵活性降低 每个项目和产品都有选定的环境因素，环境不同，接口拆分的标准就不同，深入了解业务逻辑 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:4:3","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"依赖反转原则 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:5:0","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"理解 依赖反转原则也被叫作依赖倒置原则，其含义是：高层模块不要依赖底层模块，高层模块和底层模块应该通过抽象来互相依赖；抽象不要依赖具体实现细节，具体实现细节依赖抽象。 Tomcat 是运行 Java Web 应用程序的容器，编写的 Web 应用程序代码只需要部署在 Tomcat 容器中下，便可被 Tomcat 容器调用执行。在这里，Tomcat 容器就是高层模块，Web 应用程序就是底层模块。Tomcat 容器和 Web 应用程序没有直接的依赖关系，而是通过 Servlet 规范实现互相依赖，而 Servlet 规范也不会依赖具体的实现细节，而是 Tomcat 和 Web 应用程序依赖 Servlet 规范。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:5:1","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"控制反转 控制反转（Inversion Of Control, IoC）指的是将程序员自己对程序执行流程的控制反转成通过框架控制。控制反转并不是一种具体的设计技巧，而是一种笼统的设计思想，一般用来指导框架层面的设计。 实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类 A 的实例创建过程中即创建了依赖的 B 对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:5:2","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"依赖注入 依赖注入（Dependency Injection, DI）是一种具体的编码技巧。 其详细概括就是：不通过 new 的方式在类的内部创建依赖对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 一个简单的依赖注入代码例子如下： package cn.fatedeity.designpattern.philosophy; /** * 依赖注入案例 */ public class DependencyInjectionCase { private MessageSender messageSender; public DependencyInjectionCase(MessageSender messageSender) { this.messageSender = messageSender; } public void sendMessage(String phone, String message) { this.messageSender.send(phone, message); } public static void main(String[] args) { MessageSender smsSender = new SmsSender(); DependencyInjectionCase dependencyInjectionCase0 = new DependencyInjectionCase(smsSender); // SmsSender sms send sms message dependencyInjectionCase0.sendMessage(\"sms\", \"sms message\"); MessageSender inboxSender = new InboxSender(); DependencyInjectionCase dependencyInjectionCase1 = new DependencyInjectionCase(inboxSender); // InboxSender inbox send inbox message dependencyInjectionCase1.sendMessage(\"inbox\", \"inbox message\"); } } class InboxSender implements MessageSender { @Override public void send(String phone, String message) { System.out.println(\"InboxSender \" + phone + \" send \"+ message); } } class SmsSender implements MessageSender { @Override public void send(String phone, String message) { System.out.println(\"SmsSender \" + phone + \" send \"+ message); } } interface MessageSender { void send(String phone, String message); } ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:5:3","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"优点 遵循依赖反转原则，将会有以下的优点： 查询依赖和应用代码分离，大量降低工厂类和单例类的数量，代码层次更加清晰 没有侵入性，无须依赖容器的 API，也无须实现一些特殊接口 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:5:4","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["程序设计"],"content":"最佳实践 通过依赖注入提供的扩展点，简单配置一下所有需要的类及其类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等功能。 现成的依赖注入创建有很多，比如 Google Guide、Java Spring、Pico Container、Butterfly Container 等。 ","date":"2022-08-18","objectID":"/posts/programming-pattern/classic-design-principles-solid.html:5:5","tags":["设计原则","设计模式"],"title":"经典设计原则 - SOLID","uri":"/posts/programming-pattern/classic-design-principles-solid.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:1:0","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:2:0","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"示例 1 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:2:1","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"提示 2 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:2:2","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"提示 1 \u003c= strs.length \u003c= 200 0 \u003c= strs[i].length \u003c= 200 strs[i] 仅由小写英文字母组成 ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:2:3","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:3:0","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"逐一对比 此方法如其名称，即将数组中的字符串逐一进行对比，先找出第一、第二个字符串的最长公共前缀，再找出第二、第三个字符串的最长公共前缀，以此类推，直至完成所有字符串的比较。 当然，当在对比过程中发现最长公共前缀已经为空，则直接返回即可。 此方式是较为常规的思路，时间复杂度为 $O(mn)$，其中 m 是字符串数组中字符串的平均长度，n 是字符串数组的长度，最坏情况下，字符串数组中的每个字符串都会被比较一次。 根据代码的写法不同，若利用额外的空间则空间复杂度是 $O(n)$，若使用数组中的第一个字符串做相关增减，则空间复杂度是 $O(1)$。 package cn.fatedeity.algorithm.leetcode; public class LongestCommonPrefix { public String answer(String[] strs) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i \u003c strs.length; i++) { if (stringBuilder.length() \u003e strs[i].length()) { stringBuilder.setLength(strs[i].length()); } for (int j = 0; j \u003c strs[i].length(); j++) { char c = strs[i].charAt(j); if (i == 0) { stringBuilder.append(c); continue; } else if (stringBuilder.charAt(j) != c) { stringBuilder.replace(j, stringBuilder.length(), \"\"); } if (j \u003e= stringBuilder.length() - 1) { break; } } if (stringBuilder.isEmpty()) { return stringBuilder.toString(); } } return stringBuilder.toString(); } } ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:3:1","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"同时对比 同时对比指的是，每一次对比的时候，都将数组中所有的字符串拿出来进行比较，如同时比较数组中所有字符串的第一个字符，然后比较数组中所有字符串的第二个字符，以此类推，直到已对比完整个字符串，或者所在位置的字符有所不同。 此方法也是常规思路中的一种，时间复杂度为 $O(mn)$，其中 m 是字符串数组中字符串的最小长度，n 是字符串数组的长度，最坏情况下，字符串数组中的每个字符串都会被比较一次。 空间复杂度同逐一对比方法一样，最低可以做到 $O(1)$ 的空间复杂度。 package cn.fatedeity.algorithm.leetcode; public class LongestCommonPrefix { public String answer(String[] strs) { StringBuilder commonStr = new StringBuilder(strs[0]); if (strs.length == 1) { return strs[0]; } for (int i = 0; i \u003c strs[0].length(); i++) { for (int j = 1; j \u003c strs.length; j++) { if (strs[j].length() == i || commonStr.charAt(i) != strs[j].charAt(i)) { commonStr.replace(i, commonStr.length(), \"\"); return commonStr.toString(); } } } return commonStr.toString(); } } ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:3:2","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["LeetCode"],"content":"逐一对比优化 这里是一个优化的逐一对比方法，其实也是使用了编程语言的一些特性，直接判断当前的公共前缀是否是下一个字符串的公共前缀，只有满足所有字符串要求的前缀才是最终结果。 实际落实到代码中就是，没有自己将字符串的每一个字符都做比较，而是使用编程代码中已有的方法做比较，实际的时间复杂度没有脱离 $O(mn)$ 的范畴，但实际效果比自行开发的比较要好。 package cn.fatedeity.algorithm.leetcode; public class LongestCommonPrefix { public String answer(String[] strs) { if (strs.length == 1) { return strs[0]; } String prefix = strs[0]; for (String str : strs) { while (!str.startsWith(prefix)) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.length() == 0) { return \"\"; } } } return prefix; } } ","date":"2022-08-12","objectID":"/posts/leetcode/longest-common-prefix.html:3:3","tags":["字符串"],"title":"LeetCode - 最长公共前缀","uri":"/posts/leetcode/longest-common-prefix.html"},{"categories":["程序设计"],"content":"“基于接口而非实现编程”是一条比较抽象、泛化的设计思想，其的另一个表述是“基于抽象而非实现编程”。从这条设计思想中衍生的理解就是，越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:0:0","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"抽象类和接口的区别 在面向对象编程当中，抽象类和接口是为抽象而生而的两个概念，在初学时特别容易搞混它们俩。 Java 既支持接口，也支持抽象类，这里主要拿 Java 的接口和抽象类做比较。简单地在 Java 中定义这两个概念就是，抽象类是包含抽象方法的类，接口是对行为的抽象。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:1:0","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"抽象类 在 Java 中，抽象类仍然以 class 定义，并在此基础上增加 abstract 修饰，如下是抽象类的定义： [public|protected] abstract class ClassName { abstract void fun(); } 从定义上看，Java 中的抽象类就是用来继承的，没有被继承的抽象类没有任何实际的作用。而且，抽象类中的抽象方法只是起到一个限制的作用，并没有提供实际的方法体，这也要求子类去实现自己的方法体。 将抽象类的特征总结一下，大概有以下几点： 抽象类不允许被实例化，只能被继承 抽象类可以包含属性和方法，方法里既可以包含具体实现，也可以不包含具体实现，不包含具体实现的方法称为抽象方法 子类继承抽象类，必须实现抽象类的所有抽象方法 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:1:1","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"接口 在 Java 中，接口以 interface 定义，与 class 定义的类不同，如下是接口的定义： [public|protected] interface InterfaceName { void func(); } 接口实际上也可以包含变量和方法，但是，接口中的变量会被隐式地指定为 public static final 修饰的不可变量，接口中的方法会被隐式地指定为 public abstract 修饰的方法。 将接口的特性总结一下，大概有以下几点： 接口不能声明属性，可以声明的是静态变量 接口声明的方法不包含具体实现 类实现接口的时候，必须实现接口中声明的所有方法 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:1:2","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"区别 从上述对抽象类和接口的简单分析看，抽象类和接口的概念非常相似，从明面上看，其最大的区别就是，抽象类是用来继承的，接口是用来实现的。 从更深层次的角度上看，抽象类是不能被实例化的类，只能被子类继承，继承关系表示的是一种 is-A 的关系，接口表示的是一种 has-A 关系。 在使用时，抽象类可以定义一些公共的属性、方法，抽象方法用于声明子类继承的约束；接口的主要作用就是声明实现的协议，但是相比抽象类的优势就是一个类可以实现多个接口。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:1:3","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"抽象类和接口的使用 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:2:0","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"抽象类的使用 首先，只能被子类继承的抽象类能解决代码复用的问题。 然后，抽象类表达的是一种抽象概念，适用于表示现实生活中的抽象概念。如狗是具体对象，动物则是抽象概念。 使用抽象方法，而非空的方法体，创建子类时就知道他必须要重写该方法，而不能忽略。 使用抽象类，类的使用者创建对象的时候，就知道他必须要使用某个具体子类，而不是抽象类本身。 使用抽象类提高了安全性，降低了开发者犯错的概率，是一种更优雅的编码方式。 抽象类更多的作用是引导使用者正确使用，避免被误用。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:2:1","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"接口的使用 接口是对行为的一种抽象，相当于一组协议，更侧重于解耦。 调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合，提高代码的扩展性。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:2:2","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"配合使用 如果抽象类只定义抽象方法，那抽象类和接口非常相似。但接口和抽象类在根本上是不同的，一个类可以实现多个接口，但只能继承一个类。 抽象类和接口是配合而不是替代，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。 比如，在 Java 类库中有以下关系： Collection 接口和对应的 AbstractCollection 抽象类 List 接口和对应的 AbstractList 抽象类 Map 接口和对应的 AbstractMap 抽象类 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:2:3","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"模拟抽象类和接口 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:3:0","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"通过抽象类实现接口 接口没有成员变量，没有方法实现，只有方法声明，实现接口的类必须实现接口中的所有方法。 只要满足上述几个特点，从设计的角度上讲，它就可以叫作接口。 在 Java 中，使用抽象类实现起来也比较简单，即抽象类只定义抽象方法即可，缺陷就是子类无法继承多个抽象类。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:3:1","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"用普通类模拟接口 普通的类是可以包含具体实现的，这不符合接口的定义。但是，可以让类中的方法抛出 NoSuchMethodError 错误来模拟不包含实现的接口，并且强迫子类在继承这个父类时都去主动实现父类的方法，否则就会在运行时抛出异常。 为了避免普通的类被实例化，需要将这个类的构造函数声明成 protected 访问权限。 具体的代码实现如下： public class MockInterface { protected MockInterface() {} public void funcA() { throw new NoSuchMethodError(); } } 同样的，无论是使用抽象类还是普通类，实现的接口都无法满足接口的所有特性，这里也仅做一些了解。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:3:2","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"基于接口而非实现编程 在软件开发中，最大的挑战之一就是需求的不断变化，因此，开发时一定要具有抽象意识、封装意识、接口意识。 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。 这个时候，接口的存在就非常必要了，通过使用接口定义实现类的协议，将约定和实现分离，做到了解耦的效果。 在定义接口的时候，一些注意事项就是：命名一定要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现相关的方法不要定义在接口中。 通常，越是不稳定的系统，越是要在代码的扩展性、维护性上下功夫。相反，某个系统特别稳定，在开发完成之后，基本不需要做维护，则没有必要为其扩展性、维护性投入不必要的开发时间。 ","date":"2022-08-08","objectID":"/posts/programming-pattern/base-interface-not-implementation.html:4:0","tags":["设计模式","面向对象"],"title":"基于接口而非实现编程","uri":"/posts/programming-pattern/base-interface-not-implementation.html"},{"categories":["程序设计"],"content":"面向对象是一种软件开发的编程范式。其概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD 技术、人工智能等领域。 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:0:0","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"面向对象 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:1:0","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"面向对象编程 面向对象编程（Object Oriented Programming, OOP）是一种编程范式或编程风格，它以类或对象作为组织代码的基本单元，并以封装、继承、多态这三个特性作为代码设计和实现的基石。 面向对象的类是描述了一组有相同特征（属性）和相同行为（方法）的一组对象的集合；对象是类的一个实例，拥有自己的状态和行为。 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:1:1","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"面向对象编程语言 面向对象编程语言（Object Oriented Programming Language, OOPL）是支持以类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的三大特性（封装、继承、多态）的编程语言。 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:1:2","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"面向对象编程设计和分析 面向对象分析（Object Oriented Analysis, OOA）就是要搞清楚是什么、为什么要做。 面向对象设计（Object Oriented Design, OOD）就是要搞清楚由谁来做、什么时候做、在哪里做、怎么做、做到怎样的程度。 设计和分析就是一个将想法付诸于实际的过程，因此，其中的每一步都非常重要，影响到程序这项工程的维护。 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:1:3","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"面向对象的优点 面向对象程序设计有以下优点： 可重用性：代码重复可用，减少代码量，提高开发效率 可扩展性：新的功能可以很容易地加入到系统中来，便于软件的修改 可管理性：能够将功能和数据结合，方便管理 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:1:4","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"核心特性 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:2:0","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"封装 封装的含义 封装也叫作信息隐藏或数据访问保护。详细地说，就是数据被保护在抽象数据类型的内部，尽可能对外隐藏内部的细节，只保留一些统一的方法供外部使用。 比如说，对于一个钱包类，里面有余额、币种这两个属性，通常是不允许外部直接更新余额或者直接更新币种，而是仿照现实交易的找补零钱的方式，对外提供一个找补零钱的方法，在这个方法中根据提供的参数来更新余额和币种，这样可以保证数据的一致性。 封装的优点 封装具有以下优点： 提高了代码的安全性，阻止外部随意修改，避免造成数据不一致 提高了代码的易用性，简化外部调用，便于扩展和协作 提高了代码的可维护性，封装内部细节，方便修改内部代码 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:2:1","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"继承 继承的含义 继承指的是子类拥有父类的全部特征和行为，用来表示类之间 is-A 的关系。 比如说，汽车是一种交通工具，汽车会有交通工具的一些特性和功能，交通工具狭义上指一切人造的用于人类代步或运输的装置，汽车就属于这类工具中的一种。 单继承和多继承 从继承的多向性来讲，继承可分为两种模式：单继承和多继承。 单继承表示一个子类只能继承一个父类，多继承表示一个子类可以继承多个父类。从现实世界的角度上看，多继承更符合现实，比如说，猫既是哺乳动物，又是爬行动物。 但是，从软件开发的角度上看，单继承的优点在于层次结构清晰，设计上更容易把握；多继承可以让子类具备多个父类的特征，拥有更丰富的方法，但是多继承会出现菱形继承的问题。 简单地理解菱形继承就是，假设子类 B 和子类 C 都继承自父类 A，且都重写了父类 A 中的方法 func，而孙子类 D 同时继承了子类 B 和子类 C，对于方法 func 而言，孙子类 D 会出现歧义。 继承的优缺点 继承最大的好处就是代码复用，子类可以直接重用父类中的代码，避免代码重复写多遍。 但是过度地使用继承会导致代码可读性、可维护性变差，有可能出现“父类、父类的父类……”的代码。 通常，可以在层次简单、关系不复杂的时候使用继承，反之使用组合代替继承。 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:2:2","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"多态 多态的含义 多态指的是为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。 通过继承实现 多态可以通过继承的方式实现，子类继承父类之后，并重写了父类的方法，在初始化子类的对象时，可以将对象定义为父类的数据类型，这时的对象调用的会是重写后的子类方法。 如下述代码所示： package cn.fatedeity.designpattern.polymorphism; /** * 通过继承实现多态 */ public class ExtendCase { private static void test(Base base) { System.out.println(base.getSize()); } public static void main(String[] args) { Base baseAddOne = new BaseAddOne(); // 1 test(baseAddOne); Base baseAddTwo = new BaseAddTow(); // 2 test(baseAddTwo); } } class BaseAddTow extends Base { @Override public int getSize() { return this.size + 2; } } class BaseAddOne extends Base { @Override public int getSize() { return this.size + 1; } } class Base { protected int size = 0; public int getSize() { return size; } } 通过接口实现 多态还可以通过接口的方式实现，当接口被实现之后，在初始化实现类的对象时，可以直接将这个对象定义为接口类型，这时的对象调用的会是实现类的方法。 如下述代码所示： package cn.fatedeity.designpattern.polymorphism; /** * 通过接口实现多态 */ public class ImplementsCase { private static void test(InterfaceBase base) { System.out.println(base.toString()); } public static void main(String[] args) { InterfaceBase interfaceOne = new InterfaceOne(); // This is InterfaceOne test(interfaceOne); InterfaceBase interfaceTwo = new InterfaceTow(); // This is InterfaceTwo test(interfaceTwo); } } class InterfaceTow implements InterfaceBase { @Override public String toString() { return \"This is InterfaceTwo\"; } } class InterfaceOne implements InterfaceBase { @Override public String toString() { return \"This is InterfaceOne\"; } } interface InterfaceBase { String toString(); } 通过鸭子类型实现 所谓的鸭子类型，指的是只关心事物的外部行为而非内部结构，即不关心对象是什么类型，只关心该对象是否拥有指定方法。 通过鸭子类型实现多态更加灵活，不需要类之间有继承、接口实现的关系，只需要它们同时定义了相同的方法即可。如下述的 Python 代码所示： class Logger: def record(self): print('I write a log into file.') class DB: def record(self): print('I insert data into db.') def test(recorder): recorder.record() def demo(): logger = Logger() # I write a log into file. test(logger) db = DB() # I insert data into db. test(db) 多态的意义 对于第一个例子的代码，仅用一个 test() 方法即可测试 Base 类的子类，即使要新增一个 BaseAddThree 子类，同样不需要更改 test() 方法，仅需重写自己的 getSize() 方法即可，这里提高了代码的扩展性。 同样的，仅用一个 test() 即可完成所有的测试，而不需对每一个子类都写一遍测试代码，这里显然提高了代码的复用性。 除此之外，多态还是很多设计模式、设计原则、编程技巧的代码实现基础。 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:2:3","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"面向对象和面向过程 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:3:0","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"为什么使用面向对象而不是面向过程？ 面向过程是一种流程化的思维模式，面向对象是一种自底向上的抽象化的思维模式。 相比之下，面向对象有以下优势： 面向对象编程更加能够应对大规模复杂程序的开发，它提供了一种清晰的、模块化的代码组织方式 面向对象编程的的三大特性提高了代码的易维护性、扩展性、复用性，并且大部分设计模式都以面向对象为基础 面向对象编程语言更加人性化、更加高级、更加智能，面向过程的流程化是一种计算机思维方法，而面向对象的抽象化是一种人类思维方法 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:3:1","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"违反面向对象编程风格的典型代码设计 滥用 setter() 方法和 getter() 方法使封装失去作用 定义大而全的 Constants 类、Utils 类也破坏了封装特性 MVC 模式是基于贫血模型的开发模式，数据和操作分开，是彻底的面向过程编程风格 ","date":"2022-08-04","objectID":"/posts/programming-pattern/object-oriented-basic.html:3:2","tags":["设计模式","面向对象"],"title":"面向对象的基础知识","uri":"/posts/programming-pattern/object-oriented-basic.html"},{"categories":["程序设计"],"content":"作为一个开发人员，都想写出一手好的代码，而不是别人称的“屎山”，设计模式提供了一系列常见问题的解决方案，通过利用设计模式来尽可能统一规范，可以提高代码的可维护性、可读性、可扩展性。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:0:0","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"概念基础 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:1:0","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"经典定义 模式起源于建筑业而非软件业，下面是最早研究模式的 Christopher Alexander 博士对模式下的定义： A pattern is a successful or efficient solution to a recurring problem within a content. 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。 在软件业当中，最经典的设计模式研究人员莫过于“四人组”（GoF），他们对设计模式的定义如下： Design patterns are descriptions of comminicating objects and classes that are customized to solve a general design problem in a particular context. 设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:1:1","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"设计模式结构 设计模式是和数据结构与算法同层次的知识点，利用数据结构与算法可以写出高效的代码，利用设计模式可以写出可扩展、可读、可维护的高质量代码。 在软件业当中，设计模式也可以看作是软件模式中的一部分，负责优化编码、实现高质量代码的一部分。 设计模式和软件模式类似，基本结构主要由 4 个部分构成： 模式名称：简易描述模式的问题呈现、解决方案或实现效果 问题呈现：描述何时使用模式，包含了设计中存在的问题以及问题存在的原因 解决方案：描述组成成分以及这些组成成分之间的相互关系、各自的职责和协作方式 实现效果：应用模式之后的效果以及在使用模式时应权衡的问题 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:1:2","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"目的和优点 掌握设计模式之后，在以下场景的作用非常大： 使用设计模式作为编码标准，能方便开发过程中的沟通和交流 面对复杂代码、功能、系统的设计和开发，也能够得心应手、游刃有余 利用设计模式编写好的代码，可以在团队中脱颖而出，告别被别人吐槽代码写得烂 优秀的开源项目会使用很多设计原则、设计模式或设计思想，熟悉这些可以在阅读代码时更轻松 面试时会有问设计模式的情况，掌握设计模式可以轻松应对 职业发展到更高级的工程师，代码的质量影响着日常开发，作为面试官也需要了解 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:1:3","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"评价编码质量 学习设计模式就是为了提高代码的质量，在学习设计模式之前，应当先了解编码质量的概念和评价标准。 代码质量是一个综合各种标准得到的结论，不能通过单一的维度去评价一段代码写得好坏。即使是可扩展性非常好的代码，但是可读性非常差，并不能评价这段代码质量高。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:2:0","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"如何评价 对编码质量的常见评价标准非常多，而它们又存在着包含、重叠、相互影响的关系，如一段代码的可读性、可扩展性非常好，也意味着这段代码的可维护性非常好。 在日常开发中，通常是无法客观地去评价代码的质量高低，对于同一段代码，高级开发工程师可能觉得可读性非常好，而初级开发工程师就会觉得难以阅读，他们的评价标准肯定是不一样的。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:2:1","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"评价标准 代码质量的评价词语非常多，但使用时应尽量避免过于抽象或过于细节的评价，尽量使用较为精准的词语。 如下是常用的几个评价标准： 可维护性 (maintainability)：指的是可以在不破坏原有设计、不引入新 bug 的前提下快速修改或者添加代码 可读性 (readability)：通过看代码是否符合编码规范、命名是否达意、注释是否详尽、模块划分是否清晰、是否符合高内聚低耦合等等 可扩展性 (extensibility)：指的是在不修改或少量修改原有代码的前提下，通过扩展的方式添加新的功能代码 简洁性 (simplicity)：代码要尽量简单，逻辑清晰，这样可以使得代码易读、易维护 可复用性 (reusability)：尽量减少重复代码的编写，复用已有的代码，解耦、高内聚、模块化都能提高代码的可复用性 可测试性 (testability)：代码可测试性的好坏，能从侧面上非常准确地反映代码质量的好坏 其中可维护性、可读性、可扩展性是最重要的三个评价标准。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:2:2","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"内聚、耦合 内聚指的是一个模块内部各成分之间相关联程度的度量。所谓高内聚，就是相近的功能应该放在一个模块内，不相近的功能不要放在一个模块内。 耦合指的是两个模块之间的关联程度。所谓松耦合指的是，两个模块之间的依赖关系简单清晰，即使两个模块有依赖关系，一个模块的改动不会或者很少影响到另一个模块。 高内聚和松耦合通常是一起出现的，高内聚有助于松耦合，松耦合又需要高内聚的支持。高内聚和松耦合的程序在可维护性、可读性、可扩展性上都会好很多。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:2:3","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"高质量编码 要想编写高质量的代码，可以从设计风格、设计原则、设计模式、编程规范、重构技巧等等方向着手。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:3:0","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"设计风格 现在主流的编程风格分为三种：面向过程、面向对象、函数式编程。 面向对象编程是其中相对流行的风格，而且大部分的设计原则、设计模式都是基于面向对象编程实现的。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:3:1","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"设计原则 设计原则可以指导代码设计，它们都非常抽象，通常是在开发时给予指导意义。 常见的设计原则有 SOLID 原则、DRP 原则、KISS 原则、YAGNI 原则、LOD 原则等。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:3:2","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"设计模式 大部分设计模式解决的是代码的可扩展性问题。 在设计模式领域，狭义的设计模式就是指 GoF 的《设计模式：可复用面向对象软件设计的基础》一书中包含的 23 种经典的设计模式。 这 23 种设计模式根据目的（模式是用来做什么的）可分为 3 种类型：创建型、结构型、行为型： 创建型设计模式主要解决“对象的创建”问题 结构型设计模式主要解决“类或对象的组合或组装”问题 行为型设计模式主要解决“类或对象之间的交互”问题 按照我自己对这些设计模式的理解程度对设计模式做排序，它们的详细分类如下： 创造型设计模式：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式 结构型设计模式：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式 行为型设计模式：解释器模式、模板方法模式、职责链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:3:3","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"编程规范 编程规范已经深入到编码当中，是一种更具体的解决代码可读性问题的方法。 编程规范更注重代码细节，比如，如何给变量、类、函数命令，如何写代码注释，函数不宜过长、参数不宜过多等。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:3:4","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["程序设计"],"content":"重构技巧 重构是代码开发中非常重要的一个环节，持续重构是保持代码质量不下降的有效手段。 其实重构已经不算是方法论了，而是一种行为，通常重构是基于设计风格、设计原则、设计模式、编程规范这些理论才能做得更好。 ","date":"2022-07-28","objectID":"/posts/programming-pattern/design-pattern-basic.html:3:5","tags":["设计模式","面向对象"],"title":"设计模式的基础知识","uri":"/posts/programming-pattern/design-pattern-basic.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数。 算法的时间复杂度应该为 $O(log (m+n))$。 ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:1:0","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:2:0","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"示例 1 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:2:1","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"示例 2 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:2:2","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"提示 nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -10^6 \u003c= nums1[i], nums2[i] \u003c= 10^6 ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:2:3","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:3:0","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"归并法 最先想到的解题方法就是，将两个有序数组合并成一个有序数组，然后再对结果集计算中位数。这种方法算是一个比较直接的思路。 但是，合并两个数组是此方法最耗时的操作，并且达到 $O(m+n)$ 的时间复杂度，因此，并不符合题目中算法时间复杂度达到 $O(log (m+n))$ 的要求。 而且，采用此方法的空间复杂度，也达到了 $O(m+n)$ 的程度，其空间占用也不算优。 package cn.fatedeity.algorithm.leetcode; public class MedianOfTwoSortedArrays { public double answer(int[] nums1, int[] nums2) { int i = 0, j = 0; int[] numbers = new int[nums1.length + nums2.length]; int index = 0; while (i \u003c nums1.length || j \u003c nums2.length) { if (i == nums1.length) { for (int k = j; k \u003c nums2.length; k++) { numbers[index++] = nums2[k]; } break; } else if (j == nums2.length) { for (int k = i; k \u003c nums1.length; k++) { numbers[index++] = nums1[k]; } break; } if (nums1[i] \u003c nums2[j]) { numbers[index++] = nums1[i++]; } else if (nums2[j] \u003c nums1[i]) { numbers[index++] = nums2[j++]; } else { numbers[index++] = nums1[i++]; numbers[index++] = nums2[j++]; } } if ((numbers.length \u0026 1) == 0) { // 数组长度是偶数 int mid = numbers.length \u003e\u003e 1; return (numbers[mid - 1] + numbers[mid]) / 2f; } else { return numbers[numbers.length \u003e\u003e 1]; } } } ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:3:1","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["LeetCode"],"content":"双指针 面对两个数组，也可以采用双指针的方式，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知。 基本思路就是，通过双指针将两个数组中较小的值一个一个地过滤掉，直到过滤到中位数的下标位置，即可得到两个数组的中位数。 整个方法相较归并法更优，空间复杂度直接降到了 $O(1)$ 的程度，在运行效率上，其只循环了 $\\frac{m+n}2$ 次，但时间复杂度仍然是 $O(n)$，未达到题目中 $O(log (m+n))$ 的要求。 package cn.fatedeity.algorithm.leetcode; public class MedianOfTwoSortedArrays { public double answer(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; int len = m + n; int mStart = 0, nStart = 0; int left = 0, right = 0; for (int i = 0; i \u003c= len \u003e\u003e 1; i++) { left = right; if (mStart \u003c m \u0026\u0026 (nStart \u003e= n || nums1[mStart] \u003c nums2[nStart])) { right = nums1[mStart++]; } else { right = nums2[nStart++]; } } if ((len \u0026 1) == 0) { return (left + right) / 2f; } else { return right; } } } ","date":"2022-07-27","objectID":"/posts/leetcode/median-of-two-sorted-arrays.html:3:2","tags":["数组","二分查找","分治"],"title":"LeetCode - 寻找两个正序数组的中位数","uri":"/posts/leetcode/median-of-two-sorted-arrays.html"},{"categories":["数据结构与算法"],"content":"学习任何东西，都需要深究其底层，掌握其思想，融会贯通才能应万变。对于算法而言，同样如此，编程的算法题千千万，刷题是刷不完的，还是需要掌握算法的思想才能掌握如何求解算法题。 最经典的算法思想有以下几种： 贪心算法：每一步都采用最优的选择，从而希望结果是最好的 分治算法：将原问题拆分成多个结果类似的子问题，递归解决后再合并其结果 回溯算法：类似于试探性枚举搜索，用于指导深度优先搜索这样的经典算法 动态规划：优化自顶向下的重复子问题，自底向上地推算出问题的最优解 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:0:0","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"贪心算法 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:1:0","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"理论 贪心算法是一种在每一步选择当中都采取当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。 贪心算法在有最优子结构的问题中尤为有效，简单地说，就是问题能够分解成子问题来解决，子问题的最优解就能递推到最终问题的最优解。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:1:1","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"细节 创建数学模型来描述问题； 把问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的局部最优解合并成原来问题的一个解。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:1:2","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"案例 对于零钱的问题：假设有 25 分、10 分、5 分、1 分这 4 种硬币，现在要从中取出 41 分钱的硬币，并且要求硬币的个数最少。 通过贪心算法，我们每次都拿出最大额度的硬币，直到此额度超过了所需的额度。详细的过程如下： 对于 41 分钱，拿出 25 分的硬币，此时还差 16 分钱，25 分的硬币超过了所需的额度，自然需要往更优、更小的额度去取； 对于 16 分钱，拿出 10 分的硬币，此时还差 6 分钱，10 分的硬币超过了所需的额度，自然需要往更优、更小的额度去取； 对于 6 分钱，拿出 5 分的硬币，此时还差 1 分钱，5 分的硬币超过了所需的额度，自然需要往更优、更小的额度去取； 对于 1 分钱，拿出 1 分的硬币，此时还差 0 分钱； 最终，41 分钱拆分成了 1 个 25 分、1 个 10 分、1 个 5 分、1 个 1 分，总共 4 个硬币。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:1:3","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"分治算法 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:2:0","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"理论 分治算法字面上的解释是“分而治之”，就是把一个复杂的问题拆分成两个或多个相同或相似的子问题，再把子问题拆分成更小的子问题……直到最后子问题可以简单地求解，原问题的解即子问题的解的合并。 在广义的定义下，所有递归或循环的算法均被视为“分治算法”，也有只将具有最少两个子问题的算法作为“分治算法”。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:2:1","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"细节 在每一层递归上都有三个步骤： 分解：将原问题分解成若干个规模较小，相对独立，与原问题形式相同的子问题； 解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题； 合并：将各子问题的解合并为原问题的解。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:2:2","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"案例 分治算法最让人熟知的应用案例就是归并排序，以下归并排序的部分代码能一一对应分治算法的细节步骤： void merge_sort(int array[], unsigned int first, unsigned int last) { int mid = 0; if (first \u003c last) { mid = (first + last) / 2; merge_sort(array, first, mid); merge_sort(array, mid + 1,last); merge(array,first,mid,last); } } 在 merge_sort() 函数中，将原本一个序列的排序问题从中间位置拆分成了两个子序列的的排序问题： 对 first 到 mid 的子序列排序； 在对 mid+1 到 last 的子序列排序； 并且是递归调用 merge_sort() 进行排序，最终将两个有序子序列合并。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:2:3","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"回溯算法 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:3:0","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"理论 回溯算法是一种择优选择的算法思想，又称为试探法，按择优条件向前搜索，以达到目标。 将回溯算法映射到一个现实的例子就是：在迷宫当中，通过选择不同的岔路口寻找出口，一个岔路口一个岔路口地去尝试找到出口，如果在中途走错了路，则返回到岔路口的另一条路，直到找到出口。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:3:1","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"细节 用回溯算法解决问题的一般步骤： 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解； 确定易于搜索的解空间结构，使得能用回溯法方便地搜索整个解空间； 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:3:2","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"案例 在 8 x 8 的棋盘上，每一个空格可以放一个皇后，皇后可以攻击与它同行、同列或同一斜线的其他皇后，在该棋盘上摆放 8 个皇后，使其不能互相攻击。这就是“八皇后”问题，该问题就是典型的回溯算法案例， 对于一个 4 x 4 的棋盘结构，应该叫作“四皇后”问题，下述树形结构是其解题思路： 上图就是一个回溯算法的思路，即先在第一行放置一个皇后，然后再试探性地再第二行放置一个皇后，以此类推，如果出现不满足要求的情况，则及时止损，返回上一行继续试探性地选择不同的方案，直到所有的方案都被列举出来位置。 这里说的回溯算法有点像是穷举法，其实它们是有点类似的，对于像“八皇后”问题需要所有解答时就可以将回溯算法认为是试探性穷举法。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:3:3","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"动态规划 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:4:0","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"理论 动态规划的思想是，若要解决一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 在各种场景中，动态规划在对重复子问题求最优解时非常有效。其使用的方法是，在求解的过程中将子问题的结果存储下来重复利用，从简单的问题直到整个问题都被解决。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:4:1","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"细节 使用动态规划优化算法，基本上遵循一个固定的流程： 递归的暴力破解：将一个问题拆解成子问题，使用递归的思路解决问题； 带备忘录的递归解法：在递归的过程中，将子问题的结果存储下来重复利用，减少时间耗费； 非递归的动态规划解法：遵循自底向上的推算思路，将递归转换成非递归的循环解法。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:4:2","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["数据结构与算法"],"content":"案例 如果想要求解斐波那契数列，使用递归的思路非常简单，只要推算出递归的入口即可。 当想要优化的时候，也可以使用备忘录存储中间结果集，当然，对于求解斐波那契数列，此优化思路提升得并不多。 引入动态规划的思路之后，自底向上求解斐波那契数列的思路就会有点与众不同，如下是求解的代码： int fib(int N) { vector\u003cint\u003e dp(N + 1, 0); dp[1] = dp[2] = 1; for (int i = 3; i \u003c= N; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[N]; } 其实，拿求解斐波那契数列的例子来说明并不能展现出动态规划的优势，但却能展示出从一个递归算法改成动态规划算法的过程。 ","date":"2022-07-25","objectID":"/posts/data-structure-algorithm/classical-algorithm-thought.html:4:3","tags":["算法","思维"],"title":"四大经典算法思想","uri":"/posts/data-structure-algorithm/classical-algorithm-thought.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：整数反转 给你一个 32 位的有符号整数 x，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31 − 1]，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:1:0","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:2:0","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"示例 1 输入：x = 123 输出：321 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:2:1","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"示例 2 输入：x = -123 输出：-321 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:2:2","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"示例 3 输入：x = 120 输出：21 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:2:3","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"示例 4 输入：x = 0 输出：0 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:2:4","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"提示 -2^31 \u003c= x \u003c= 2^31 - 1 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:2:5","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:3:0","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"投机取巧 假设这道题目没有 环境不允许存储 64 位整数（有符号或无符号） 的限制，其实问题很容易解决，只需要将数字转换成正整数，然后从个位开始反转，最后再根据原始整数的符号来设定结果整数的符号。 这种方法的缺陷就是，当数字较大时，需要使用到 64 位整数变量存储结果整数，这样肯定是不符合题目要求了，可以称之为投机取巧。 package cn.fatedeity.algorithm.leetcode; public class ReverseInteger { public int answer(int x) { long reverse = 0; int rest = Math.abs(x); while (rest \u003e= 10) { reverse = reverse * 10 + rest % 10; rest = (int) (rest / 10.0); } reverse = reverse * 10 + rest; if (x \u003c 0) { reverse = -reverse; } if (reverse \u003c Integer.MIN_VALUE || reverse \u003e Integer.MAX_VALUE) { return 0; } return (int) reverse; } } ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:3:1","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"预判超量 这里的思路仍然是将数字从个位一点点转换成结果整数，与投机取巧不同的是，需要预判结果整数是否超过了 32 位的有符号位整数。 package cn.fatedeity.algorithm.leetcode; public class ReverseInteger { public int answer(int x) { int reverse = 0; while (x != 0) { // -2147483648 and 2147483647 if (reverse \u003c Integer.MIN_VALUE / 10 || reverse \u003e Integer.MAX_VALUE / 10) { return 0; } reverse = reverse * 10 + x % 10; x /= 10; } return reverse; } } 可能有人疑惑，为什么中途判断的时候只需要是 $\\frac{1}{10}$ 即可，不需要再将 x % 10 的值算上。 其根本原因还是，给定的整数范围是 [-2147483648, 2147483647]，在这个范围内，给定整数最高位只能是 2，得到的结果集最高位却支持到 7，因此，个位上的比较也就不重要了。 ","date":"2022-07-22","objectID":"/posts/leetcode/reverse-integer.html:3:2","tags":["数学"],"title":"LeetCode - 整数反转","uri":"/posts/leetcode/reverse-integer.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：回文数 给你一个整数 x，如果 x 是一个回文整数，返回 true；否则，返回 false。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:1:0","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:2:0","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"示例 1 输入：x = 121 输出：true ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:2:1","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"示例 2 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:2:2","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"示例 3 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:2:3","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"提示 -2^31 \u003c= x \u003c= 2^31 - 1 ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:2:4","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:3:0","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"双指针 比较简单的思路就是，先将整数转换成字符串，然后使用首尾双指针判断所指位置的字符是否相同，直到所有的字符都被比较完毕。 如上图所示，使用双指针是比较直观的一个思路，需要注意的就是，负整数都不是回文数，奇数和偶数在做回文判断时有区别。 package cn.fatedeity.algorithm.leetcode; public class PalindromeNumber { public boolean answer(int x) { if (x \u003c 0) { return false; } // 转成字符串 String s = Integer.toString(x); // 双指针判断 int len = s.length(); for (int i = 0; i \u003c len \u003e\u003e 1; i++) { if (i != len - 1 - i \u0026\u0026 s.charAt(i) != s.charAt(len - 1 - i)) { return false; } } return true; } } ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:3:1","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"不转换成字符串 如果给这道题目加上不能将整数转换为字符串的限制，就需要在数学的角度上去思考其解决方案。 既然是想要判断整数是否是回文，则可以直接将整数翻转成另一个整数，再将这两个整数做相等匹配，此方法的循环次数相比双指针更多，但却没有整数转换成字符串的耗时，整数效率更高一些。 package cn.fatedeity.algorithm.leetcode; public class PalindromeNumber { public boolean answer(int x) { if (x \u003c 0) { return false; } // 将整数进行翻转 int reverse = 0; int rest = x; while (rest \u003e= 10) { reverse = reverse - 10 + rest % 10; rest = (int) (rest / 10.0); } return reverse - 10 + rest == x; } } ","date":"2022-07-20","objectID":"/posts/leetcode/palindrome-number.html:3:2","tags":["数学"],"title":"LeetCode - 回文数","uri":"/posts/leetcode/palindrome-number.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：无重复字符的最长子串 给定一个字符串 s，请你找出其中不含有重复字符的 最长子串 的长度。 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:1:0","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:2:0","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"示例 1 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:2:1","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"示例 2 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:2:2","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"示例 3 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:2:3","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"限制 0 \u003c= s.length \u003c= 5 - 10^4 s 由英文字母、数字、符号和空格组成 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:2:4","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:3:0","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["LeetCode"],"content":"滑动窗口 滑动窗口是一种比较重要的算法思想，常用与解决线性表结构数据的子序列问题，运用之后可以将双层嵌套循环的问题转换为单层循环的问题，降低时间复杂度以提高效率。 这道题目的基本思想是将字符串理解成一个滑动的窗口，然后将这个窗口在这个字符串上滑动，在窗口滑动的过程中，左边会出一个元素，右边会进一个元素，然后只需要计算当前窗口内的元素值即可。 package cn.fatedeity.algorithm.leetcode; import java.util.HashMap; public class LongestSubstringWithoutRepeatingCharacters { public int answer(String s) { int start = 0; int result = 0; HashMap\u003cCharacter, Integer\u003e hashMap = new HashMap\u003c\u003e(); for (int current = 0; current \u003c s.length(); current++) { char c = s.charAt(current); if (hashMap.containsKey(c)) { start = Math.max(hashMap.get(c) + 1, start); } hashMap.put(c, current); result = Math.max(current - start + 1, result); } return result; } } ","date":"2022-07-18","objectID":"/posts/leetcode/longest-substring-without-repeating-characters.html:3:1","tags":["哈希表","字符串","滑动窗口"],"title":"LeetCode - 无重复字符的最长子串","uri":"/posts/leetcode/longest-substring-without-repeating-characters.html"},{"categories":["折腾日志"],"content":"本来博客部署在 CloudBase 也挺好，没有什么访问量的博客一个月也花不了几毛钱，在这个上面基本是无感了。奈何腾讯准备更改 CloudBase 的计费模式，为了省那一点钱，还是将博客迁移到自己的服务器上吧。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:0:0","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"迁移起因 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:1:0","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"原来的博客 其实从很久以前就想要写博客，但总是断断续续的，一直都没有认真地开始。 最终，决定使用静态博客工具作为自己博客的承载体。在多种工具的比较下，最终选择了 Hugo 并部署到 Github Pages 上，并同时部署到腾讯云的 CloudBase 以供国内用户访问。 自此，2022 年 5 月 15 日，程序员翔仔 终于部署到公网上了。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:1:1","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"出现了变故 但是，才经过大概 2 个月的时间，收到了腾讯云发送的 CloudBase 计费模式变更的消息。 简单来说，CloudBase 出了一个最低消费，像我这样的，原本从几毛钱的无感消费要升级到几十块，这个变动对于我来说还是挺大的。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:1:2","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"思路变更 此处要赶爷，爷自有去处。 突然想到，曾经自己用 299 买的云服务器一直荒废没有使用，毕竟还有好几个月的期限呢，一定要利用起来。 就决定是你了，我的博客暂时先放置在云服务器上，顺便了解一下如何部署静态博客到云服务器上。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:1:3","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"第一版方案 不可否认，现在流行的自动化部署真的是用一次就爱上了，尤其是，还有 Github Action 这样的免费资源可以薅，哈哈哈。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:2:0","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"Github Pages 部署 将 Hugo 通过 Github Action 部署到 Github Pages 非常简单，在网上也有很多教程可用，这里就简单地列举一下吧。 第一步，通常就是要建立一个私有库存储博客的源文件，再建立一个 Github Pages 库存储 Hugo 构建后的文件。 第二步，自然就是在 Hugo 博客项目下编写 workflow 文件，这里有使用到 Checkout、Hugo setup、GitHub Pages action 三种 Action 步骤，当时的配置如下： on: push: branches: - master pull_request: jobs: deploy: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v3 # 安装 Hugo 程序 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true # Hugo Build - name: Build run: hugo --minify --gc # 部署到 Github Pages 上 - name: Deploy Github Pages uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/master' }} with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: fatedeity/fatedeity.github.io publish_branch: master cname: fatedeity.cn 在这一步，需要配置一个 Actions secrets 以解决安全性问题，可以通过 GitHub Pages action 了解更多。 经过上述两个配置步骤，基本上是已经完成了，之后 Hugo 博客文件再 push 到 Github 时就会自动触发部署，期间基本上能在 20s 左右完成。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:2:1","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"CloudBase 部署 使用 Github Action 部署 Github Pages 非常简单，毕竟也算是同出一家，基本上不会出现什么问题。 因为想要通过部署到 CloudBase 以加速国内 IP 访问博客的速度，也不得不研究一下怎么通过 Github Action 部署到 CloudBase 上。 仔细查找了一下，基本上就两种方案：通过 CloudBase CLI 使用命令行部署；通过官方提供的 Tencent CloudBase Github Action 工具部署。 最终，决定使用 Action 工具，相信与 Github Action 更配（实际操作起来并没有 😳），下面是简单的一个配置步骤： 第一步，添加 CloudBase Action v2 所需的配置文件，由于我只使用了 CloudBase 的静态博客部署，配置起来也不麻烦，主要是需要在项目根目录下创建 cloudbaserc.json 文件，填入以下配置： { \"envId\": \"{{ENV_ID}}\", \"region\": \"ap-guangzhou\", \"$schema\": \"https://framework-1258016615.tcloudbaseapp.com/schema/latest.json\", \"framework\": { \"name\": \"hugo-blog\", \"plugins\": { \"client\": { \"use\": \"@cloudbase/framework-plugin-website\", \"inputs\": { \"outputPath\": \"public\", \"cloudPath\": \"/\" } } } } } 第二步，更新之前的 workflow 文件，将 Cloudbase Action 的步骤配置进去，当时的配置如下： on: push: branches: - master pull_request: jobs: deploy: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v3 # 安装 Hugo 程序 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true # Hugo Build - name: Build run: hugo --minify --gc # 部署到 CloudBase 上 - name: Deploy Tencent CloudBase uses: TencentCloudBase/cloudbase-action@v2.0.1 if: ${{ github.ref == 'refs/heads/master' }} with: secretId: ${{ secrets.SECRET_ID }} secretKey: ${{ secrets.SECRET_KEY }} envId: ${{ secrets.ENV_ID }} 通过上述的步骤，基本上也算是完成了 Github Action 到 CloudBase 的配置。 但是，使用起来并不是很顺利，经常性地出现 Github Action 运行超时的情况，应该是 Github Action 机器在美国，而 CloudBase 服务器在国内的原因。 当时也没有找到什么好的解决办法，只能通过每次报失败之后再手动去运行一遍（从自动化部署变成了半自动化 😆）。 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:2:2","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"第二版方案 ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:3:0","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"云服务器部署 将项目部署到自己的云服务器上，方法就变得更多了，既有使用 SSH Remote Commands 通过 ssh 工具运行命令，也有使用 SCP、Rsync、SFTP 等工具将文件直接上传，还有更多其他的办法等等。 对比之后，还是采用了理解起来最简单的办法，通过 SSH Remote Commands 连接到云服务器上执行命令，这个命令也很容易理解，就是通过 Git 命令拉取 Github Pages 的代码。 第一步，先在云服务上做好准备，安装好 Git 程序，确定能手动拉取到 Github Pages 的代码。 第二步，当然还是要更新 workflow 文件，将 SSH Remote Commands Action 的步骤替换掉原来的 CloudBase Action 的步骤，具体的配置如下： on: push: branches: - master pull_request: jobs: deploy: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v3 # 安装 Hugo 程序 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true # Hugo Build - name: Build run: hugo --minify --gc # 部署到 Github Pages 上 - name: Deploy Github Pages uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == 'refs/heads/master' }} with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: fatedeity/fatedeity.github.io publish_branch: master cname: fatedeity.cn # 部署到 Server 上 - name: Deploy Tecent Server uses: appleboy/ssh-action@master with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} key: ${{ secrets.KEY }} port: ${{ secrets.PORT }} script: rm -rf fatedeity.github.io/ \u0026\u0026 git clone https://ghproxy.com/https://github.com/fatedeity/fatedeity.github.io.git \u0026\u0026 rm -rf fatedeity.github.io/.[!.]* 这里有个小技巧，将 Github 通过 GitHub Proxy 代理加速 访问，原本比较慢的拉取代码步骤变得飞快，综合下来，这个静态博客部署完成只需花费 30ms 左右的时间。 第三步，代码被自动拉取到服务器上之后，还需要配置一个反向代理的服务器以供外网访问。最常用的自然就是 Nginx 服务器了，安装 Nginx 的步骤就直接忽略吧，下面是我这边访问静态博客的反向代理配置： log_format main escape=json '{\"remote_addr\":\"$remote_addr\",\"timestamp\":\"$time_iso8601\",\"request\":\"$request\",\"size\":$body_bytes_sent,\"status\":$status,\"request_time\":$request_time,\"referer\":\"$http_referer\",\"user_agent\":\"$http_user_agent\"}'; server { listen 80; listen [::]:80; server_name fatedeity.cn; return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; server_name fatedeity.cn; # 证书 ssl_certificate cert/fatedeity.cn_bundle.crt; # 私钥 ssl_certificate_key cert/fatedeity.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { root /home/fatedeity/fatedeity.github.io/; index index.html; } error_page 404 /404.html; access_log /var/log/nginx/hugo-blog-access.log main; } ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:3:1","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["折腾日志"],"content":"日志统计 经过上述的操作记录，基本就完成了 Hugo 到 Github Pages 和 Cloud Server 的配置，其实到这里也就结束了。 但是，突然想要看一下自己服务器的访问量，之前都没有搞过这些东西，都是在公司有现成的工具可以使用。发现自己的服务器配置并不是很高，搞不来 ELK 那一套，只能另辟蹊径。 还好，简单一搜，发现有 GoAccess 这样的开源实时日志工具可用，非常适合我这样简单看看日志的用户。 第一步，自然就是安装 GoAccess 工具啦，也很简单，使用 apt install goaccess 命令安装一下即可。 第二步，配置好 .goaccessrc 文件，我这边的配置很简单，只是需要配置好日志格式、输入输出文件即可： time-format %H:%M:%S date-format %Y-%m-%d log-format %^:\"%h\",%^:\"%dT%t+%^\",%^:\"%r\",%^:%b,%^:%D,%^:\"%R\",%^:\"%u\" log-file /var/log/nginx/hugo-blog-access.log output /home/fatedeity/logs/hugo-blog.html 第三步，这边主要是想要通过浏览器访问一下日志，每次想访问的时候使用下面的命令生成一下，也不麻烦，当然也可以定时更新： goaccess -p /home/fatedeity/.goaccessrc 这样就大功告成了，展示一下 GoAccess 的空页面： ","date":"2022-07-16","objectID":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html:3:2","tags":["博客","服务器","Github"],"title":"博客从 CloudBase 迁移至云主机","uri":"/posts/z-turn/blog-migration-from-cloudbase-to-server.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:1:0","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:2:0","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"示例 1 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807 ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:2:1","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"示例 2 输入：l1 = [0], l2 = [0] 输出：[0] ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:2:2","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"示例 3 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:2:3","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"提示 每个链表中的节点数在范围 [1, 100] 内 0 \u003c= Node.val \u003c= 9 题目数据保证列表表示的数字不含前导零 ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:2:4","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:3:0","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"结点累加 这道题目将两个链表结合成一个链表，比较清晰的思路就是，类似于四则运算中的加法，从个位往高位进行每一位相加，如果当前位的结果大于等于 10 时则需要在高位加 1。 解析到程序当中，既可以使用循环的方式，也可以使用递归的思维。循环的方式是将两个链表同步递增，而递归的方式是每次计算完一位时再对链表的下一个结点做递归处理。 通过循环的方式解决这个问题，时间复杂度是 $O(n)$，空间复杂度也是 $O(n)$，这里的 n 指的是最长的那个链表节点数。 package cn.fatedeity.algorithm.leetcode; public class AddTwoNumbers { public ListNode answer(ListNode l1, ListNode l2) { ListNode result = new ListNode(); ListNode listNode = result; boolean addOne = false; while (l1 != null || l2 != null || addOne) { int sum = 0; if (l1 != null) { sum += l1.val; l1 = l1.next; } if (l2 != null) { sum += l2.val; l2 = l2.next; } if (addOne) { sum += 1; } addOne = sum \u003e= 10; listNode.next = new ListNode(sum % 10); listNode = listNode.next; } return result.next; } } class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } ","date":"2022-07-15","objectID":"/posts/leetcode/add-two-numbers.html:3:1","tags":["递归","链表","数学"],"title":"LeetCode - 两数相加","uri":"/posts/leetcode/add-two-numbers.html"},{"categories":["LeetCode"],"content":"题目信息 源地址：两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:1:0","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"提示信息 ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:2:0","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"示例 1 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:2:1","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"示例 2 输入：nums = [3,2,4], target = 6 输出：[1,2] ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:2:2","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"示例 3 输入：nums = [3,3], target = 6 输出：[0,1] ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:2:3","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"限制 2 \u003c= nums.length \u003c= 10^3 -10^9 \u003c= nums[i] \u003c= 10^9 -10^9 \u003c= target \u003c= 10^9 只会存在一个有效答案 ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:2:4","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"实现逻辑 ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:3:0","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"暴力枚举 最先想到的逻辑肯定是使用双层循环暴力查找。 当然，采用这种方式的时间复杂度是 $O(n^2)$，空间复杂度是 $O(1)$，实际效率是非常地低。 package cn.fatedeity.algorithm.leetcode; public class TwoSum { public int[] answer(int[] nums, int target) { for (int i = 0; i \u003c nums.length; i++) { for (int j = i + 1; j \u003c nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:3:1","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["LeetCode"],"content":"哈希匹配 如果采用“空间换时间”的方法，利用哈希表结构查找时间复杂度为 $O(1)$ 的特性，就可以一次循环快速得到结果。 最终，时间复杂度降到 $O(n)$，空间复杂度则变成 $O(n)$。 package cn.fatedeity.algorithm.leetcode; import java.util.HashMap; public class TwoSum { public int[] answer(int[] nums, int target) { HashMap\u003cInteger, Integer\u003e hashMap = new HashMap\u003c\u003e(); for (int i = 0; i \u003c nums.length; i++) { int diff = target - nums[i]; if (hashMap.containsKey(diff)) { return new int[]{hashMap.get(diff), i}; } hashMap.put(nums[i], i); } return new int[0]; } } ","date":"2022-07-12","objectID":"/posts/leetcode/two-sum.html:3:2","tags":["数组","哈希表"],"title":"LeetCode - 两数之和","uri":"/posts/leetcode/two-sum.html"},{"categories":["数据结构与算法"],"content":"插值查找和二分查找一样，是有序表的一种查找算法，其基于二分查找，将查找点的选择改进为自适应选择，提高查找效率。 ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:0:0","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"详细描述 二分查找是通过折半的方法，每一次都将搜索范围缩小至原来的二分之一，如果这个折半能够实现到折四分之一甚至更多，效率将会更高。 插值查找就是这样的算法，类似于二分查找，插值查找每次会从 自适应 处开始查找，实质上是将 $\\frac1 2$ 处位置的查找公式做了修改： $$ mid = \\frac{low + high}{2} = low + \\frac{1}{2}(high - low) \\Rightarrow mid = low + \\frac{key - a[low]}{a[high] - a[low]}(high - low) $$ 插值查找详细的执行步骤如下： 在有序表中，通过比例公式取对应记录作为比较对象； 若给定值与对应记录的关键字相等，则查找成功； 若给定值小于对应记录的关键字，则在对应记录的左半区继续查找； 若给定值大于对应记录的关键字，则在中间记录的右半区继续查找； 不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:1:0","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:2:0","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"插值查找为什么是 $\\frac{key - a[low]}{a[high] - a[low]}$? 打个比方，在一本英文字典中查找 apple 这个单词的时候，肯定不会从字典中间开始查找，而是从字典开头部分开始翻，因为会觉得这样的找法才是比较快的。 对于一个有序的序列，如果能在查找前较准确的预测关键字在序列中的位置时，这样的查找方法能比二分查找拥有更好的性能。 其中的差值公式 $\\frac{key - a[low]}{a[high] - a[low]}$ 是要将查找的关键字与序列中的最大、最小记录的关键字比较，获取一个相对更准确的位置。 ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:2:1","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"使用插值查找有哪些注意事项？ 对于均匀分布的序列，插值查找的效率是非常快。特别是对于绝对均匀分布的序列（相邻元素差值相同），插值查找可以只做一次比较就查找成功。 对于分布很不均匀的序列，插值查找的计算则会起到反效果，这时候反而不如二分查找。 ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:2:2","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:3:0","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"查找接口 package cn.fatedeity.algorithm.search; public interface Search { int search(int[] numbers, int target); } ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:3:1","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"插值查找类 package cn.fatedeity.algorithm.search; /** * 插值查找类 */ public class InterpolationSearch implements Search { private int search(int[] numbers, int target, int left, int right) { if (left \u003e right) { return -1; } else if (left == right) { if (numbers[left] == target) { return left; } else { return -1; } } if (target \u003c numbers[left] || target \u003e numbers[right]) { return -1; } int scale = (target - numbers[left]) / (numbers[right] - numbers[left]); int mid = left + (int) Math.floor(scale * (right - left)); if (numbers[mid] \u003e target) { return this.search(numbers, target, left, mid - 1); } else if (numbers[mid] \u003c target) { return this.search(numbers, target, mid + 1, right); } else { return mid; } } @Override public int search(int[] numbers, int target) { return this.search(numbers, target, 0, numbers.length - 1); } } ","date":"2022-07-05","objectID":"/posts/data-structure-algorithm/interpolation-search.html:3:2","tags":["算法","查找"],"title":"插值查找的简单理解","uri":"/posts/data-structure-algorithm/interpolation-search.html"},{"categories":["数据结构与算法"],"content":"二分查找是一种提升有序序列搜索效率的查找算法，大大降低了数组查找的时间，其类似的思想也应用到二叉树、数据库索引等场景。 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:0:0","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"详细描述 二分查找的搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 二分查找详细的执行步骤如下： 在有序表中，取中间记录作为比较对象； 若给定值与中间记录的关键字相等，则查找成功； 若给定值小于中间记录的关键字，则在中间记录的左半区继续查找； 若给定值大于中间记录的关键字，则在中间记录的右半区继续查找； 不断重复步骤 1~4，直到查找成功，或所有查找区域无记录，查找失败为止。 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:1:0","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:2:0","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:3:0","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"二分查找算法有哪些局限性？ 二分查找算法需要按照下标随机访问。所以更适合数组结构，而不适合链表结构，数组按照下标随机访问数据的时间复杂度是 $O(1)$，而链表随机访问的时间复杂度是 $O(n)$。 二分查找针对的是有序数。二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中，针对动态变化的数据集合，二分查找将不再适用。 数据量太小不适合二分查找。在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。 数据量太大也不适合二分查找。二分查找是作用在数组这种数据结构之上的，太大的数据用数组存储比较吃力，也就不能用二分查找了。 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:3:1","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"二分查找算法有哪些变形？ 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:3:2","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:4:0","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"查找接口 package cn.fatedeity.algorithm.search; public interface Search { int search(int[] numbers, int target); } ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:4:1","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"二分查找类 package cn.fatedeity.algorithm.search; /** * 二分查找类 */ public class BinarySearch implements Search { private int search(int[] numbers, int target, int left, int right) { if (left \u003e right) { return -1; } else if (left == right) { if (numbers[left] == target) { return left; } else { return -1; } } if (target \u003c numbers[left] || target \u003e numbers[right]) { return -1; } int mid = (left + right) \u003e\u003e 1; if (numbers[mid] \u003e target) { return this.search(numbers, target, left, mid - 1); } else if (numbers[mid] \u003c target) { return this.search(numbers, target, mid + 1, right); } else { return mid; } } @Override public int search(int[] numbers, int target) { return this.search(numbers, target, 0, numbers.length - 1); } } ","date":"2022-07-04","objectID":"/posts/data-structure-algorithm/binary-search.html:4:2","tags":["算法","查找"],"title":"二分查找的简单理解","uri":"/posts/data-structure-algorithm/binary-search.html"},{"categories":["数据结构与算法"],"content":"基数排序是桶排序的一种扩展使用，同样是一种非比较的整数排序算法，其原理是将整数位数切割成不同的数字，然后按每个位数分别比较。 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:0:0","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 从基数排序的描述可以看得出，其适用于整数，但是，整数也可以表达字符串（比如名字或时间）和特定格式的浮点数，因此基数排序并不只是适用于整数。 基数排序详细的执行步骤如下： 首先准备 10 个桶，分别用于存储所在位数为 0 ~ 9 的数； 提取出序列中元素的个位，将该元素移动到对应个位所属的桶内； 重复执行第 2 步，从个位、十位、百位直到最大元素的最大位数，没有所在位时赋为 0； 执行完第 3 步，组合每个桶内的元素成有序序列。 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:1:0","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:2:0","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:3:0","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"基数排序的复杂度是多少？ 基数排序的时间复杂度和待排序序列的最大位数有关系，由于需要对每一个位数遍历一次序列，基数排序的时间复杂度是 $O(n \\times k)$，其中 k 是最大位数。 基数排序的空间复杂度是 $O(n+k)$，其中 k 是桶的数量。 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:3:1","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"基数排序和快速排序哪个效率更好？ 基数排序是一种空间换时间的非比较类排序算法，其时间复杂度是 $O(n \\times k)$；快速排序是一种常规的比较类排序算法，其时间复杂度是 $O(n\\log_2n)$。 从时间复杂度上看，主要在于其系数的比较。通常是，待排序序列的最大位数越大，基数排序的效率就越低，这时选择快速排序则更优；如果数据量非常大的时候，则基数排序比较占优。 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:3:2","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:4:0","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:4:1","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:4:2","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"基数排序类 package cn.fatedeity.algorithm.sort; import java.util.List; import java.util.ArrayList; /** * 基数排序类 */ public class RadixSort extends AbstractSort { @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } int min = numbers[0], max = numbers[0]; for (int number : numbers) { if (number \u003c min) { min = number; } if (number \u003e max) { max = number; } } int k = String.valueOf(Math.max(Math.abs(min), Math.abs(max))).length(); List\u003cList\u003cInteger\u003e\u003e buckets = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 19; i++) { buckets.add(new ArrayList\u003c\u003e()); } int x = 1; while (x \u003c= k) { for (int number : numbers) { int index = (number / (int) Math.pow(10, x - 1)) % 10; List\u003cInteger\u003e bucket = buckets.get(index + 9); bucket.add(number); } int index = 0; for (int i = 0; i \u003c buckets.size(); i++) { for (int number : buckets.get(i)) { numbers[index++] = number; } buckets.set(i, new ArrayList\u003c\u003e()); } x++; } return numbers; } } ","date":"2022-07-02","objectID":"/posts/data-structure-algorithm/radix-sort.html:4:3","tags":["算法","排序"],"title":"基数排序的简单理解","uri":"/posts/data-structure-algorithm/radix-sort.html"},{"categories":["数据结构与算法"],"content":"桶排序是计数排序的一种扩展使用，适用于元素值范围不大的序列。如果对大量学生的考试成绩做排序，就非常适合使用桶排序。 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:0:0","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 桶排序的工作原理是，将序列中的元素分配到有限的桶里，每个桶再分别进行排序（使用别的排序算法或者递归使用桶排序），最终合并成结果序列。 桶排序详细的执行步骤如下： 找出序列中最小的元素和最大的元素，并计算得到差值范围和映射范围，确定桶的数量； 遍历整个序列，将每一个元素移动到对应的桶中； 对每一个桶中的元素进行排序，直到所有的桶中元素都有序； 合并每一个桶中的元素成为有序序列。 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:1:0","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:2:0","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:3:0","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"桶排序的关键是什么？ 桶排序过程中存在两个关键环节：元素到桶的映射规则、排序算法选择。 对于映射规则，如果规则设计过于模糊、宽泛，可能所有元素都映射到同一个桶，导致桶排序往比较类排序算法演变；如果规则设计过于严苛，可能每一个桶只分配到一个元素，导致桶排序往计数排序方式演变。 对于桶中元素的排序，可以继续使用桶排序或者其他排序算法，最终桶排序的复杂度和稳定性，都根据排序算法的选择有所不同。 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:3:1","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"桶排序的适用于什么场景？ 最好时间复杂度的场景是：序列中的元素值范围越小越好，比如对范围只有 10 的序列做排序，申请 10 个桶就能实现遍历一次序列完成排序。 最好空间复杂度的场景是：序列中的元素值均匀分布，最终分配到每一个桶的元素数量都相差不大，这样可以避免数据倾斜的问题。 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:3:2","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:4:0","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:4:1","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:4:2","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"桶排序类 package cn.fatedeity.algorithm.sort; import java.util.ArrayList; import java.util.List; /** * 桶排序类 */ public class BucketSort extends AbstractSort { private void swap(List\u003cInteger\u003e numbers, int src, int target) { int temp = numbers.get(src); numbers.set(src, numbers.get(target)); numbers.set(target, temp); } private void insertSort(List\u003cInteger\u003e numbers) { for (int i = 1; i \u003c numbers.size(); i++) { for (int j = i; j \u003e 0; j--) { if (numbers.get(j - 1) \u003c= numbers.get(j)) { break; } this.swap(numbers, j, j - 1); } } } @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } int min = numbers[0], max = numbers[0]; for (int number : numbers) { if (number \u003c min) { min = number; } else if (number \u003e max) { max = number; } } // 以 10 为步长 int bucketNum = (max - min) / 10 + 1; List\u003cList\u003cInteger\u003e\u003e bucketList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c bucketNum; i++) { bucketList.add(new ArrayList\u003c\u003e()); } // 将元素分配到桶中 for (int number : numbers) { int index = (number - min) / 10; List\u003cInteger\u003e bucket = bucketList.get(index); bucket.add(number); } int index = 0; for (int i = 0; i \u003c bucketNum; i++) { List\u003cInteger\u003e bucket = bucketList.get(i); this.insertSort(bucket); for (int number : bucket) { numbers[index++] = number; } } return numbers; } } ","date":"2022-06-30","objectID":"/posts/data-structure-algorithm/bucket-sort.html:4:3","tags":["算法","排序"],"title":"桶排序的简单理解","uri":"/posts/data-structure-algorithm/bucket-sort.html"},{"categories":["数据结构与算法"],"content":"学习计数排序可以了解到空间换时间的思想，其是一种牺牲空间换时间的排序算法，在其特定的场景上，甚至将时间复杂度降到了线性级别。 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:0:0","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 计数排序作为一种线性时间复杂度的排序算法，其要求输入的数据必须是 有确定范围的整数，核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 计数排序详细的执行步骤如下： 找出原数组中元素值最大的，记为 max； 创建一个新数组 count，其长度是 max+1，其元素默认值都为 0； 遍历原数组中的元素，以原数组中的元素作为 count 数组的索引，以原数组中的元素出现次数作为 count 数组的元素值； 创建结果数组 result，起始索引 index； 遍历 count 数组，找出其中元素值大于 0 的元素，将其对应的索引作为元素值填充到 result 数组中去，每处理一次，count 中的该元素值减 1，直到该元素值不大于 0，依次处理 count 中剩下的元素； 返回结果数组 result。 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:1:0","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:2:0","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:3:0","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"计数排序的时间复杂度是多少？ 计数排序的时间复杂度可以达到 $O(n+k)$，其中 k 是 count 数组的长度。 从这里可以知道，count 数组元素的取值越集中，算法耗费的时间越短。 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:3:1","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"计数排序有什么限制吗？ 计数排序有两个前提需要满足： 排序的元素必须是整数，否则无法对应数组的索引下标 排序元素的取值要在一定范围内，并且比较集中，否则 count 数组将会非常大 只有这两个条件都满足，才能最大程度发挥计数排序的优势。 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:3:2","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:4:0","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:4:1","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:4:2","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"计数排序类 package cn.fatedeity.algorithm.sort; /** * 计数排序类 */ public class CountSort extends AbstractSort { @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } int min = numbers[0], max = numbers[0]; for (int number : numbers) { if (number \u003c min) { min = number; } else if (number \u003e max) { max = number; } } int[] count = new int[max - min + 1]; for (int number : numbers) { int index = number - min; count[index]++; } int index = 0; for (int i = 0; i \u003c count.length; i++) { while (count[i] \u003e 0) { numbers[index++] = i + min; count[i]--; } } return numbers; } } ","date":"2022-06-28","objectID":"/posts/data-structure-algorithm/count-sort.html:4:3","tags":["算法","排序"],"title":"计数排序的简单理解","uri":"/posts/data-structure-algorithm/count-sort.html"},{"categories":["数据结构与算法"],"content":"归并排序与与快速排序一样，是采用分治法（Divide and Conquer）的一个非常典型的应用，在排序算法中，同时了解归并排序和快速排序，相互印证，能理解得更深。 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:0:0","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 归并排序的基本思想是，将已有序的子序列合并，可以得到有序的完整序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 二路归并。 归并排序详细的执行步骤如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针超出序列尾。 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:1:0","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:2:0","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:3:0","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"归并排序和快速排序比较怎么样？ 归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:3:1","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"归并排序的应用在什么场景？ 归并排序速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的序列。 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:3:2","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"归并排序的时间复杂度是多少？ 每次合并操作的平均时间复杂度为 $O(n)$，而完全二叉树的深度为 $\\log_2n$，总的平均时间复杂度为 $O(n \\log n)$。 并且，归并排序的最好、最坏、平均时间复杂度均为 $O(n \\log n)$。 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:3:3","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:4:0","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:4:1","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:4:2","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"归并排序类 package cn.fatedeity.algorithm.sort; /** * 归并排序类 */ public class MergeSort extends AbstractSort { private void merge(int[] numbers, int low, int mid, int high) { int i = low; int j = mid + 1; int[] newNumbers = new int[high - low + 1]; int k = 0; while (i \u003c= mid \u0026\u0026 j \u003c= high) { if (numbers[i] \u003c numbers[j]) { newNumbers[k++] = numbers[i++]; } else if (numbers[i] \u003e numbers[j]) { newNumbers[k++] = numbers[j++]; } else { newNumbers[k++] = numbers[i++]; newNumbers[k++] = numbers[j++]; } } while (i \u003c= mid) { newNumbers[k++] = numbers[i++]; } while (j \u003c= high) { newNumbers[k++] = numbers[j++]; } if (high + 1 - low \u003e= 0) { System.arraycopy(newNumbers, 0, numbers, low, high + 1 - low); } } private int[] sort(int[] numbers, int low, int high) { if (low \u003c high) { int mid = (low + high) \u003e\u003e 1; this.sort(numbers, low, mid); this.sort(numbers, mid + 1, high); this.merge(numbers, low, mid, high); } return numbers; } @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } return this.sort(numbers, 0, numbers.length - 1); } } ","date":"2022-06-24","objectID":"/posts/data-structure-algorithm/merge-sort.html:4:3","tags":["算法","排序"],"title":"归并排序的简单理解","uri":"/posts/data-structure-algorithm/merge-sort.html"},{"categories":["数据结构与算法"],"content":"快速排序是面试当中最常见的排序算法问题了，除了需要理解快速排序的流程，还要理解一些快速排序的代码实现，了解一些优化方法。 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:0:0","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 快速排序通过一趟排序将待排序列分割成独立的两部分，其中一部分序列的关键字均比另一部分序列的关键字小，则可分别对这两部分序列继续进行排序，以达到整个序列有序的目的。 快速排序详细的执行步骤如下： 从序列中挑出一个元素，称为 “基准”（pivot）； 重新排序序列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于序列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子序列和大于基准值元素的子序列排序。 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:1:0","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:2:0","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:3:0","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"快速排序可以怎样选择基准值？ 第一种方式：固定位置选择基准值；在整个序列已经趋于有序的情况下，效率很低。 第二种方式：随机选取待排序列中任意一个数作为基准值；当该序列趋于有序时，能够让效率提高，但在整个序列数全部相等的时候，随机快排的效率依然很低。 第三种方式：从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为基准值；这种方式解决了很多特殊的问题，但对于有很多重复值的序列，效果依然不好。 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:3:1","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"快速排序有什么好的优化方法？ 首先，合理选择基准值，将固定位置选择基准值改成三点取中法，可以解决很多特殊的情况，实现更快地分区。 其次，当待排序序列的长度分割到一定大小后，使用插入排序。对于待排序的序列长度很小或基本趋于有序时，插入排序的效率更好。 在排序后，可以将与基准值相等的数放在一起，在下次分割时可以不考虑这些数。对于解决重复数据较多的情况非常有用。 在实现上，递归实现的快速排序在函数尾部有两次递归操作，可以对其使用尾递归优化（简单地说，就是尾位置调用自身）。 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:3:2","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:4:0","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:4:1","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:4:2","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"快速排序类 package cn.fatedeity.algorithm.sort; import java.util.Random; /** * 快速排序类 */ public class QuickSort extends AbstractSort { private int[] sort(int[] numbers, int low, int high) { if (low \u003e high) { return numbers; } // 随机数取基准值 Random random = new Random(); int pivotIndex = random.nextInt(low, high + 1); int pivot = numbers[pivotIndex]; this.swap(numbers, pivotIndex, low); int mid = low + 1; for (int i = low + 1; i \u003c= high; i++) { if (numbers[i] \u003c pivot) { this.swap(numbers, i, mid); mid++; } } this.swap(numbers, low, --mid); // 递归实现 this.sort(numbers, low, mid - 1); this.sort(numbers, mid + 1, high); return numbers; } @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } return this.sort(numbers, 0, numbers.length - 1); } } ","date":"2022-06-23","objectID":"/posts/data-structure-algorithm/quick-sort.html:4:3","tags":["算法","排序"],"title":"快速排序的简单理解","uri":"/posts/data-structure-algorithm/quick-sort.html"},{"categories":["数据结构与算法"],"content":"插入排序在对基本有序的较小序列进行排序时，效率是非常高的，希尔排序针对这一点对插入排序的方式进行了再次优化。 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:0:0","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 希尔排序又称为缩小增量排序，主要是对序列按下标的一定增量进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减小，每组包含的关键字越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。 希尔排序详细的执行步骤如下： 选择一个增量序列 t1, t2, …, tk，其中 ti \u003e tj，tk = 1； 按增量序列个数 k 对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti 将待排序序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序； 仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:1:0","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:2:0","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:3:0","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"希尔排序是原地排序算法吗? 希尔排序是插入排序的一个优化版本，利用优化的策略使用插入排序，提高效率，没有使用到额外的内存空间，因此希尔排序是原地排序算法。 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:3:1","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"希尔排序是稳定的排序算法吗？ 插入排序是稳定的排序算法，但是，由于希尔排序使用了增量间隔进行插入排序，希尔排序并不能像插入排序保持稳定，排序过程中会出现相等的两数前后顺序不一致。 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:3:2","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"希尔排序的时间复杂度是多少？ 最好情况时间复杂度为 $O(n)$；最坏情况时间复杂度为 $O(n^2)$；由于希尔排序花费的时间还由增量间隔决定，平均时间复杂度并不能明确得出，平均时间复杂度可看作为 $O(n^{1.3 \\sim 2})$。 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:3:3","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:4:0","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:4:1","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:4:2","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"希尔排序类 package cn.fatedeity.algorithm.sort; /** * 希尔排序类 */ public class ShellSort extends AbstractSort { @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } int length = numbers.length; // 通常增量序列进行二分对原序列拆分 for (int gap = length \u003e\u003e 1; gap \u003e 0; gap = gap \u003e\u003e 1) { for (int i = gap; i \u003c length; i++) { int j = i, current = numbers[i]; while (j \u003e= gap \u0026\u0026 numbers[j - gap] \u003e current) { numbers[j] = numbers[j - gap]; j = j - gap; } numbers[j] = current; } } return numbers; } } ","date":"2022-06-22","objectID":"/posts/data-structure-algorithm/shell-sort.html:4:3","tags":["算法","排序"],"title":"希尔排序的简单理解","uri":"/posts/data-structure-algorithm/shell-sort.html"},{"categories":["数据结构与算法"],"content":"插入排对是一个容易被低估的排序算法，虽然其时间复杂度看起来与冒泡排序和选择排序差不多，但是用在相对有序的短序列中却格外的好。 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:0:0","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 插入排序的基本思想是：将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。 在其实现过程中使用双层循环，外层循环针对除了第一个元素之外的所有元素，内层循环针对当前元素前面的有序表进行待插入位置查找，并进行移动。 选择排序详细的执行步骤如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置； 重复步骤 2~5。 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:1:0","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:2:0","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:3:0","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"插入排序是原地排序算法吗？ 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 $O(1)$，也就是说，这是一个原地排序算法。 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:3:1","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"插入排序是稳定的排序算法吗？ 对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:3:2","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"插入排序的时间复杂度是多少？ 最好情况时间复杂度为 $O(n)$；最坏情况时间复杂度为 $O(n^2)$；平均时间复杂度为 $O(n^2)$。 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:3:3","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:4:0","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:4:1","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:4:2","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"插入排序类 package cn.fatedeity.algorithm.sort; /** * 插入排序类 */ public class InsertionSort extends AbstractSort { @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } for (int i = 1; i \u003c numbers.length; i++) { for (int j = i; j \u003e 0; j--) { // 一直交换到顺序相反 if (numbers[j - 1] \u003c= numbers[j]) { break; } this.swap(numbers, j, j - 1); } } return numbers; } } ","date":"2022-06-20","objectID":"/posts/data-structure-algorithm/insertion-sort.html:4:3","tags":["算法","排序"],"title":"插入排序的简单理解","uri":"/posts/data-structure-algorithm/insertion-sort.html"},{"categories":["数据结构与算法"],"content":"选择排序的概念非常容易理解，按照一般的思路，排序就是每次从原来的序列中拿出最小的元素即可，最终得到的序列就是有序序列。 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:0:0","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 选择排序的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，以此类推，直到全部待排序的数据元素的个数为零。 选择排序详细的执行步骤如下： 初始状态：无序区为 R[1..n]，有序区为空； 第 i 趟排序 (i=1,2,3…n-1) 开始时，当前有序区和无序区分别为 R[1…i-1] 和 R[i…n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1…i] 和 R[i+1…n] 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区； 经过 n-1 趟，无序序列就有序化了。 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:1:0","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:2:0","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:3:0","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"为什么选择排序是不稳定的？ 虽然原理上存在有序区和无序区的区分，但是选择排序算法为了提高空间的使用率，使用的是原地交换方式。 与冒泡排序两两比较交换不同，选择排序算法是最小的元素与固定位置的元素进行交换，当这个固定位置的元素被交换到另一个位置之后，也就有可能导致相等的数字次序变化。 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:3:1","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"选择排序的时间复杂度是多少？ 无论原序列是有序还是无序，选择排序都需要对序列做完整的遍历，即最好情况时间复杂度和最坏情况时间复杂度都是 $O(n^2)$；平均时间复杂度是 $O(n^2)$。 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:3:2","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:4:0","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:4:1","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:4:2","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"选择排序类 package cn.fatedeity.algorithm.sort; /** * 选择排序类 */ public class SelectionSort extends AbstractSort { @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } for (int i = 0; i \u003c numbers.length - 1; i++) { for (int j = i + 1; j \u003c numbers.length; j++) { // 选取到小的值做交换 if (numbers[i] \u003c= numbers[j]) { continue; } this.swap(numbers, i, j); } } return numbers; } } ","date":"2022-06-19","objectID":"/posts/data-structure-algorithm/selection-sort.html:4:3","tags":["算法","排序"],"title":"选择排序的简单理解","uri":"/posts/data-structure-algorithm/selection-sort.html"},{"categories":["数据结构与算法"],"content":"冒泡排序是学习排序算法时最先遇到的算法，其形象名称和排序过程最容易记住，很多人会在面试时谈论起，真正理解了冒泡排序算法才能更深入地学习其他排序算法。 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:0:0","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"详细描述 冒泡排序是一种交换排序，基本思想是在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。 即每当两个相邻的数比较后发现它们的顺序与排序要求相反时，就将它们互换。 冒泡排序详细的执行步骤如下： 从第一个元素开始，比较相邻的元素，如果前一个比后一个大，就交换它们两个； 从前往后，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素就会是最大的数； 将这次找出的最大元素放在最后一个元素位置上，然后针对除这个最大元素以外的其他所有元素重复以上 1~2 步骤； 重复以上步骤，直到最后第一个元素和第二个元素完成比较、交换，则排序完成。 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:1:0","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"算法图解 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:2:0","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"问题解疑 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:3:0","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"冒泡排序是原地排序算法吗？ 冒泡排序是一个原地排序算法，过程只涉及相邻数据的交换操作，只需要常量级的临时空间，它的空间复杂度是 $O(1)$。 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:3:1","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"冒泡排序是稳定的排序算法吗？ 为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等时可以不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:3:2","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"冒泡排序的时间复杂度是多少？ 使用最优时间复杂度解法，原序列是有序时的时间复杂度是 $O(n)$；最坏情况时间复杂度为 $O(n^2)$；平均时间复杂度是 $O(n^2)$。 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:3:3","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"代码实现 ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:4:0","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"排序接口 package cn.fatedeity.algorithm.sort; /** * 排序接口 */ public interface Sort { int[] sort(int[] numbers); } ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:4:1","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"排序抽象类 package cn.fatedeity.algorithm.sort; /** * 排序抽象类 */ public abstract class AbstractSort implements Sort { protected void swap(int[] numbers, int src, int target) { int temp = numbers[src]; numbers[src] = numbers[target]; numbers[target] = temp; } } ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:4:2","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"冒泡排序类 package cn.fatedeity.algorithm.sort; /** * 冒泡排序类 */ public class BubbleSort extends AbstractSort { @Override public int[] sort(int[] numbers) { if (numbers.length \u003c= 1) { return numbers; } for (int i = 0; i \u003c numbers.length - 1; i++) { boolean doSwap = false; for (int j = 0; j + 1 \u003c numbers.length - i; j++) { if (numbers[j] \u003e numbers[j + 1]) { this.swap(numbers, j, j + 1); doSwap = true; } } // 优化基础冒泡排序的步骤 if (!doSwap) { // 如果遍历整个序列无需交换，则表示整个序列已经完全有序 return numbers; } } return numbers; } } ","date":"2022-06-18","objectID":"/posts/data-structure-algorithm/bubble-sort.html:4:3","tags":["算法","排序"],"title":"冒泡排序的简单理解","uri":"/posts/data-structure-algorithm/bubble-sort.html"},{"categories":["数据结构与算法"],"content":"学习排序算法，除了学习它的算法原理和代码实现之外，更重要的是要学会如何评价、分析排序算法。其实，排序算法主要是从执行效率、内存消耗、稳定性三个方面进行分析。 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:0:0","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"分析方法 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:1:0","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"执行效率 对于排序算法执行效率的分析，不仅仅只是简简单单的一个时间复杂度。 还需要从以下方面进行分析： 最好情况、最坏情况、平均情况时间复杂度。对于排序算法来说，有序度不同的数据，对于排序的执行时间有一定的影响，从多个方面分析时间复杂度会更加准确 时间复杂度的系数、常数、低阶。在实际开发中，大多是对一些规模较小的数据进行排序，实际运行速度是非常快的，这时候也可以把系数、常数、低阶考虑进来 比较次数或交换（移动）次数。常见的排序算法都是基于比较的，这时候会涉及到元素比较大小和元素交换或移动，这时候比较次数和交换次数也会影响到执行效率 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:1:1","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"内存消耗 在算法中，内存消耗基本上通过空间复杂度来衡量。 但是，在排序算法中，会有一个新的概念用来衡量内存消耗，即 原地排序。原地排序算法特指不需要另外空间存储的排序算法，空间复杂度能达到 $O(1)$。 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:1:2","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"稳定性 针对排序算法，还有稳定性这样一个重要的度量指标。 这个概念是指，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:1:3","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"常见排序算法 常见的排序算法有很多，这里列出 10 种排序算法作比较。而这 10 种常见的排序算法会根据是否进行比较分为两种： 比较类排序：冒泡排序、选择排序、插入排序、希尔排序、堆排序、快速排序、归并排序 非比较排序：计数排序、桶排序、基数排序 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定 希尔排序 $O(n^{1.3 \\sim 2})$ $O(n^2)$ $O(n)$ $O(1)$ 不稳定 堆排序 $O(n\\log_2n)$ $O(n\\log_2n)$ $O(n\\log_2n)$ $O(1)$ 不稳定 快速排序 $O(n\\log_2n)$ $O(n^2)$ $O(n\\log_2n)$ $O(n\\log_2n)$ 不稳定 归并排序 $O(n\\log_2n)$ $O(n\\log_2n)$ $O(n\\log_2n)$ $O(n)$ 稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ 稳定 桶排序 $O(n+k)$ $O(n^2)$ $O(n)$ $O(n+k)$ 稳定 基数排序 $O(n \\times k)$ $O(n \\times k)$ $O(n \\times k)$ $O(n+k)$ 稳定 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:2:0","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"如何选择合适的排序算法？ ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:3:0","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"选择依据 在实际开发的时候，并不是时间复杂度低的排序算法就能适用于任何场景。 比如说，计数排序算法适用于较集中的小范围整数序列，桶排序算法适用于容易划分为桶的均匀整数序列，计数排序适用于可划分为具有递进关系的“位”的整数序列。 一般来说，对于小规模的数据进行排序时，可以选择时间复杂度是 $O(n^2)$ 的排序算法；对于大规模的数据进行排序时，需要选择时间复杂度是 $O(n \\log n)$ 的排序算法；对于非比较类排序算法，主要应用于特定的场景。 这样选择的原因是，时间复杂度为 $O(n^2)$ 的排序算法会比 $O(n \\log n)$ 的排序算法的效率低，一般指的都是时间复杂度在没有系数、常数、低阶介入比较的情况，当真正使用的时候，这些是不可避免的。 因此，在实际使用时，有些时候 $O(n^2)$ 的排序算法也会比 $O(n \\log n)$ 的排序算法的效率高。 通常，为了兼顾任意规模数据的排序，在一个方法中会使用到多种排序算法。 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:3:1","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"排序实现 - Glibc 例如 Glibc 的 qsort() 函数，数据量较小时会优先使用归并排序算法来对输入数据排序，当数据量比较大时，qsort() 会改用快速排序算法来排序。 在归并排序中，每个元素小于 32 时，会直接进行归并排序；当有元素大于 32 时，则先将元素的指针拷贝到临时空间，再使用归并排序对指针进行排序。 在快排过程中，元素个数小于等于 4 个时候，会使用插入排序代替快速排序。 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:3:2","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"排序实现 - Java 例如 JDK 8 中 Arrays.sort() 的底层实现，也根据不同的情况使用到多种排序算法。 对于元素个数小于 47 的序列，使用的是插入排序算法；对于元素个数大于 47 而小于 286 的序列，使用的则是快速排序算法。 而对于超过 286 个元素的序列，还会判断这个序列是否结构化（数据是否时升时降），结构化的序列会使用归并排序算法，而非结构化的序列仍然会使用快速排序算法。 ","date":"2022-06-16","objectID":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html:3:3","tags":["算法","排序"],"title":"如何分析排序算法","uri":"/posts/data-structure-algorithm/analyze-sorting-algorithms.html"},{"categories":["数据结构与算法"],"content":"对一个算法做复杂度分析是学习算法必备的知识点，当掌握了如何对一个算法做复杂度分析，在优化算法方面将会如虎添翼。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:0:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"简介 复杂度分析法是对已知的代码进行效率分析的方法，与之相对的是使用实际数据运行代码的事后统计法。 复杂度分析法和事后统计法各有优劣，与复杂度分析法进行比较，事后统计法会有以下局限性： 测试结果非常依赖测试环境。硬件的不同会对测试结果有比较大的影响，比如不同处理器的执行时间会不一样 测试结果受数据的影响很大。对同一个排序算法，待排序数据的有序度会影响算法的执行时间；对于小规模的数据排序，插入排序的效率会比快速排序的效率更高 相比事后统计法，复杂度分析法更能表示一个算法在各个维度的综合性能。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:1:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"复杂度 复杂度分为时间复杂度和空间复杂度，但是它们并不能准确地表示算法的执行时间和存储空间。 时间复杂度表示的是执行时间与数据规模之间的增长关系；空间复杂度表示的是存储空间与数据规模之间的增长关系。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:2:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"复杂度表示法 常用的复杂度表示法就是大 O 复杂度表示法，时间复杂度和空间复杂度都能运用这个概念，在概念上可以进行类比。 在实际使用中，空间复杂度会比时间复杂度更简单些，下面只对时间复杂度做解析。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:2:1","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"大 O 时间复杂度表示法 int cal(int n) { int sum = 0; int i = 1; for (; i \u003c= n; ++i) { sum = sum + i; } return sum; } 对上述代码着手，解析这段代码的时间复杂度。 第 2 行和第 3 行仅会运行一次，但第 4、5、6 行是一个 for 循环，将会运行 n 次，因此，整个函数运行的次数可以简单地认为是 n + 2 次。 假如将一行代码的执行时间算作单位时间，以此做类比，则此函数的执行时间 $T(n)$ 与代码的执行次数 n 成正比： $$ T(n) = O(f(n)) $$ 其中，n 表示数据规模的大小；$f(n)$ 表示每行代码执行的次数总和，因为这是一个公式，所以用 $f(n)$ 来表示；$T(n)$ 表示代码执行的时间。公式中的 O 表示代码的执行时间 $T(n)$ 与 $f(n)$ 表达式成正比。 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。 所以，大 O 时间复杂度也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 从定义上理解，大 O 符号是一种算法「复杂度」的「相对」「表示」方式： 复杂度：表示相对其他东西的度量结果 相对：只能比较相同的事物，不能将一个做算数乘法的算法和排序整数列表的算法进行比较 表示：大 O 符号把算法间的比较简化为一个单一变量 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:2:2","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"时间复杂度分析 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:3:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"变量法则 代码中的变量决定时间复杂度。 大 O 复杂度表示法是一种函数的表示方式，函数中存在至少一个变量，这其实就说明了大 O 复杂度表示法展示了代码执行时间随数据规模增长的变化趋势。 所以，在分析时间复杂度的时候，需要记住代码中的变量决定时间复杂度，观察代码中具体哪一个数据变量在实际运行中最能体现运行时间的趋势。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:3:1","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"加法法则 总复杂度等于量级最大的那段代码的复杂度。 大 O 复杂度表示法只是表示一种变化趋势，一般认为，与公式中的高阶 n 值相比，常量、系数、低阶量级与算法的增长趋势关系不大。 为了降低复杂性以及提高对比性，通常会忽略掉公式中的常量、系数、低阶，只记录其中最大阶的量级即可。 因此，在分析一个算法、一段代码的时间复杂度时，一般只需关注循环执行次数最多的那一段代码即可。 通常，核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:3:2","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"乘法法则 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。 在实际开发中，嵌套循环的代码比较常见，这里涉及到嵌套循环的时间复杂度分析。 如果把一次循环看作是 n 次，每次循环当中又会再做一次内循环，再把这次内循环看作是 m 次，这样整体循环就可以看作是 $n \\times m$ 次，这就是乘法法则。 大部分算法复杂度分析中，会经常遇到如 $n^2$、$n^3$ 这样的时间复杂度，也使用到乘法法则。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:3:3","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"常见时间复杂度 常见的时间复杂度有很多，如 $O(1)$、$O(\\log n)$、$O(n)$、$O(n \\log n)$、$O(n^2)$、$O(n^3)$、$O(n^k)$、$O(2^n)$、$O(n!)$ 等。 时间复杂度可以分为多项式量级和非多项式量级两种，多项式量级指的是以 n 作为底数，非多项式量级指的是不以 n 作为底数的非确定量级。 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。 因此，非多项式时间复杂度的算法是非常低效的算法，实际编码中需要尽量避免这种情况出现。 常见的时间复杂度中，非多项式量级只有 $O(2^n)$、$O(n!)$ 两个，其他的都是多项式量级。 其实，时间复杂度超过 $O(n \\log n)$ 的算法就可以称为指数级增长的算法，应尽量避免。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:4:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"常量级 $O(1)$ 是常量级时间复杂度的一种表示方式，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度就被记作 $O(1)$。 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 $O(1)$。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:4:1","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"对数级 对数级时间复杂度非常常见，同时也是最难分析的一种时间复杂度。 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，都可以把所有对数阶的时间复杂度都记为 $O(\\log n)$。 $O(\\log_3n) = O(\\log_32) \\times O(\\log_2n)$ =\u003e $O(\\log_3n) = O(C \\times \\log_2n)$，其中 $C = log_32$ 是一个常量可忽略不计。 如果一段代码的时间复杂度是 $O(\\log n)$，然后代码循环执行 n 遍，这段代码就是 $O(n \\log n)$ 的时间复杂度。 $O(n \\log n)$ 也是一种常见的算法时间复杂度。比如归并排序、快速排序的平均时间复杂度都是 $O(n \\log n)$。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:4:2","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"多变量级 顾名思义，多变量级时间复杂度受多个变量影响，表示一个时间复杂度由多个数据的规模来决定。 这种情况不能随意使用加法法则省略掉其中一个，而是两个变量都需要使用到，如 $O(m \\times n)$、$O(m + n)$ 都是多变量级的复杂度。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:4:3","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"时间复杂度维度 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:5:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"最好情况时间复杂度 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:5:1","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"最坏情况时间复杂度 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:5:2","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"平均时间复杂度 平均时间复杂度会将所有可能情况下的执行次数和其发生的频率聚合起来计算加权平均值，这里涉及到概率论的知识，因此平均时间复杂度又被称为加权平均时间复杂度、期望时间复杂度。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:5:3","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"均摊时间复杂度 均摊时间复杂度是一种适用场景更少的表示方式，对于某些特殊的场景（比如一种场景是大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系），可以引入摊还分析法计算得出均摊时间复杂度。 对于上面描述的场景，可以将这一组操作放在一起分析，尝试将较高时间复杂度那次操作的耗时平摊到其他那些时间复杂度较低的操作上。 均摊时间复杂度是一种特殊的平均时间复杂度。通常，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:5:4","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"复杂度变化趋势 上图是常见复杂度的变化趋势，可以清晰地看到，超过 $O(n \\log n)$ 的复杂度就可以随着 n 的变化而急剧变化，在实际开发中，应尽量避免。 ","date":"2022-06-14","objectID":"/posts/data-structure-algorithm/complexity-analysis.html:6:0","tags":["算法"],"title":"算法的复杂度分析","uri":"/posts/data-structure-algorithm/complexity-analysis.html"},{"categories":["数据结构与算法"],"content":"一致性哈希是一种特殊的哈希表使用方式，它解决了简单哈希算法在分布式散列表中存在的动态伸缩问题。其能在保证增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:0:0","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"简介 在分布式集群中，对机器的添加、删除或者是机器故障后自动脱离集群等操作是分布式集群管理最基本的功能。如果采用的是常见的取模哈希算法，当有机器添加、删除之后，需要对数据做迁移，非常麻烦。 而一致性哈希利用哈希环的概念，保证增加或减少服务器，数据存储的改变最少，相比取模哈希算法大大节省了数据移动的开销，非常方便。 一致性哈希认为在动态变化的缓存空间环境中，良好的哈希算法应该满足以下几个方面： 平衡性：指哈希的结果能够尽可能分布到所有的缓存中，这样可以使得所有的缓存空间都能得到利用 单调性：指当新的缓存空间加入时，原本已分配的数据可以被映射到原本或者新的缓存空间中，而不会被映射到旧的其他缓存空间中 分散性：避免出现相同的内容被不同的终端映射到不同的缓存空间中，降低系统存储的效率 负载：与分散性结合理解，对于一个特定的缓冲区，避免被不同的终端映射为不同的内容 一致性哈希可以理解成普通取模哈希算法的改良版，改变的是将普通的线性哈希空间变成环状的哈希空间，其中每一个缓存空间是环上的一个节点，数据一般存储在沿顺时针的方向找到的环上的第一个节点。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:1:0","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"算法 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:2:0","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"哈希环 简单的说，一致性哈希是将整个哈希值空间想象成一个虚拟的圆环。 比如，假设哈希函数 H 的值空间为 0 ~ $2^{32}-1$，整个哈希空间环如下： 假设这时有 k1、k2、k3、k4 这几个 key 值，通过一定的哈希算法，将这几个 key 值被平均分配到哈希环上。 同样的，现在有 3 台 cache 服务器，通过一定的哈希算法，也被平均分配到哈希环上。 下图展示的是 key 值被分配到哪一台 cache 服务器的一个示例： 如上所示：k1 存储在 c3 上，k4、k3 存储在 c1 上，k2 存储在 c2 上。 哈希环会将哈希后的 key 值按照顺时针的方向寻找最近的 cache 服务器，然后将数据存储在这台服务器上。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:2:1","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"删除节点 假设 c3 服务器宕机，这时候需要从集群中将其摘除，其上的数据也需要做迁移。 按照一致性哈希的规则，原本存储在 c3 上的 k1 按照顺时针的方向寻找最近的 cache 服务器，即后续 k1 会存储在 c1 上： 从这里可知，当使用一致性哈希时，删除节点 c3 会影响到被删除节点 c3 上及其下一个节点 c1 的数据，迁移数据的时候，需要将被删除节点 c3 上的数据迁移到其下一个节点 c1 上。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:2:2","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"新增节点 假设现在需要新增 c4 服务器，会破坏现在集群的平衡，需要对数据做一些处理。 假设 c4 服务器定位在 k4 和 k3 之间，按照一致性哈希的规则，原本存储在 c1 上的 k4 会迁移到 c4 上： 同样的，新增节点会影响到新增节点所在位置的后一个节点 c1，迁移数据的时候，需要将新增节点所在位置到其上一个节点 c3 之间的数据从其下一个节点 c1 迁移到新增的节点 c4 上。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:2:3","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"虚拟节点 一致性哈希理论上没有什么问题，但实际使用会存在以下问题： 当节点较少时，哈希环中的节点容易出现分布不均衡，最终导致数据倾斜 当一个节点宕机时，数据会立马迁移到下一个节点，下一个节点的流量压力和内存压力都会增大，可能会导致其宕机，继而引发雪崩 这里就衍生出一个 虚拟节点 的概念，即对每个物理节点计算多个哈希值，将原来单一的物理节点在哈希环上虚拟出几个分身节点，这些分身节点称为虚拟节点。 映射到分身节点上的数据实际上就是映射到分身对应的物理节点上，这样一个物理节点可以通过虚拟节点的方式均匀分散在哈希环的各个部分，解决数据倾斜问题。 由于虚拟节点分散在哈希环各个部分，当某个节点宕机下线，虚拟节点所存储的数据会被均匀分配给下一个虚拟节点，则物理节点也会得到均匀分配，避免了对单一节点突发压力导致的节点雪崩问题。 在实际应用中，通常将虚拟节点数设置成 32 甚至更大，这样可以保证即使很少的服务节点也能做到均匀的数据分布。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:2:4","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"优缺点 一致性哈希算法相比普通的哈希算法在扩展性和容错性上都有一定的优势： 扩展性：普通的哈希算法增加缓存空间的时候，需要对大量数据做迁移；一致性哈希算法扩展时仅需将下一个节点中的一部分数据迁移到这个新增节点上 容错性：普通的哈希算法减少缓存空间的时候，会出现哈希映射大面积失效的情况；而对于一致性哈希算法，如果出现需要减少缓存空间的情况，其实就是需要将当前减少的节点数据迁移到下一个节点中 实际上，不会存在一劳永逸的哈希算法，一致性哈希算法在以下场景需要谨慎使用： 对于数据占用空间大、但数量较小时，使用一致性哈希有些大材小用 一致性哈希解决了数据的均匀分布，但是没有解决流量和负载的均衡 数据和机器之间的映射通过哈希算法得到，这种关系比较固定，无法人工干涉 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/consistent-hash-basic.html:3:0","tags":["数据结构","哈希表"],"title":"一致性哈希的简单认识","uri":"/posts/data-structure-algorithm/consistent-hash-basic.html"},{"categories":["数据结构与算法"],"content":"B+ 树通常用于数据库和操作系统的文件系统中，对内存与磁盘之间的交互提供了非常大的遍历，是一种常见的存储在磁盘的索引结构。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:0:0","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"B+ 树的概念 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:1:0","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"基本概念 B+ 树是 B 树的一种变体，从某个程度上看，B+ 树可以认定是 B 树的升级版。 在 B+ 树中，关键字只存储在叶子结点，非叶子结点存储的是叶子结点所存储关键字的部分拷贝，所有的叶子结点也都在相同的高度，叶子结点本身按关键字大小从小到大链接。 因此，相对于 B 树而言，B+ 树更充分地利用了结点的空间，让查询速度更加稳定，其速度完全接近于二分查找。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:1:1","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"特性 B+ 树拥有 B 树的大部分特性，但也具有独特的、与 B 树不同的特性，不同的地方有以下两点： B+ 树的非叶子结点不直接存储数据的指针，所有数据的指针都存储在叶子结点 B+ 树叶子结点存储的数据从小到大有序排列，且相邻叶子结点之间具有链接 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:1:2","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"与 B 树的区别 与 B 树相比较，B+ 树具有以下特点： B+ 树的非叶子结点不直接存储数据，存储的索引更多，树的层级更少，查询的速度更快 B+ 树所有数据的指针都存储在叶子结点，因此每次查找到数据的次数都相同，查询速度更稳定 B+ 树所有的叶子结点之间具有链接，构成了一个有序链表，查询范围区间的数据更方便 B+ 树遍历所有数据时只需要遍历所有叶子结点即可，相对 B 树遍历更快 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:1:3","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"为什么使用 B+ 树作为索引结构？ 索引的本质是一种用于快速查找记录的数据结构，常见有二叉查找树、平衡二叉树、哈希表、B 树和 B+ 树等索引存储结构。 每一种索引结构都有其对应的应用场景，易用性也是选择的标准之一，这里讨论一下为什么选用 B+ 树作为索引存储结构。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:2:0","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"为什么不采用二叉查找树？ 使用普通的二叉树查找作为索引结构具有一个致命的问题：当一直插入数据的时候，有可能会退化成链表结构，时间复杂度也会从 $O(\\log n)$ 退化到 $O(n)$。 因此，普通的二叉查找树比较适合数据基本没有变动的情况，这样查找效率不会发生较大的变化。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:2:1","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"为什么不采用平衡二叉树？ 为了解决普通二叉查找树有可能退化成链表的问题，可以使用自平衡的二叉查找树代替，如 AVL 树、红黑树等。 红黑树常见的一种自平衡二叉查找树，但是也有一个问题：红黑树是一个近似平衡的二叉树，当数据量较大的时候，会出现树层级较大的情况。 当数据量非常大时，索引占用的空间也会非常大，索引还是得存储在磁盘上，如果树的层级较大，则进行磁盘 IO 的次数就会越多，性能就会越差。 因此，红黑树不适合作为存储在磁盘上的索引结构。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:2:2","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"为什么不采用哈希表？ 哈希表是一个支持快速查找的数据结构，其查找的时间复杂度是 $O(1)$，其也是最常见的索引存储结构之一。 但是哈希表也有其缺点，就是只存储键值对应关系的哈希表不支持范围查询，如果要做范围查询，需要做全量的数据扫描才行。 当然，如果是具有排序功能的哈希表，会非常适合作为存储在内存中的索引结果，如 Java 中的 TreeMap 对象。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:2:3","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"为什么不采用 B 树？ 使用 B 树可以解决红黑树层级较大的问题，通过一个结点可以存储多个元素，树变得更加矮胖，使得树的层级变得可控。 而且，通过给一个结点存储一页的数据量，最大化地优化操作系统和磁盘的交互，解决了多次磁盘 IO 的问题。 但是对应 B+ 树而言，B 树的层级仍然会比 B+ 树的高，且范围查询没有 B+ 树方便，这是舍弃 B 树而选择 B+ 树的主要原因。 当然，也有使用 B 树作为索引结构的数据库，如 MongoDB 等。 ","date":"2022-06-12","objectID":"/posts/data-structure-algorithm/b+-tree-basic.html:2:4","tags":["数据结构","树","索引"],"title":"B+ 树的简单认识","uri":"/posts/data-structure-algorithm/b+-tree-basic.html"},{"categories":["数据结构与算法"],"content":"在计算机科学中，B 树是一种自平衡的树，能够保持数据有序。其适用于读写相对大的数据块的存储系统，例如磁盘，因此也常作为数据库系统的索引结构。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:0:0","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"理解 B 树的概念 B 树是一种自平衡的查找树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除数据的动作，都能在对数时间内完成。 同一般的二叉查找树不同，B 树是一棵多路平衡查找树，其特性是：结点的孩子结点数可以多于两个，且每一个结点处可以存储多个元素。 在 B 树中，非叶子结点可以拥有可变数量的子结点，为了维持在预先设定的数量范围内，通常是对非叶子结点进行合并和分离。其优势是不需要像其他自平衡查找树那样频繁地重新保持平衡，其劣势是结点未被完全填充时会浪费一些空间。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:1:0","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"特性 通常，我们会在 B 树的名称前添加阶数以示说明，如 m 阶 B 树。一个 m 阶的 B 树具有以下特性： 任意结点最多有 m 个孩子结点 任意除根结点以外的非叶子结点最少有 $\\frac{m}{2}$ 个子结点 如果根结点不是叶子结点，那么它至少有 2 个孩子结点 有 k 个孩子结点的非叶子结点有 k-1 个键 所有的叶子结点都在同一层，B 树也是通过此约束来保持树的平衡 下述展示的是一个 3 阶 B 树： ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:1:1","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"变体 B 树可以指一个特定的树形结构，也可以指大体上的一类树形结构。 对于 B 树这一类树形结构，还包括了 B+ 树和 B* 树等结构，它们的简单定义如下： 对于 B+ 树，关键字只存储在叶子结点，非叶子结点存储的是叶子结点所存储关键字的部分拷贝，所有的叶子结点也都在相同的高度，叶子结点本身按关键字大小从小到大链接。 B* 树是 B+ 树的变体，在 B+ 树的基础上，非叶子结点（除根结点外）会增加指向同一层兄弟的指针，且非叶子结点关键字个数至少为 $\\frac{2m}{3}$，即块的最低使用率为 $\\frac{2}{3}$（B+ 树为 $\\frac{1}{2}$）。 下面为 B* 树的结构： ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:1:2","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"起源和运用 其实，B 树就是一种为磁盘而设计的树形结构，主要是降低其他树形结构访问磁盘的 IO 次数。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:2:0","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"磁盘读取 从磁盘读取数据的时间主要涉及到“寻道时间”和“旋转延迟”： 寻道时间指的是磁盘接收到系统指令后，磁头从头开始移动到数据所在磁道所需要的时间，可能是 0 到 20 毫秒甚至更久 旋转延迟指的是寻道结束后，磁盘将对应的扇区旋转到磁头下所需要的时间，其平均时间大约在旋转周期的 50% 左右，对于一个 7200 转的磁盘，采用 60×1000÷7200 的公式计算得知一次旋转周期事件为 8.33 毫秒左右 磁盘的顺序读写会比随机读写快也是这个原因，在顺序读写时，磁头不需要再做寻道，仅需很少的旋转时间，而随机读写则需要不停地移动磁头寻找对应的磁道。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:2:1","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"磁盘预读 为了尽量减少 IO 操作，计算机系统一般采取预读的方式，预读的长度一般为页（Page）的整数倍。 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（多数操作系统页的大小为 4k），主存和磁盘以页为单位交换数据。 计算机系统是分页读取和存储的，每次读取和存取的最小单元为一页，而磁盘预读时通常会读取页的整数倍。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:2:2","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"索引结构 对于文件系统和数据库系统的索引，通常以文件的形式存储在磁盘上，因此查找索引也会执行磁盘 IO 操作，如果查找过程中磁盘 IO 的存取次数过多会影响索引的效率。 数据库系统普遍使用 B 树或者 B+ 树作为索引结构，其巧妙地利用了磁盘预读原理，将一个结点设置为一个页的大小，这样每个结点只需要一次 IO 就可以完全载入。 同时，在使用过程中还运用了以下技巧： 每次新建结点时，直接申请一个页的空间，实现一个结点只需一次 IO 将根结点常驻内存，在实际使用时可以减少 1 次 IO 使用 B 树作为索引结构时，由于结点的大小等于一个页的大小，通常阶会比较大，因此树的深度较浅（通常不超过 3），查找效率非常高。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:2:3","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"缺点 虽然数据库系统普遍使用 B 树作为索引结构，但是仍然有以下缺点： 非叶子结点直接存储数据，同一结点存储的索引数会比较少 数据即可能存储在叶子结点，也可能存储在非叶子结点，查询效率相对不稳定 在同层结点之间没有指针相邻，不适合做一些数据遍历操作 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:2:4","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"插入和删除 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:3:0","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"插入 B 树所有的插入过程都以根结点起始，首先是要查找到新元素所要存储的结点，然后判断插入结点的元素数量： 如果结点存储的元素数量小于最大值，那么有空间容纳新的元素，直接插入并保持结点内部有序即可； 如果结点存储的元素数量大于等于最大值，将它平均地分裂成 2 个结点： 从该结点的原有元素和新的元素中选择出中位数（按顺序排列的一组数据中居于中间位置的数）； 小于中位数的元素放入左边结点，大于中位数的元素放入右边结点，中位数作为分隔值； 将分隔值插入到父结点中，这也可能会造成父结点发生分裂，父结点的分裂也可能会造成它的父结点分裂，以此类推；如果没有父结点，就创建一个新的父结点。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:3:1","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"删除 删除 B 树中的结点有两种常用的策略： 定位并删除元素，然后调整树使它满足约束条件 从上到下处理这棵树，在进入一个结点之前，调整树使得其之后一旦遇到要删除的键，可以被直接删除而不需要再进行调整 对于前一种删除策略，其删除流程如下： 如果删除叶子结点中的元素，将它直接删除，如果结点中的元素数量小于最小值，则进行重新平衡操作； 如果删除非叶子结点中的元素，选择一个新的分隔值（左子树中最大的元素或右子树中最小的元素），将它从叶子结点中移除，替换掉被删除的元素作为新的分隔值，如果该叶子结点中的元素数量小于最小值，则进行重新平衡操作； 重新平衡操作从叶子结点开始，向根结点进行，直到树重新平衡。 在删除结点中，使 B 树重新平衡主要会有以下情况： 如果缺少元素结点的右兄弟结点存在且拥有多余的元素，那么向左旋转： 将父结点的分隔值移动到左子树中最大元素处； 将右兄弟结点的最小元素移动到原父结点的分隔值处； 如果缺少元素结点的左兄弟结点存在且拥有多余的元素，那么向右旋转： 3. 将父结点的分隔值移动到右子树中最小元素处； 4. 将左兄弟结点的最大元素移动到原父结点的分隔值处； 如果缺少元素结点的两个直接兄弟结点都只有最小数量的元素，那么将它与左兄弟结点以及它们在父结点中的分隔值合并： 5. 将分隔值复制到左边的结点； 6. 将此缺少元素结点中的所有元素移动到左边结点； 7. 将缺少元素的结点移除； 8. 如果父结点是根结点且没有元素，则释放它并让合并后的结点成为新的根结点；如果父结点的元素数量小于最小值，重新平衡父结点。 对 B 树做删除元素的操作比较复杂，但仍然是以保持 B 树平衡为主，并且不使其导致特性失效。 ","date":"2022-06-10","objectID":"/posts/data-structure-algorithm/b-tree-basic.html:3:2","tags":["数据结构","树","索引"],"title":"B 树的简单认识","uri":"/posts/data-structure-algorithm/b-tree-basic.html"},{"categories":["数据结构与算法"],"content":"AVL 树是最早被发明的自平衡的二叉查找树，在 AVL 树中，任意结点的两个子树的高度最大差别为 1，所以它也被称为高度平衡树，其本质仍然是一颗二叉查找树。 ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:0:0","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"基本概念 结合二叉查找树的特性，以及 AVL 树自身的特性，AVL 树具有以下特性： 若任意结点的左子树不为空，则左子树上所有结点的值均小于它的根结点的值 若任意结点的右子树不为空，则右子树上所有结点的值均大于或等于它的根结点的值 任意结点的左、右子树也分别为二叉查找树 任意结点的子树的高度差都小于等于 1 上述的前三项是二叉查找树的特性，第四项是 AVL 树自平衡的特性。 ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:1:0","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"实现原理 为了保证二叉树的平衡，AVL 树引入了监督机制，就是在树的某一部分的不平衡度超过一个阈值后触发相应的平衡操作，保证树的平衡度在可以接受的范围内。 既然引入了监督机制，则必然需要一个监督指标，以此来判断是否需要进行平衡操作，这个监督指标被称为 平衡因子（Balance Factor）。其定义如下： 某个结点的右子树的高度减去左子树的高度得到的差值。 基于平衡因子，就可以这样定义 AVL 树： 所有结点的平衡因子的绝对值都不超过 1 的二叉查找树。 为了计算平衡因子，自然需要在结点中引入高度这一属性。结点的高度为以下定义： 左右子树的高度的最大值。 typeof struct AVLNode { struct AVLNode *left; // 左子树 struct AVLNode *right; // 右子树 int height; // 当前结点的高度 int value; // 当前结点的值 } ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:2:0","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"自平衡 自平衡是指在对平衡二叉树执行插入或删除结点操作后，可能会导致树中某个结点的平衡因子绝对值超过 1，即平衡二叉树变得“不平衡”，为了恢复该结点左右子树的平衡，此时需要对结点执行旋转操作。 二叉树的平衡化有两大基础操作：左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。 这两种操作都是从失去平衡的最小子树根结点开始的（即离插入结点最近且平衡因子超过 1 的祖结点）。 ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:0","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"左旋 所谓左旋操作，就是把上图中的 B 结点和 A 结点进行所谓“父子交换”。在仅有这三个结点时候，是十分简单的。但是当 B 结点处存在左孩子时，事情就变得有点复杂了。 通常的操作是：结点 B 抛弃左孩子，将之与旋转后的结点 A 相连，成为结点 A 的右孩子。 ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:1","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"右旋 所谓右旋操作，就是把上图中的 B 结点和 C 结点进行所谓“父子交换”。在仅有这三个结点时候，也是是十分简单的。但是当 B 结点处存在右孩子时，事情就变得有点复杂了。 这时通常的操作是：结点 B 抛弃右孩子，将之和旋转后的结点 C 相连，成为结点 C 的左孩子。 ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:2","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"单次旋转 - LL LL 型又被称为“左左”，从上图中可以看得出，A 结点的平衡因子绝对值达到了 2，需要进行修复才能重新成为一棵平衡二叉树。F 结点为新插入的结点，优先会经过 A 结点的 左孩子 B 结点，最终落到 B 结点的 左子树 上，这即是“左左”的来由。 可以使用平衡因子来定义 LL 情况：A 结点的平衡因子为 -2，左孩子 B 结点的平衡因子为 -1。 这时候仅需要对 A 结点做一次 右旋 的操作即可达到平衡状态： ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:3","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"单次旋转 - RR RR 型又被称为“右右”，与上面的 LL 型 具有对称性，展示的情况如下： 也可以使用平衡因子来定义：A 结点的平衡因子为 2，右孩子 C 结点的平衡因子为 1。 这里则是仅需要对 A 结点做一次 左旋 的操作即可达到平衡状态： ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:4","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"双次旋转 - LR 使用平衡因子定义 LR 型为：A 结点的平衡因子为 -2，左孩子 B 结点的平衡因子为 1。 下面有一个例子： 第一步：对 A 结点的左子结点（B 结点）执行左旋操作，得到一个 LL 型的结构： 第二步：对 A 结点执行右旋操作： ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:5","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"双次旋转 - RL RL 型和上面的 LR 型对称，A 结点的平衡因子为 2，右孩子 C 结点的平衡因子为 -1。 第一步：对 A 结点的右子结点（C 结点）执行右旋操作，得到一个 RR 型的结构： 第二步：对 A 结点执行左旋操作： ","date":"2022-06-02","objectID":"/posts/data-structure-algorithm/avl-tree-basic.html:3:6","tags":["数据结构","树","索引"],"title":"AVL 树的简单认识","uri":"/posts/data-structure-algorithm/avl-tree-basic.html"},{"categories":["数据结构与算法"],"content":"有序的数组可以使用二分查找的方法快速检索一个数据，但是同为线性表结构的链表没有办法使用二分查找，而跳表突破了这个限制，允许链表使用类似于二分查找的方法查找数据。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:0:0","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"图解分析 对于一个单向链表来说，即使链表中存储的是有序的数据，但如果想要从中查找某个数据时，也只能从头到尾遍历链表，其时间复杂度是 $O(n)$。 为了提高链表的查询效率，使其支持类似“二分查找”的方法，对链表进行多层次扩展，这样的数据结构就是 跳表。跳表对标的是平衡树，是一种提升链表插入、删除、搜索效率的数据结构。 首先，跳表处理的是 有序 的链表，一般使用双向链表更加方便。 然后，每两个结点提取一个结点到上一级，提取的这一层被称作为 索引层。 这时候，当想要查找 19 这个数字，可以先从索引层开始查找；当到达 17 时，发现下一个结点存储 21 这个数字，则可以确定，想要查找的 19 肯定是在 17 到 21 之间；这时候可以转到下一层（原始链表）中查找，快速从 17 开始检索，很快就可以查找出 19 这个数字。 加入一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是查找效率提高了。实际上，一般会新增多层索引，拥有多层索引的跳表，查找一个结点需要遍历的结点个数将再次减少。 这种链表加多层索引的结构，就是跳表。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:1:0","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"效率分析 为了方便对跳表的效率做分析，在这里设定一个常见的跳表类型。 假设每两个结点会抽出一个结点作为上一级索引的结点，那第一级的索引个数大约就是 $\\frac{n}{2}$，第二级的索引个数大约就是 $\\frac{n}{4}$，以此类推，第 k 个索引的结点个数是第 k-1 个索引的结点个数的 $\\frac{1}{2}$，那么，第 k 个索引的结点个数就是 $\\frac{n}{2^k}$。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:2:0","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"时间复杂度 假设索引总共有 h 级，最高级的索引有 2 个结点，使用公式 $\\frac{n}{2^h} = 2$ 进行反推，可以计算得出 $h = \\log_2 n - 1$，如果包含原始链表那一级，跳表的高度就是 $\\log_2 n$ 级。 当想要从跳表中查询某个数据时，每层都会遍历 m 个结点，那么，在跳表中查询一个数据的时间复杂度就是 $O(m \\log n)$。 从上面图中可知，在每一级索引中最多只需要遍历 3 个结点，其实就可以看作是 m = 3。 实际就是，在最高级索引时最多遍历 3 个结点，当需要在下一级索引中继续检索时，算上前后两个当做范围的结点也只有 3 个，因此，在每一级索引最多只需要遍历 3 个结点。 如果细究的话，m 的值与抽取索引值的间隔有直接关系，但是只是计算时间复杂度的话，可以将 m 值看作是一个常数。 因此，在跳表中做检索的时间复杂度是 $O(\\log n)$。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:2:1","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"空间复杂度 同样的，假设每两个结点会抽出一个结点作为上一级索引的结点，那第一级的索引个数大约就是 $\\frac{n}{2}$，第二级的索引个数大约就是 $\\frac{n}{4}$，依次类推，最终索引占用的空间将是 $\\frac{n}{2} + \\frac{n}{4} + … + 4 + 2 = n - 2$。 所以，跳表的空间复杂度是 $O(n)$。 实际上，跳表是一种使用空间换时间的数据结构，以增加索引的方式，提高检索数据的效率。因此，跳表会比普通链表耗费更多内存进行数据存储。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:2:2","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"结点间隔 在上述分析跳表的时间复杂度和空间复杂度时，都是以每两个结点抽出一个结点作为上一级索引的结点。 实际上，也可以使用 3 个结点或 4 个结点甚至更多结点做间隔。当然，以不同个数结点做间隔时，检索效率和内存占用都会有些不一样。 假设以 3 个结点做间隔，占用的空间会有所降低，在这个跳表上做检索操作时，检索的效率也会有一些降低。 因为在每一级索引检索的最多结点个数将从 2 个变成 3 个，跳表的高度是 $\\log_3 n$ 级，最终占用的空间将是 $\\frac{n}{3} + \\frac{n}{9} + … + 3 + 1 = \\frac{n}{2}$。 在理论上，以 3 个结点做间隔的跳表与以 2 个结点做间隔的跳表的时间复杂度和空间复杂度都是一样的。但是，实际操作时，以 3 个结点做间隔的跳表的空间占用会比以 2 个结点做间隔的跳表更优一些。 实际上，在软件开发中，不必太在意索引占用的额外空间。虽然原始链表中存储的有可能是很大的对象，但索引结点可以只存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:2:3","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"动态插入和删除 上面理解的跳表都是静态的，实际开发中，跳表在新增、删除结点时需要做动态处理，否则容易导致检索效率降低。 如上图所示，如果频繁插入结点，而没有对索引层做动态处理，很容易出现不满足一开始设定的跳表规则。 删除链表的结点时也是同样道理，如果删除结点而没有更新索引层，索引层容易出现已被删除的脏结点。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:3:0","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"重建索引 比较容易理解的方法就是重建索引，当每次插入、删除结点的时候，把整个跳表的所有索引层删除重建。 但是这种方法会降低插入结点时的效率，已知跳表的空间复杂度是 $O(n)$，也可以推断出重建跳表索引层的时间复杂至少是 $O(n)$。 也就是说，使用重建索引的方式，跳表插入结点耗费时间将会直线上升。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:3:1","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"随机索引 与重建索引相比，随机索引的效率会更高一些，像 Redis 实现 SortedSet 底层用的跳表就是使用随机索引的方式进行动态处理。 这里的做法是通过使用一个随机函数，来决定这个结点插入时，是否需要插入到索引层、以及插入到第几级索引。 一般来说，通过随机函数得到的数据都是比较均匀的，也表示最终得到的跳表索引层也是比较均匀，而且数据量越大，索引层越是均匀。 先设定索引的生成规则：从原始链表中随机选择 $\\frac{1}{2}$ 个结点作为一级索引，从一级索引中随机选择 $\\frac{1}{4}$ 个结点作为二级索引，以此类推，一直到最顶层索引。这时候就需要根据这个规则完成所需的随机函数，并且是每次插入结点的时候，都通过随机函数判断这个结点需要插入到几级索引。 以下是 Redis 源码当中使用到的 随机函数： /* Returns a random level for the new skiplist node we are going to create. * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL * (both inclusive), with a powerlaw-alike distribution where higher * levels are less likely to be returned. */ int zslRandomLevel(void) { int level = 1; while ((random()\u00260xFFFF) \u003c (ZSKIPLIST_P * 0xFFFF)) level += 1; return (level\u003cZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; } 这个随机函数会随机生成 1 到索引最高层数之间的一个数字，该方法有 $\\frac{1}{2}$ 的概率返回 1、有 $\\frac{1}{4}$ 的概率返回 2、有 $\\frac{1}{8}$ 的概率返回 3、以此类推。其中 1 表示不需要生成索引，2 表示需要生成一级索引，3 表示需要生成二级索引，以此类推。 为什么不是返回 1 时生成一级索引呢？这是因为，在生成比一级索引更高层级的索引时，都会向下生成索引，即如果随机函数返回 3，则会给这个结点同时生成二级索引和一级索引。这样，如果返回 1 时生成一级索引则会出现生成一级索引的概率为 100%。 使用随机索引方法的跳表，插入结点的时间复杂度与跳表索引的高度相同，最终时间复杂度降到 $O(\\log n)$，而不是重建索引的 $O(n)$。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:3:2","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"应用场景 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:4:0","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"跳表和平衡查找树 与平衡查找树相比，跳表拥有以下优势： 跳表的底层原始链表支持范围查询 跳表相对简单，更容易使用代码实现 跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗 针对上述的第 1 点，支持范围查询的 B+ 树更适用于磁盘，跳表主要用于内存中读取数据。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:4:1","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"LSM-Tree LSM-Tree 全称是 Log Structured-Merge Tree，其中文名是日志结构的合并树，是一种分层的、有序的、基于硬盘的数据结构。 LSM-Tree 的核心思路是，首先写入数据到内存中，不需要每次有数据更新时就必须将数据写入到磁盘中，内存达到阈值之后，再使用归并排序的方式将内存中的数据合并追加到磁盘队尾。 因为跳表恰好就是天然有序的，所以在 flush 的时候效率很高，通常基于 LSM-Tree 结构的数据库在内存部分都会选择跳表这种数据结构。 HBase 的 MemStore 内部基于 LSM-Tree 实现，Google 开源的 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 内部的 MemTable 都是基于 LSM-Tree 实现，它们都使用到了跳表这一结构。 ","date":"2022-06-01","objectID":"/posts/data-structure-algorithm/skip-list-basic.html:4:2","tags":["数据结构","链表","索引"],"title":"跳表的简单认识","uri":"/posts/data-structure-algorithm/skip-list-basic.html"},{"categories":["数据结构与算法"],"content":"哈希表也被称为散列表，其实现使用到了散列技术，散列技术在理想情况下，无须任何比较就可以找到待查关键字，查找的效率非常高。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:0:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"哈希表的概念 散列技术在记录的存储位置和它的关键字之间建立一个确定的对应关系，使得每个关键字对应一个存储位置，也就是我们常说的键值对关系。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:1:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"关键字 哈希表一般都是用在查找的时候，通常，我们将需要存储的原始数据被称作是查找的 关键字。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:1:1","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"哈希算法 散列技术的关键在于将关键字与存储位置建立对应关系，这种建立映射关系的规则被称作 哈希算法。 一般的哈希算法是将任意长度的二进制值串映射为固定长度的二进制值串，而这个固定长度的二进制值串可以匹配上存储位置。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:1:2","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"哈希值 通过原始数据映射之后得到的二进制值串就是 哈希值。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:1:3","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"装载因子 哈希冲突是非常常见的，因此，在此基础上增加了一个 装载因子 的概念，用来表示哈希表中空位的多少，其计算公式为： 哈希表的装载因子 = 填入表中的元素个数 / 哈希表的长度 装载因子越大，说明空闲位置越少，冲突越频繁，哈希表的性能会下降。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:1:4","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"构造方法 哈希表利用了数组支持使用下标快速随机访问数据的特性，使用数组作为物理存储结构，可以理解为哈希表是数组的一种扩展，也可以说没有数组就没有哈希表。 哈希表通常是基于数组实现的，对比数组，哈希表还拥有创建、删除、查找都非常快的优势，无论数据量多大，这些操作都接近于 $O(1)$ 的时间复杂度；但相对也存在一些劣势，哈希表中的数据没有顺序，而且不能在同一存储地址存储重复的哈希值。 无论是什么编程语言，实现一个哈希表数据结构的过程都可以分为三个步骤： 实现一个哈希算法； 合理解决哈希冲突； 实现其他操作方法。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:2:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"哈希算法 一个好的哈希算法对于哈希表是非常重要的，是哈希表具有比较优的时间复杂度和空间复杂度的根本。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"什么是好的哈希算法 简单来说，好的哈希算法需要具备两个原则：快速计算 和 均匀分布。 具体来说，实现一个好的哈希算法会有以下特点： 哈希算法的方向是单向的，从哈希值不能反向推导出原始数据 哈希算法的转换是敏感的，原始数据任何一点变动，得到的哈希值都会大不相同 哈希冲突的概率要极小的，不同的原始数据，经过哈希算法得到的哈希值相同的概率很小 哈希算法的执行效率是高效的，即使是很长的文本也能快速计算出哈希值 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:1","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"直接定址法 直接定址法就是取关键字的某个线性函数值作为哈希值，或者使用这个线性函数值经过特定的算法计算出哈希值。 例如，存储中国每一年的人数时，可以将年份作为计算哈希值的线性函数值，可以想象得到，年份是连续的，并且没有冲突，非常适合用来计算哈希值。 直接定址法的优点就是简单、分布均匀、不会出现冲突。其缺点也很明显，就是要求选定的线性函数值分布均匀、不会出现冲突。 换一种角度看，直接定址法的限制决定了其并不常用于实际开发。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:2","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"数字分析法 数字分析法的核心点就是从原始数据中选取一个辨识度较大的数据作为计算哈希算法的关键字，比较常见的就是用于处理关键字位数比较大的数字。 数字分析法有个比较常见的场景，国内的手机号都是 11 位的数字，而且也常见到将中间 4 位数字隐藏的做法，这个其实就是数字分析法的一种用法。因为 11 位手机号的前 3 位是运营商接入号，中间 4 位是归属地识别号，后 4 位是用户号，当手机号码都在同一个地区时，只需要使用前 3 位和后 4 位就可以作为哈希算法的关键字。 数字分析法也是一种相对简单的哈希算法，但一般针对较大数字，如果这些较大数字分布均匀的话，可以选用这个方法。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:3","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"平方取中法 平方取中法的规则如其名。假设关键字是 1234，计算得到它的平方就是 1522756，再抽取中间三位 227 可以作为哈希值；假设关键字是 4321，计算得到它的平方就是 18671041，抽取中间三位 671 或 710 作为哈希值即可。 平方取中法比较适合不知道关键字的分布、而位数又不是很大的情况。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:4","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"折叠法 折叠法主要是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并根据哈希表的长度，取后几位作为哈希值。 比如，对 9876543210 使用折叠法，假设哈希表表长为三位，将 9876543210 分成 987|654|321|0 这样四组，然后对这四组使用 987+654+321+0 叠加求和计算得到 1962，再取 1962 的后三位作为哈希值。 折叠法的应用场景可以和平方取中法互补，适合用在不知道关键字的分布，而位数较多的情况。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:5","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"除留取余法 除留取余法是最常用的哈希算法之一，实际就是对关键字求模取余数，这个余数就是哈希值。但是这种方法得到的哈希值非常容易冲突，这个方法的关键就是要选择合适的除数。 根据前辈们的经验，通常这个除数会选取小于等于哈希表表长的最大质数或不包含小于 20 质因子的合数。 合数是指在大于 1 的整数中除了能被 1 和本身整除外，还能被其他数（0 除外）整除的数，最小的合数是 4。 与之相对的是质数，在正整数中，1 既不属于质数也不属于合数。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:3:6","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"哈希冲突 设计得再好的哈希算法也很难完全避免冲突，从哈希表出现到现在，也出现了很多解决哈希冲突的常规方法。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:4:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"开放定址法 所谓开放定址法就是，一旦发生了冲突，就去寻找下一个空的存储地址，只要哈希表足够大，空的存储地址总能被找到，并将数据存入。 像是这种寻找下一个空的存储地址的常用方法就是线性探测法，即一个一个去寻找，直至找到下一个空的存储地址。但是这种方法在哈希冲突比较多的时候，哈希表的时间复杂度会慢慢下降到 $O(n)$。 除了线性探测法，还有二次探测、双重哈希的方法。 二次探测就是将线性探测为 1 的步长改成平方的步长。例如，在线性探测中是 hash(key) + 0, hash(key) + 1, hash(key) + 2，二次探测就是 hash(key) + 0, hash(key) + $1^2$、hash(key) + $2^2$。 双重哈希指的是使用多个哈希算法，如果第一个哈希算法出现冲突，就使用第二个哈希算法，以此类推，直至找到空闲的存储位置。 当数据量和装载因子都比较小的时候，适合采用开放寻址法。这也是 Java 中 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:4:1","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"链地址法 链地址法是另一种常见的哈希冲突解决办法。 开放定址法是在原哈希表上再次找到存储位置，而链地址法是在出现哈希冲突之后，将这些出现冲突的关键字存储到链表中。具体的存储结构如下图所示： 这个方法相对于开放定址法来说多了链表这种数据结构，对于会出现很多冲突的哈希算法来说，提供了绝不会出现找不到地址的保障。 虽然这个方法在插入时没有明显的性能损耗，但是带来了查找、删除时需要遍历单向链表的性能损耗。 链地址法在查找时耗费的时间取决于链表的长度，可以将时间复杂度理解成 $O(k)$(k 为链表长度)。 针对于这样的劣势，可以采用其他的数据结构代替链表，如使用红黑树这样的树形结构，Java 中的 HashMap 便是如此。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:4:2","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"公共溢出区法 公共溢出区法可以理解为链地址法的集中方式。 公共溢出区法也是需要使用到另外的存储区域，但不像链地址法中会将这个存储区域链到链表上，而是使用一个单独的存储区域存储所有冲突的关键字。 这个公共的溢出区可以是另外一个哈希表，对冲突的关键字再次哈希进行存储。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:4:3","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"应用场景 这里的应用场景可以分为哈希表的应用场景和哈希算法的应用场景。 对于哈希表，使用它主要是为了提升时间复杂度；对于哈希算法，使用它是为了应用它的特点。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:5:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"安全加密 常见的加密算法使用的都是哈希算法，如 MD5、SHA 等。因为哈希算法不可逆和转换敏感的特点，使用哈希算法的安全性非常好。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:5:1","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"唯一标识 比如 URL 字段或者图片字段要求不能重复，这个时候就可以通过对相应字段值做 MD5 处理，将数据统一为 32 位长度，对数据库索引构建和查询提升非常明显。 此外，还可以对文件之类的二进制数据做 MD5 处理，作为唯一标识，这样判定重复文件的时候更快捷。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:5:2","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"数据校验 比如从网上下载的很多文件（尤其是 P2P 站点资源），都会包含一个 MD5 值，用于校验下载数据的完整性，避免数据在中途被劫持篡改。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:5:3","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"负载均衡 利用哈希表代替映射表，可以实现一个会话粘滞的负载均衡策略。 对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就应该是被路由到的服务器编号。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:5:4","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"数据分片 通过哈希表对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:5:5","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"经典案例 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:6:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"MD5 MD5 消息摘要算法是一种被广泛使用的散列函数，可以产生出一个 128 位（16 字节）的散列值，用于确保信息传输完整一致。 MD5 是输入不定长度信息，输出固定长度 128 位的算法。无论是多长的信息，经过程序流程，都会生成四个 32 位数据，最后联合起来成为一个 128 位散列值。 但是在 2009 年，中国科学院的谢涛和冯登国仅用了 $22^{0.96}$ 的碰撞算法复杂度，破解了 MD5 的碰撞抵抗，该攻击在普通计算机上运行只需要数秒钟。2011 年，RFC 6151 禁止将 MD5 用作密钥散列消息认证码。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:6:1","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"SHA 安全散列算法 SHA 是一个密码散列函数家族，是 FIPS 所认证的安全散列算法。这是能计算出一个数字消息所对应到的、长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的几率很高。 SHA 家族算法包含了 SHA-0、SHA-1、SHA-2、SHA-3，对 SHA-0 和 SHA-1 都已经出现理论上破解的方法，现在比较常见的还是 SHA-2，虽然至今尚未出现对 SHA-2 有效的攻击，但它的算法跟 SHA-1 基本上相似。 SHA-3 是在 2015 年正式发布的，由于对 MD5 出现成功的破解，NIST 感觉需要一个与之前算法不同的、可替换的加密散列算法，也就是现在的 SHA-3。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:6:2","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"CRC 循环冗余校验 CRC 是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。 由于 CRC 算法检验的检错能力极强，且检测成本较低，因此在对于编码器和电路的检测中使用较为广泛。从检错的正确率与速度、成本等方面，都比奇偶校验等校验方式具有优势。因而 CRC 成为计算机信息通信领域最为普遍的校验方式。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:6:3","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"工业级哈希表实现 Java 中的 HashMap 是一个非常经典的工业级哈希表实现，理解它的实现可以加深对哈希表的印象，有兴趣可以看一下 HashMap 的源码。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:7:0","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"初始大小 HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样能大大提高 HashMap 的性能。 哈希表的容量要取 2 的整次幂，因为这样正好相当于一个 低位掩码，在 hash() 方法内可以做到高位归零。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:7:1","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"装载因子和动态扩容 HashMap 默认的最大装载因子是 0.75，当 HashMap 中元素个数超过 0.75 * capacity(capacity 表示哈希表的容量) 的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:7:2","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"散列函数 散列函数的设计并不复杂，追求的是简单高效、分布均匀。HashMap 散列函数的源码如下： int hash(Object key) { int h = key.hashCode()； // capicity 表示哈希表的大小 return (h ^ (h \u003e\u003e\u003e 16)) \u0026 (capitity -1); } 在 Java 中，hashCode() 方法通过将对象的物理地址转换为一个整数，再将整数通过哈希算法计算得到哈希码，这个哈希码是一个 32 位的带符号整数值，正常情况下很难发生碰撞。 为了让这个哈希码与 HashMap 的底层数组做映射，Java 还会将这个哈希码再次做哈希操作，采用的方法是： 将哈希码右移 16 位，正好是 32bit 的一半； 将哈希码的高半区和低半区做异或，可以混合哈希码的高位和低位，以此加大低位的随机性； 将计算结果做高位归零，只保留低位值。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:7:3","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"散列冲突解决方法 HashMap 底层采用链地址法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。 于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化引入了红黑树。 当链表长度太长（默认超过 8）时，链表就转换为红黑树，这是利用了红黑树快速增删改查的特点，提高 HashMap 的性能。 当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表，这是因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。 ","date":"2022-05-31","objectID":"/posts/data-structure-algorithm/hash-basic.html:7:4","tags":["数据结构","哈希表"],"title":"哈希表的简单认识","uri":"/posts/data-structure-algorithm/hash-basic.html"},{"categories":["数据结构与算法"],"content":"从逻辑结构上看，堆是一种非常特别的树形结构，从应用场景上看，与常见的树形结构又完全不同，使用堆还能解决许多独特的问题。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:0:0","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"堆的概念 堆本身是一种树形结构，总是满足以下性质： 堆总是一棵完全二叉树 堆中某个结点总是不大于或不小于其父结点的的值 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:1:0","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"属性 堆分为两种：根结点最大的堆叫作 最大堆 或 大根堆；根结点最小的堆叫作 最小堆 或 小根堆。 堆属性非常有用，其使得堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:1:1","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"堆和二叉搜索树的区别 堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。 对于堆来说，在最小堆中父结点必须比子结点小，在最大堆中父结点必须比子结点大，变化是从上到下；对于二叉搜索树，左子结点比父结点小，父结点比右子结点小，变化是从左到右。 在内存占用方面，堆使用数组作为底层存储结构，占用内存空间较小；二叉搜索树使用链表作为底层存储结构，占用内存空间较大。 从平衡的角度上看，堆不需要整棵树有序，而二叉搜索树必须是平衡的，总体上是有序的。 对于搜索的效率而言，堆的搜索效率比二叉搜索树低得多，基本上可以认为堆不适合作为搜索的数据结构。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:1:2","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"堆的实现 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:2:0","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"存储 实现一个堆，首先是涉及到如何存储一个堆。 根据堆总是一棵完全二叉树的性质，以及完全二叉树比较适合用数组来存储的概念，可以知道用数组存储堆是比较好的选择。 从上图可以看到，数组中下标为 i 的结点的左子结点，就是下标为 2i 的结点，右子结点就是下标为 2i + 1 的结点，其父结点就是下标为 i/2 的结点。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:2:1","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"堆化 往堆中插入或者删除一个元素后，重要的是要继续满足堆的两个特性，而这个重新满足堆特性的过程称为 堆化。 堆化实际上有两种：从下往上、从上往下。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:2:2","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"插入元素 插入元素时涉及的是从下往上的堆化方法。 往堆中插入一个元素其实就是往底层数组的末尾添加元素，下面是示例图： 从下往上堆化的过程比较简单，实际上就是将插入的元素与父结点进行比较，出现不符合特性的情况就互换两个结点，一直重复这个过程，直至父子结点之间满足堆的特性。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:2:3","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"删除元素 当删除堆顶元素的时候，为保持堆的特性，则会涉及到从上往下的堆化方法。 从上往下堆化不是直接从堆顶元素开始与子结点进行互换，而是先将数组中的最后一个元素移到被删除结点位置（为了满足完全二叉树的特性），然后利用同样的父子结点比对方法。 通常，对于大根堆会比较较大的子结点，对于小根堆会比较较小的子结点，出现不符合特性的情况就互换两个结点，一直重复这个过程，直至父子结点之间满足堆的特性。 这种方法堆化之后的结果，肯定满足完全二叉树的特性。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:2:4","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"复杂度 一个包含 n 个节点的完全二叉树，树的高度不会超过 $\\log_2 n$。 堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 $O(\\log_2 n)$。 插入元素和删除元素的主要逻辑就是堆化，所以往堆中插入一个元素和删除一个元素的时间复杂度都是 $O(\\log_2 n)$。 ","date":"2022-05-26","objectID":"/posts/data-structure-algorithm/heap-basic.html:2:5","tags":["数据结构","堆"],"title":"堆的简单认识","uri":"/posts/data-structure-algorithm/heap-basic.html"},{"categories":["数据结构与算法"],"content":"二叉树是树形结构的一种重要类型，许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，因此二叉树显得格外重要。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:0:0","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"树的定义 树是一种抽象数据类型，用来模拟具有树状结构性质的数据集合，如上图就是一个树形结构。 树的专业术语比较多，需要了解以下内容： 树的结点：包含一个数据元素及若干指向子树分支的信息 结点的度：一个结点含有的子树数目称为该结点的度 树的度：树中最大的结点度称为树的度 叶子结点：也称终端结点，结点度为零的结点 分支结点：也称非终端结点，结点度不为零的结点 子结点：一个结点含有的子树的根结点称为该结点的子结点 父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点 兄弟结点：具有相同父结点的结点互称为兄弟结点 堂兄弟结点：父结点在同一层的结点互为堂兄弟结点 结点的祖先：从根到该结点所经分支上的所有结点称为该结点的祖先 子孙：以某结点为根的子树中任一结点都称为该结点的子孙 结点的层次：从根开始定义起，根为第 1 层，根的子结点为第 2 层，以此类推 深度：对于任意结点 n，n 的深度为从根到 n 的唯一路径长，根的深度为 0 高度：对于任意结点 n，n 的高度为从 n 到叶子结点的最长路径长，所有叶子结点的高度为 0 森林：由 m(m\u003e=0) 棵互不相交的树组成的集合称为森林 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:1:0","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"常见二叉树 顾名思义，二叉是指每个结点最多只有两个子结点，这两个子结点分别称为左子结点和右子结点。 但是，二叉树并不要求所有结点必须拥有两个子结点，有的结点只有左子结点，有的结点只有右子结点。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:2:0","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"满二叉树 如上述图 a 所示，除叶子结点以外，所有非叶子结点都有 2 个子结点，这种二叉树被称为满二叉树。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:2:1","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"完全二叉树 如上述图 b 所示，除最后一层外，每一层的结点数均达到最大值，而且最后一层的叶子结点都靠左排列，只缺少右边的若干结点，这种二叉树被称为完全二叉树。 从定义上来说，满二叉树是一种特殊的完全二叉树。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:2:2","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"二叉查找树 二叉查找树是一种特殊的二叉树，常用作搜索使用，也被称为二叉搜索树、二叉排序树。 它有可能是一棵空树，也可能是具有以下性质的二叉树： 若根结点的左子树不空，则左子树上所有结点的值均小于根结点的值 若根结点的右子树不空，则右子树上所有结点的值均大于等于根结点的值 根结点的左、右子树也分别为二叉查找树 二叉查找树是一种经典的数据结构，它既具有链表快速插入、删除的特点，又具有数组快速查找的优势。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:2:3","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"存储结构 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:3:0","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"链式存储 使用链表存储树的结构是一种比较简单、直观的方法。 二叉树中每个结点最多只有两个子结点，因此，可以给结点设计一个数据域和两个指针域，两个指针域分别指向左子结点和右子结点。 这种情况下，使用链表作为存储方式，只要拎住根结点，就可以通过左右子结点的指针，把整棵树都串起来。 这种方式比较常用，大部分二叉树代码都是通过这种方式实现的。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:3:1","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"顺序存储 二叉树的顺序存储结构是基于数组实现的，用一维数组存储二叉树中的结点，并且数组的下标能够体现出二叉树结点之间的逻辑关系。 在这个存储二叉树结点的数组中，为了使得后续的结点逻辑关系易于理解，下标为 0 的存储位置是不使用的。一般是把根结点存储在 i = 1 的位置上，它的左子结点存储在 2i = 2 的位置上、右子结点存储在 2i + 1 = 3 的位置上。以此类推，左子结点的左子结点存储在 2i = 4 的位置，它的右子结点存储在 2i + 1 = 5 的位置。 总结二叉树结点在数组中的逻辑关系：如果结点 x 存储在数组中下标为 i 的位置，则结点 x 的左子结点存储在数组中下标为 2i 的位置，右子结点存储在数组中下标为 2i+1 的位置。 可以发现，上述展示的是一个完全二叉树，使用数组存储完全二叉树时，除了下标为 0 的位置没有存储数据之外，其他的位置都会被填满了。 但如果是非完全二叉树，则会出现浪费数组中内存空间的情况。如下图所示： 因此，一般使用顺序存储结构存储完全二叉树，在这种情况下，相比较链式存储结构会更节省内存。 堆其实就是一种完全二叉树，最常用的存储方式就是数组。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:3:2","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"二叉树的遍历 二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得某个结点仅且被访问一次。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:4:0","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"深度优先遍历 深度优先遍历方式是指尽可能深地搜索树的分支，即先遍历到叶子结点再更改搜索路径。 二叉树经典的深度优先遍历方式有三种：前序遍历、中序遍历、后序遍历。其中，前、中、后序，表示的是结点与它的左右子树结点遍历打印的先后顺序： 前序遍历是指，对于树中的任意结点来说，先打印这个结点本身，然后再打印它的左子树，最后打印它的右子树 中序遍历是指，对于树中的任意结点来说，先打印它的左子树，然后再打印这个结点本身，最后打印它的右子树 后序遍历是指，对于树中的任意结点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个结点本身 其实，二叉树的前、中、后序遍历就是一个递归的过程。比如，前序遍历就是先打印根结点，然后再递归地打印左子树，最后递归地打印右子树。 下述是递归实现前、中、后序遍历的伪代码展示： void preOrder(Node* root) { if (root == null) return; // 打印根结点 print root; // 递归打印左子树 preOrder(root-\u003eleft); // 递归打印右子树 preOrder(root-\u003eright); } void inOrder(Node* root) { if (root == null) return; // 递归打印左子树 inOrder(root-\u003eleft); // 打印根结点 print root; // 递归打印右子树 inOrder(root-\u003eright); } void postOrder(Node* root) { if (root == null) return; // 递归打印左子树 postOrder(root-\u003eleft); // 递归打印右子树 postOrder(root-\u003eright); // 打印根结点 print root; } 除了使用递归的方式实现深度优先遍历外，还可以使用栈这种数据结构以非递归方式实现，前序遍历方式如下： 将 A 结点压入栈中，栈的结构是 [A]； 将 A 结点弹出，然后将 A 结点的子结点 B、C 压入栈中，栈的结构是 [C, B]； 将 B 结点弹出，然后将 B 结点的子结点 D、E 压入栈中，栈的结构是 [C, E, D]； 将 D 结点弹出，D 结点没有子结点，无需做处理，栈的结构是 [C, E]； 将 E 结点弹出，E 结点没有子结点，无需做处理，栈的结构是 [C]； 依次类推，最终以 A、B、D、E、C、F、G 的次序弹出结点元素。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:4:1","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"广度优先遍历 广度优先遍历又称为层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层再访问下一层。 层次遍历需要使用到队列这种数据结构，队列的特点是先进先出。整个遍历过程如下： 将 A 结点入队，队列的结构是 [A]； 将 A 结点出队，然后将 A 结点的子结点 B、C 入队，队列的结构是 [B, C]； 将 B 结点出队，然后将 B 结点的子结点 D、E 入队，队列的结构是 [C, D, E]； 将 C 结点出队，然后将 C 结点的子结点 F、G 入队，队列的结构是 [D, E, F, G]； 将 D 结点出队，D 结点没有子结点，无需做处理，栈的结构是 [E, F, G]； 以此类推，最终 A、B、C、D、E、F、G 的次序弹出结点元素。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:4:2","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"优缺点 对于深度优先遍历算法，都是优先搜索完一颗子树，有着内存占用相对较小的优点，通常额外存储结点数是树的深度；非递归的深度优先遍历方式会进行回溯，相对效率比较低。 对于广度优先遍历算法，对于解决最短或最小问题特别有效，而且结点只访问一遍，效率相对较高；使用广度优先算法需要存储一层结点的状态，内存占用相对较高。 ","date":"2022-05-24","objectID":"/posts/data-structure-algorithm/binary-tree-basic.html:4:3","tags":["数据结构","树"],"title":"二叉树的简单认识","uri":"/posts/data-structure-algorithm/binary-tree-basic.html"},{"categories":["数据结构与算法"],"content":"队列这个概念非常容易理解，将队列比喻成只能同时通过一辆汽车的隧道，当汽车进入到隧道内部，只能先进隧道的汽车先出隧道，后进隧道的汽车后出隧道。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:0:0","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"基本概念 队列也是一种受限的线性表，特殊之处在于它只允许在一端插入，在另一端删除。因此，先进入队列的元素能最先从队列中删除，故队列又被称为 先进先出表。 队列与栈非常相似，支持的操作也很有限。以下是队列的一些概念： 进行插入操作的端称为 队尾 进行删除操作的端称为 队头 队列中没有元素时，称为 空队列 向队列中插入一个元素称为 入队 删除队列中的一个元素称为 出队 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:1:0","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"实现类型 在物理存储层面，队列既可以用数组实现，也可以用链表实现，在这两种数据结构的基础上增加队列的限制即可。 使用数组实现的队列被称为顺序队列，使用链表实现的队列被称为链式队列。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:2:0","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"顺序队列 使用数组实现的顺序队列比实现完整功能的数组更加简单，不需要实现往数组中插入元素和删除数组内元素的功能。 首先，需要申请一个大小为 n 的数组；然后，创建一个队头标识和队尾标识；当入队时，需要将队尾标识后移一位；当出队时，也需要将队头标识后移一位。 当数组无限大的时候，上述的实现方式没有任何问题。但数组向来是限制大小的，而且出队之后，数组的前半部分已经没有数据存储了，非常浪费空间。 对于这种情况，通常采用 搬移数据 的办法，当队尾标识已经达到 n 的下标时，则做一次数据搬移，并且将队头标识和队尾标识指向新的下标。 以这种实现思路，入队的均摊时间复杂度为 $O(1)$，出队的时间复杂度一直都是 $O(1)$。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:2:1","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"链式队列 使用链表实现的链式队列比使用数组实现的顺序队列更加简单，由于链表的特性，减少了搬移数据这一步。 链表不需要提前申请内存空间，也不需要担心内存空间不够的问题，只需要创建好队头标识和队尾标识即可，因此链式队列也是常见的队列实现方式。 如果是采用尾插法实现的链表，可以将链表的哨兵结点的指向作为队头标识，这样只需要新增一个队尾标识即可。当新的元素入队时，将这个元素链接到尾结点，然后修改队尾标识的指向；需要出队时，则做删除头结点的操作，修改哨兵结点的指向。 以链表实现的队列，无论是入队还是出队，时间复杂度都可以达到 $O(1)$。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:2:2","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"循环队列 顺序队列在入队时会有搬移数据的情况，存在一定的性能损耗，循环队列则是在这一方面做了部分优化，减少这一步操作。 如果把数组看作一条直线，就可以把循环队列看作一个环，通过将队列做成环的方式，可以避免数据搬移的操作。 如上图所示，通常会有一个 front 指针指向队头所在地址，有一个 rear 指针指向队尾的下一个地址，其原因主要是：若 front 和 rear 分别指向队头和队尾，无法判别队空和存在一个元素的状态。 若采用 rear 指针指向队尾的下一个地址的方式，则可以使用 front 和 rear 指向同一个地址来判别队空；同时，由于循环队列是逻辑上循环，通常使用求余运算判断队满，并且为了避免队空出现的 rear % n = front 和队满出现的 (rear + n) % n = front 造成差错，因此总是留出一个空位，使用 (rear + 1) % n = front 判断队满。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:2:3","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"双端队列 双端队列是一种具有队列和栈的性质的数据结构，即常说的 deque(double-ended queue)，是一种限定插入和删除操作在表的两端进行的线性表。 现实生活中双端队列的例子：假如在电影院买票，一个刚刚买完票的人想咨询一下简单信息，就可以直接回到队伍的头部，如果在队尾排队的人不想看电影了，就可以从队尾直接离开队伍。 尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列普遍。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:2:4","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"应用场景 队列的应用场景非常广泛，尤其是一些带有特殊性质的队列，在各自的应用场景如鱼得水。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:3:0","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"阻塞队列 阻塞队列在队列的基础上增加了阻塞的特性。 当队列为空的时候，出队的操作会被阻塞，直到队列中有数据；当队列满了的时候，入队的操作也会被阻塞，直到队列中有空闲位置可以插入数据。 常见的场景就是“生产者 - 消费者”模型，使用阻塞队列可以有效地协调生产和消费的速度。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:3:1","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"并发队列 并发队列指的是在多线程情景下，多个线程同时操作队列，而这个队列如果是线程安全的，则被称为并发队列。 实现并发队列最简单的方式就是在入队、出队的时候加锁，但是这会影响队列的并发量，队列在同一时刻仅能处理一个存取操作。 实际上，使用循环队列和 CAS 原子操作，就可以实现非常高效的无锁并发队列。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:3:2","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"优先队列 优先队列是在队列的概念上，对元素赋予优先级，访问时是具有最高优先级的元素先出队。 通常优先队列会使用堆来实现，如大根堆就很好的表示了根结点是优先级最高的元素。当出队时可以先删除根结点，然后从上往下堆化；入队时则需要从下往上堆化。 可以看出，优先队列其实是堆的一种使用方式，赋予了队列的名称，保持和普通队列相同的操作方法。 ","date":"2022-05-23","objectID":"/posts/data-structure-algorithm/queue-basic.html:3:3","tags":["数据结构","队列"],"title":"队列的简单认识","uri":"/posts/data-structure-algorithm/queue-basic.html"},{"categories":["数据结构与算法"],"content":"数据结构中的栈是一种操作受限的线性表，只允许在一端插入和删除数据，但却是计算机科学领域中非常重要的数据结构，常使用在底层结构。 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:0:0","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"栈的概念 从功能上来说，同为线性表的数组和链表完全可以替代栈的使用。 但是，从某种角度来说，数组和链表暴露太多的操作接口，使用起来比较复杂，非常容易出错。 因此，当数据集合只需要在一端插入和删除数据，并且满足先进后出、后进先出的特性，可以首选“栈”这种数据结构。 以下是栈的一些概念： 允许进行插入和删除操作的一端称为 栈顶，栈顶会根据插入、删除操作进行浮动 不允许进行插入和删除操作的一端称为 栈底，栈底是固定不变的 栈中元素个数为零时称为 空栈 往栈中插入元素称作 进栈 删除栈顶的元素称作 出栈 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:1:0","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"栈的实现 在物理存储层面，栈既可以用数组实现，也可以用链表实现，在这两种数据结构的基础上增加栈的限制即可。 使用数组实现的栈被称为顺序栈，使用链表实现的栈被称为链式栈。 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:2:0","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"顺序栈 使用数组作为栈存储数据的物理存储结构，需要先申请一个大小为 n 的数组。 将数组的尾部作为栈顶，入栈和出栈都只在栈顶做相应处理，使用一个变量表示数组存储的元素个数，这样入栈、出栈的操作都能达到 $O(1)$ 的时间复杂度。 基于数组实现的栈存在一个限制，即数组在声明之后是固定大小的，当栈满的时候，则无法再次往数组中添加数据。这样就涉及到对数组进行动态扩容，当数组空间不够的时候，需要重新申请一块更大的内存，将原来数组中数据统统拷贝过去。 实际上，支持动态扩容的顺序栈在实际开发中并不常见。使用到顺序栈这种数据结构的情况，一般都是规模比较小的数据，知道数据的最大规模时可以避免爆栈。 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:2:1","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"链式栈 对于数据规模比较大的情况，使用链表实现栈则会更加方便。这时候，不需要提前申请内存空间，而是需要创建一个哨兵结点指向头结点。 链式栈一般会使用头插法创建链表。将头结点作为栈顶，每次入栈都当作链表在头结点插入元素，每次出栈都当作链表删除头结点。这些操作都只需要处理好哨兵结点的指向即可，使用链式栈能达到 $O(1)$ 的时间复杂度。 基于链表实现的栈不需要像数组一样要动态扩容，链表是天生支持动态扩容的。 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:2:2","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"应用场景 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:3:0","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"函数调用栈 函数调用栈是一个非常经典的应用场景。 操作系统会给每个线程分配一块独立的内存空间，这块内存被组织成“栈”这种数据结构，用来存储函数调用时的临时变量。 每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回到上层函数之后，再将这个函数对应的栈帧出栈。 直到函数栈为空，则表示最外层的函数已经执行完毕。 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:3:1","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"逆波兰表达式 编译器还会利用栈来实现表达式求值，这部分也有非常成熟的四则运算算法——逆波兰表达式。 通常的四则运算表达式写成 (1 + 2) x (3 + 4)，加减乘除等运算符写在中间，因此也被称作“中缀表达式”；逆波兰表达式的写法是 1 2 + 3 4 + x，运算符被写在后面，因而也被称作“后缀表达式”；除此之外，还有波兰表达式，其写法是 x + 1 2 + 3 4，被称作“前缀表达式”。 如果将表达式画出一棵语法树，就能以树的概念来直观理解前缀、中缀、后缀的含义，前缀表达式对应树的前序遍历，中缀表达式对应树的中序遍历，后缀表达式对应树的后序遍历，如下图所示： 如果要使用逆波兰表达式来做四则运算，需要先将中缀表达式转换成逆波兰表达式，涉及到操作数栈和运算符栈： 从左向右遍历中缀表达式； 若读取的是操作数，将操作数存入到操作数栈中； 若读取的是运算符，还需要根据运算符类型进一步判断： 如果是 ( 运算符，则直接存入运算符栈中； 如果是 ) 运算符，则输出运算符栈中的运算符到操作数栈，直到遇到 ( 运算符，在这里放弃 ( 和 ) 运算符； 如果是非括号运算符，还需要与运算符栈栈顶的运算符比较优先级： 如果运算符栈栈顶的运算符是括号，则将当前运算符直接存入运算符栈中； 如果当前运算符比运算符栈栈顶的运算符优先级更高时，则直接存入运算符栈中； 如果当前运算符比运算符栈栈顶的运算符优先级更低或相等时，则输出栈顶运算符到操作数栈，然后将当前运算符压入操作符栈； 当表达式读取完后，将运算符栈中的运算符依次出栈到操作数栈中，直到运算符栈为空。 经过上述步骤后，则可以将中缀表达式转换成逆波兰表达式，随后对逆波兰表达式做运算得到表达式的结果： 从左向右遍历逆波兰表达式； 若读取的是操作数，将操作数存入栈中； 若读取的是运算符，则对栈顶的两个操作数执行该运算，然后将运算结果存入栈中； 重复上述的步骤 1~3，最终栈中的元素即为结果值。 ","date":"2022-05-21","objectID":"/posts/data-structure-algorithm/stack-basic.html:3:2","tags":["数据结构","栈"],"title":"栈的简单认识","uri":"/posts/data-structure-algorithm/stack-basic.html"},{"categories":["数据结构与算法"],"content":"链表是两大物理存储结构之一，与数组使用一组连续的内存空间不同，链表通过链接的方式将零散的内存空间串联起来使用，是线性表的另一种存储方式。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:0:0","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"认识链表 链表和数组一样，也是一个线性表结构，但有一点与数组不同，链表不使用连续的内存空间进行存储，而是通过串联的方式连接元素。 因此，链表克服了数组需要预先知道数据大小的缺点，并且能充分利用计算机内存空间，实现灵活的内存动态管理。 但链表也失去了高效存取的优点，同时，由于增加了结点的指针域，空间开销相较于数组会更大。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:1:0","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"链表的概念 链表通过指针将零散的内存块串联在一起，这里的内存块被称为链表的 结点。 结点除了存储数据之外，还会存储下一个结点的地址，这个记录下一个结点地址的指针被称为 后继指针。在双向链表中，结点还会存储上一个结点的地址，这个记录上一个结点地址的指针被称为 前驱指针。 链表中存在两个比较特殊的结点，分别是第一个结点和最后一个结点。因此也给这两个结点取了名称，第一个结点被称为 头结点，最后一个结点被称为 尾结点。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:1:1","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"低效存取 将链表和数组作比较，数组具有高效存取的优点，而链表是是存取效率非常低的数据结构。 这里的存取指的是通过下标的方式去访问数据，链表无法像数组一样使用寻址公式，只能通过头结点作为入口，根据指针一个结点一个结点地依次遍历，直到找到对应的结点。 综合计算下来，链表做随机访问的时间复杂度为 $O(n)$，效率比数组低得多。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:1:2","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"高效增删 虽然链表在随机存取方面没有数组高效，但在插入、删除结点的时候，效率比数组高很多。 假设，要在链表中插入一个结点，在知道插入位置的前后两个相邻结点的前提下，只需将新结点的后继指针指向下一个结点，然后将上一个结点的后继指针指向这个新结点，即可完成插入结点的操作。删除结点也是类似的操作，非常方便。 但是，链表插入、删除结点的高效率依靠于知道操作位置的相邻结点，否则仍需要从头结点开始寻找到对应位置，这样的效率会非常低。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:1:3","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"五花八门的链表 链表有很多不同的类型，在上面说的都是最简单的单向链表，复杂一点的还有双向链表、循环链表等等。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:2:0","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"单向链表 单向链表是最简单的链表结构，它包含两个域，一个信息域和一个指针域。 信息域存储实际的数据，指针域存储下一个结点位置。 在实际编码中，为了方便，会使用哨兵结点占据头结点的位置，其信息域是空的，指针域存储实际的头结点所在位置，尾结点的指针域一般会是 NULL 地址。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:2:1","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"双向链表 双向链表在单向链表的基础上多增加了一个指针域，这个新增加的指针域会存储上一个结点所在位置。 也就是说，在双向链表中，除头结点外，任意结点都可以访问到上一个结点，因此称为双向链表。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:2:2","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"双端链表 双端链表与双向链表是完全不同的两个概念。 双端链表是在单向链表的基础上，增加了尾结点的引用。拥有这个引用的双端链表在尾部插入结点时特别方便，因此常被用作实现链式队列。 虽然双端链表可以很方便地在尾部插入结点，但由于无法快捷地获取倒数第二个结点，因此仍然不能方便地删除尾结点，若需要此功能可以靠双向链表实现。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:2:3","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"循环链表 循环链表是一个头结点和尾结点连接在一起的特殊链表，通过单向链表或双向链表都能够实现。 循环链表的优点就是从链表的尾结点到头结点非常方便，也方便处理具有环形结构特点的数据，如约瑟夫问题。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:2:4","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"块状链表 快状链表本身是一个链表，但是链式存储的并不是一般的数据，而是由一些数据组成的顺序表结点，这些结点也被称作块。 块状链表通过使用可变的顺序表的长度和特殊的插入、删除的方式，可以达到 $O(\\sqrt{N})$ 的时间复杂度。 块状链表的另一个特点是相对普通链表来说更节省内存，因为不用保存指向每一个数据结点的指针。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:2:5","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"常见问题 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:3:0","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"数组和链表 仅特性和效率而言，数组拥有高效随机存取的特性，链表在插入、删除结点时效率更高。因此，经常利用下标访问元素可以使用数组，经常插入、删除元素可以使用链表。 但是，不能仅仅只用复杂度分析决定使用哪种数据结构。数组简单易用，而且能够借助 CPU 缓存机制预读数组中的数据；而链表在内存中不是连续存储的，对 CPU 缓存不友好，没办法有效预读。 数组的缺点是数据大小固定，而且一经声明要占用整块连续内存空间，如果声明的数组过大，系统可能没有足够的连续内存空间分配给它。即使是在 Java 中使用可以动态扩容的 ArrayList 类型，也存在扩容耗时的问题。而链表本身没有这样的限制，天生支持动态扩容。 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:3:1","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"实现技巧 编写一个正确的链表是比较难的，但是其中也有以下技巧可以参考： 理解指针或引用的含义。将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，这个内存地址存储这个变量，通过指针能找到这个变量 警惕指针丢失。插入结点时，先将插入结点的后继指针指向下一个结点，再把前一个结点的指针指向插入结点，这样才不会丢失指针 避免内存泄漏。删除结点时，要记得手动释放内存空间 利用哨兵简化实现难度。在实际开发当中，如果向空链表中插入第一个结点的时候，还需要判断链表中是否已经存在头结点，嵌入代码比较严重；但是，如果增加一个哨兵结点，哨兵结点的后继指针指向头结点，则可以省略这一步操作 重点留意边界条件处理。当链表为空的时候，代码是否能正常工作？当链表只有一个结点的时候，代码是否能正常工作等等 举例画图，辅助思考。链表的指针指向会比较复杂，这种情况可以通过举例画图的办法将各种情况列举出来，这样思路会更加清晰 多写多练，熟能生巧。写链表代码是非常考验逻辑思维能力的，多多尝试练习可以提高逻辑思维能力 ","date":"2022-05-20","objectID":"/posts/data-structure-algorithm/linked-list-basic.html:3:2","tags":["数据结构","链表"],"title":"链表的简单认识","uri":"/posts/data-structure-algorithm/linked-list-basic.html"},{"categories":["数据结构与算法"],"content":"数组是最基础的数据结构，也是两大物理存储结构之一，只有深刻理解了数组的概念和特性，才能算是迈入学习数据结构的殿堂，才能将抽象的数据结构映射到代码当中。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:0:0","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"理解数组 数组本质上是一种 线性表 数据结构，它用一组 连续的内存空间，来存储一组具有 相同类型的数据。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:1:0","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"线性表 如上图所示，线性表就是数据排成一条线一样的结构，在线性表中，每个数据都只有前后两个方向。 与线性表相对的是非线性表结构，在非线性表中，每个数据会存在多个方向，数据之间不仅仅只是简单的前后关系，而是呈现发散型的关系。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:1:1","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"连续的内存空间 在数组中，存储数据的内存空间是连续的。 也就是说，当一段内存空间标明用于存储数组元素，则这一片空间只会存储数组元素，不会再拆分出来存储其他的数据。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:1:2","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"相同类型的数据 在数组的原始定义中，数组只能存储相同类型的数据，这样可以保证数组中每个元素占用的内存空间都能保持一致。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:1:3","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"数组的增删查改 讨论数组的增删查改，从效率的角度上区分，主要可以分为两类：高效存取、低效增删。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:2:0","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"高效存取 这里的“存取”指的是通过下标访问数组元素，然后对这个元素做存取操作。 数组能做到高效存储的根本原因在于，其拥有“连续的内存空间”和“相同类型的数据”这两个限制。正因为这两个限制，计算机可以通过一个寻址公式来寻找数组元素的地址，如下是寻址公式的简单理解： address[i] = base_address + data_type_size * i 其中，base_address 表示数组的起始地址，data_type_size 表示每个元素占用的空间大小。 简单的理解就是，由于存储数组元素的内存空间是连续的，因此可以使用一个相对于起始位置的偏移量即可找到数组元素，又因为数组中存储的都是相同类型的元素，可以采用下标计算每一个元素的相对偏移量。 通过寻址公式，数组可以通过下标快速查找到数组中的元素，其时间复杂度能达到 $O(1)$。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:2:1","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"低效增删 虽然数组可以通过下标实现高效的随机存取，但是对数组做插入、删除操作非常低效。 这里的低效体现在插入元素或删除元素之后，需要对数组中的其他元素做搬移操作，以保证数组元素的连续性。 在一个长度为 n 的数组中，假设要在第 k 个位置插入一个元素，这不是修改元素的操作，不能直接替换掉第 k 个元素，而是需要依次将第 k 个及之后的元素都往后挪一位，然后才能在第 k 个位置上存入这个元素。 删除元素和插入元素类似，为了避免删除元素之后导致数组中间出现空洞，需要将删除位置之后的元素往前挪一位。 通过计算得知，数组插入、删除元素的最好时间复杂度为 $O(1)$、最坏时间复杂度为 $O(n)$，平均时间复杂度为 $O(n)$。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:2:2","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"特殊数组 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:3:0","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"二维数组 二维数组指的是以数组作为数组元素的数组，即“数组的数组”，又被称为矩阵。 从存储结构上看，将普通的一维数组看作是一个如同直线的线性表，二维数组就可以看作是多个线性表并排的平面。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:3:1","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"稀疏数组 在数组中，若为 0 的元素数目远远多于非 0 元素，并且非 0 元素分布没有规律时，则可以用稀疏数组保存该数组的元素。 对于二维数组，行和列可以作为元素的坐标，通过坐标可以确定一个元素的位置，稀疏数组就是通过存储坐标和元素值以保证重新转换回二维数组。 稀疏数组通常是用作减少存储空间浪费，压缩数组规模，只保存有用数据。这是一个典型的时间换空间的应用。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:3:2","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"常见问题 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:4:0","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"数组越界 虽然数组可以通过寻址公式做到高效随机访问，但是这并没有限制使用超出数组长度的下标访问数组，我们通常把访问的数组下标超出数组长度的情况称为数组越界。 在 C 语言中，编译器不会检测出数组越界的问题，如果出现数组越界的情况而又没处理的话，极可能出现如代码进入死循环等不可预知的情况。 int main(int argc, char* argv[]) { int i = 0; int arr[3] = {0}; for(; i\u003c=3; i++){ arr[i] = 0; printf(\"hello world\\n\"); } return 0; } 如上述代码，在字节对齐和内存分配的特性下，先后定义的 i 和 arr 共占据了 8 个字节，表现为 {arr[0], arr[1], arr[2], i} 的形式，当循环到下标为 3 时，实际 arr[3] 指向的就是 i 所在地址，会出现 arr[3] = i = 3，以至于代码运行进入死循环。 相比较下，使用 Java 会更加安全，Java 不会把检查数组越界的工作丢给程序员来做，其本身就会做越界检查，如果出现错误会抛出 java.lang.ArrayIndexOutOfBoundsException 异常，而不是出现死循环。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:4:1","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"容器和数组 这里说的容器指的是封装了数组的操作方法、并且支持动态扩容的容器类，比如 Java 中的 ArrayList 类。 与原生数组相比，虽然 ArrayList 拥有非常大的优势，但并不是所有地方都使用 ArrayList 而不是数组，在某些情况下，使用数组会更方便、更有效率。 在以下情况下，可以选择原生数组： 追求极致性能。Java 的 ArrayList 不支持存储基本类型，而是存储基本类型封装后的对象，自动装箱、拆箱会有一定的性能消耗 操作简单，仅使用原生功能。虽然 ArrayList 提供了非常多额外的功能，但也额外增加了风险，使用原生数组更简单便捷 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:4:2","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":["数据结构与算法"],"content":"从 0 开始编号 数组的下标从 0 开始编号可以通过数组的寻址公式来回答。 在 C 语言中，数组的下标不是指数组的第几个元素，而是指数组元素的偏移。 如果使用 0 作为数组的起始下标，则可以使用下述的表达式作为寻址公式： address[i] = base_address + data_type_size * i 如果使用 1 作为数组的起始下标，将不能直接使用上面的寻址公式，而是需要修改如下： address[i] = base_address + data_type_size * (i - 1) 在对比前后两个寻址公式之后，使用 1 作为起始下标的寻址公式会比使用 0 作为起始下标的寻址公式多一个简单的减法指令。 对于非常底层的程序来说，即使只是多出一个简单的减法指令，也是一种性能的损耗，为了做到极致优化，选择 0 作为起始下标会更好。 当然还有一个历史原因，C 语言使用了 0 作为数组的起始下标，后续出现的编程语言都纷纷仿效，这也算是为了统一，降低程序员的学习成本。 ","date":"2022-05-19","objectID":"/posts/data-structure-algorithm/array-basic.html:4:3","tags":["数据结构","数组"],"title":"数组的简单认识","uri":"/posts/data-structure-algorithm/array-basic.html"},{"categories":null,"content":"简介 翔仔，一名妄想用努力奋斗来掩饰自己平庸的程序员。 在技术这条路上，虽然已经有很多前辈，但因自己的性格所致，一直也是踽踽独行。 本就不太会说话，即使写也写不出什么好的文章，希望用这样的方式，能够提升自己写作的水平。 现在的能力一般，但仍然想着坚守：「不忘初心，方得始终」。 想要探讨技术问题，可以联系我：799298142@qq.com ","date":"2022-05-19","objectID":"/about.html:1:0","tags":null,"title":"关于","uri":"/about.html"},{"categories":null,"content":"技术栈 2018-2021: 刚毕业初入到「好分数」，公司内使用 nodejs 作为主要编程语言，也陆陆续续学会 Express、MongoDB、Redis、RabbitMQ、ElasticSearch 等等相关技术。 2021-2022: 在线教育的更迭大背景下，离职后进入到「探迹」，公司内使用 Python 作为主要编程语言，其过程使用 Flask、MongoDB、ElasticSearch 等技术更多。 作为一名后端开发程序员，一直有着想要成为架构师的梦，当然，更多的是想要自己不再做打工人🤡。 ","date":"2022-05-19","objectID":"/about.html:2:0","tags":null,"title":"关于","uri":"/about.html"}]